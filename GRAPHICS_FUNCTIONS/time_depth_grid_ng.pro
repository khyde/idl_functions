; $Id:	time_depth_grid.pro,	June 13 2007	$

PRO TIME_DEPTH_GRID_NG, DATE, DEPTH, VARIABLE, BLANK_WINDOW=BLANK_WINDOW,MISSING_COLOR=MISSING_COLOR,FONT_SIZE=FONT_SIZE,$
  RETURN_IMAGE=RETURN_IMAGE,OUT_IMAGE=OUT_IMAGE,$
  DEPTH_INTERVAL=DEPTH_INTERVAL, NEAR=NEAR, MDATE=MDATE, MDEPTH=MDEPTH, VRANGE=VRANGE, AX_INTERVAL=AX_INTERVAL, $
	TOP_COLOR=TOP_COLOR, AY_GRID=AY_GRID, _EXTRA=_EXTRA, XTITLE=XTITLE,YRANGE=YRANGE,FYEAR=FYEAR,ADD_YEAR_TITLE=ADD_YEAR_TITLE,$
	ADD_DATE_TICKS=ADD_DATE_TICKS,DATE_SYMBOL=DATE_SYMBOL,DATE_FILL=DATE_FILL,DATE_COLOR=DATE_COLOR,DATE_SIZE=DATE_SIZE,$
	ADD_SAMPLE_POINTS=ADD_SAMPLE_POINTS,SAMPLE_SYMBOL=SAMPLE_SYMBOL,SAMPLE_FILL=SAMPLE_FILL,SAMPLE_COLOR=SAMPLE_COLOR,SAMPLE_SIZE=SAMPLE_SIZE,$
	YTITLE=YTITLE, ORIENTATION=ORIENTATION, TITLE=TITLE, CUTOFF=CUTOFF, DIMENSIONS=DIMENSIONS,NODATE=NODATE,LAYOUT=LAYOUT,PAL=PAL,XMINOR=XMINOR,XMAJOR=XMAJOR,YMINOR=YMINOR,YMAJOR=YMAJOR,MARGIN=MARGIN,$
	PROD=PROD, SPECIAL_SCALE=SPECIAL_SCALE, LOG=LOG, INTERPOLATE=INTERPOLATE, NOXDATES=NOXDATES, MAKE_MISSING=MAKE_MISSING,NODEPTH=NODEPTH,EXTRA=EXTRA,TARGET=TARGET


;+
; NAME:


; Program designed to create a contour a variable in a depth over time grid

; INPUTS
;		DATES						Date array (yyyymmdd or yyyymmddhhmmss)
;		DEPTH:						Depth in positive units
;		VARIABLE:					Given variable to plot (temperature, salinity, chlorophyll, etc.)
;		MDATE:						2 element array of the maximum and minimum dates (yyyymmdd)
;		MDEPTH:						2 element array of the maximum and minimum depths in positive units
;		VRANGE:						The range of the input variable in order to scale the color contours
;		AX_INTERVAL:			The xaxis interval for DATE_AXIS ('DAY', 'MONTH', 'YEAR', etc.)
;		AY_GRID:					The xaxis grid interval for DATE_AXIS ('DAY', 'MONTH', 'YEAR', etc.)
;		DEMINSIONS				2 element array of the grid deminsions
;		DEPTH_INTERVAL:		The depth interval to fill in the missing data with (0.5 meters, 2 meters, etc.)
;		NEAR:							Input variable to WHERE_NEAREST for filling in the new structure


; KEYWORDS
;		LOG:							To scale the color contour in log units
;		PROD:             Used to scale the color contour based on the product
;		SPECIAL_SCALE:	  Used in the call to SD_SCALES when the PROD is provided
;		TOP_COLOR:				Maximum color for bytscl (default=250)
;		INTERPOLATE:			To interpolate values within the profile
;		NOXDATES:					To omit the X axis dates
;		MAKE_MISSINGS:		To input into INTERP_XTEND
;		NODEPTH:					To interpolate in only the x direction (no depths)



	IF KEYWORD_SET(NODEPTH) THEN BEGIN
		IF N_ELEMENTS(DATE) EQ N_ELEMENTS(VARIABLE) THEN BEGIN
		_DATE = DATE
		_VAR	= VARIABLE
		ENDIF ELSE PRINT, 'ERROR: arrays not equal'
	ENDIF ELSE BEGIN
		IF N_ELEMENTS(DATE) EQ N_ELEMENTS(DEPTH) OR N_ELEMENTS(DATE) EQ N_ELEMENTS(VARIABLE) THEN BEGIN
			_DATE = DATE
			_DEPTH = DEPTH
			_VAR	= VARIABLE
		ENDIF ELSE PRINT, 'ERROR: x,y,v arrays not equal'
	ENDELSE

	IF N_ELEMENTS(PROD) EQ 1 THEN _PROD = PROD ELSE _PROD = ''
	IF N_ELEMENTS(PAL)  NE 1 THEN _PAL  = 'PAL_DEFAULT' ELSE _PAL=PAL
	IF N_ELEMENTS(MISSING_COLOR) NE 1 THEN MISSING_COLOR = 255
	IF N_ELEMENTS(FONT_SIZE)     NE 1 THEN FONT_SIZE = 14
	IF N_ELEMENTS(ORIENTATION)   NE 1 THEN ORIENTATION = 0 

	IF N_ELEMENTS(TOP_COLOR) EQ 0 THEN _TOP_COLOR=250 ELSE _TOP_COLOR=TOP_COLOR

	IF N_ELEMENTS(MDATE) EQ 2 THEN BEGIN
		IF NOT KEYWORD_SET(NODATE) THEN BEGIN
			MAXDATE=MAX(MDATE)
			MINDATE=MIN(MDATE)
			MAXJD = DATE_2JD(MAXDATE)
			MINJD = DATE_2JD(MINDATE)
			IF N_ELEMENTS(AX_INTERVAL) EQ 1 THEN BEGIN
				IF AX_INTERVAL EQ 'SECOND' 	THEN AX = DATE_AXIS([MINJD,MAXJD],/SECOND)
				IF AX_INTERVAL EQ 'MINUTE' 	THEN AX = DATE_AXIS([MINJD,MAXJD],/MINUTE)
				IF AX_INTERVAL EQ 'HOUR' 		THEN AX = DATE_AXIS([MINJD,MAXJD],/HOUR)
				IF AX_INTERVAL EQ 'DAY' 		THEN AX = DATE_AXIS([MINJD,MAXJD],/DAY)
				IF AX_INTERVAL EQ 'MONTH' 	THEN AX = DATE_AXIS([MINJD,MAXJD],/MONTH)
				IF AX_INTERVAL EQ 'YEAR' 		THEN AX = DATE_AXIS([MINJD,MAXJD],/YEAR)
				IF KEYWORD_SET(FYEAR) AND AX_INTERVAL EQ 'MONTH' THEN AX = DATE_AXIS([MINJD,MAXJD],/MONTH,/FYEAR)
				XTICKNAME=AX.TICKNAME
				XMAJOR=AX.TICKS
				XTICKVALUES=AX.TICKV				
				IF KEYWORD_SET(NOXDATES) THEN XTICKNAME = REPLICATE('',N_ELEMENTS(AX.TICKNAME))
				XRANGE = MINMAX(AX.JD)
			ENDIF
		ENDIF ELSE BEGIN
			MAXDATE = MAX(MDATE)
			MINDATE = MIN(MDATE)
			XRANGE = MINMAX(MAXDATE-MINDATE)
		ENDELSE
	ENDIF ELSE PRINT, 'ERROR: MDATE must be a two element array'

	IF N_ELEMENTS(MDEPTH) EQ 2 THEN BEGIN
		MAXDEPTH=MAX(MDEPTH)
		MINDEPTH=MIN(MDEPTH)
		IF MINDEPTH EQ 0 THEN MINDEPTH = MINDEPTH ELSE MINDEPTH = -MINDEPTH
		DEPTHS = FINDGEN(((MAXDEPTH*(1/DEPTH_INTERVAL))+1))*DEPTH_INTERVAL
		OK = WHERE(DEPTHS LE MAXDEPTH AND DEPTHS GE ABS(MINDEPTH)) & DEPTHS = DEPTHS[OK]
		ND = N_ELEMENTS(DEPTHS)
		IF N_ELEMENTS(YRANGE) NE 2 THEN YRANGE = [-MAXDEPTH,MINDEPTH]	ELSE YRANGE=YRANGE				; Want the minimum depth to be at the top
	ENDIF ELSE PRINT, 'ERROR: MDEPTH must be a two element array'

	IF N_ELEMENTS(VRANGE) EQ 2 THEN BEGIN
		MAXVAR=MAX(VRANGE)
		MINVAR=MIN(VRANGE)
	ENDIF ELSE PRINT, 'ERROR: VRANGE must be a two element array'

	SETS = WHERE_SETS(_DATE)
	DAYS = SETS.VALUE

	IF KEYWORD_SET(NODEPTH) THEN BEGIN
		CR  = CREATE_DATE(MINDATE,MAXDATE)
		NEW = CREATE_STRUCT('DATE','','DEPTH',0.0,'VAR',0.0)
		NEW = STRUCT_2MISSINGS(NEW)
		NEW = REPLICATE(NEW,N_ELEMENTS(CR))
		NEW.DATE = CR
		NEW.DEPTH = 0
		ARRAY = NEW.DATE
		VALUE = _DATE
		OK = WHERE_MATCH(ARRAY,VALUE,COUNT,VALID=VALID,NCOMPLEMENT=ncomplement,COMPLEMENT=complement,ninvalid=ninvalid,invalid=invalid)
		IF COUNT GE 1 THEN NEW[OK].VAR = _VAR(VALID)
		IF NCOMPLEMENT GE 1 THEN NEW(COMPLEMENT).VAR = MISSINGS(0.0)

		IF KEYWORD_SET(INTERPOLATE) AND COUNT GE 2 THEN BEGIN
			IF KEYWORD_SET(MAKE_MISSING) THEN VAR = INTERP_XTEND(DATE_2JD(NEW[OK].DATE),NEW[OK].VAR,DATE_2JD(NEW.DATE),/MAKE_MISSING) ELSE $
				                                VAR = INTERP_XTEND(DATE_2JD(NEW[OK].DATE),NEW[OK].VAR,DATE_2JD(NEW.DATE))
			NEW.VAR = VAR.Y
			INTERP_DATA = VAR.Y
		ENDIF
		IF KEYWORD_SET(BLANK_WINDOW) THEN BEGIN
		  TS_INTERP_BLANK, JD=DATE_2JD(NEW[OK].DATE),INTERP_DATA=INTERP_DATA, INTERP_JD=DATE_2JD(NEW.DATE), SPAN=BLANK_WINDOW, MISS=MISSINGS(NEW.VAR)
			NEW.VAR = INTERP_DATA
	  ENDIF		
		NEW2 = NEW
		NEW2.DEPTH = 0.5
		NEW3 = NEW
		NEW3.DEPTH = 1
		NEW = STRUCT_CONCAT(NEW,NEW2)
		NEW = STRUCT_CONCAT(NEW,NEW3)
	ENDIF ELSE BEGIN ; IF KEYWORD_SET(NODEPTH) THEN BEGIN
		NEW = CREATE_STRUCT('DATE','','DEPTH',0.0,'VAR',0.0)
		NEW = STRUCT_2MISSINGS(NEW)
		NEW = REPLICATE(NEW,ND*(N_ELEMENTS(SETS)+2))
		NEW(0:ND-1).DATE = REPLICATE(MINDATE,ND)
		NEW(0:ND-1).DEPTH = DEPTHS
		COUNTER = ND
		FOR NTH = 0L, N_ELEMENTS(SETS)-1 DO BEGIN
			SUBS=WHERE_SETS_SUBS(SETS[NTH])
			SETVAR = _VAR(SUBS)
			SETDEPTH = _DEPTH(SUBS)
			S = COUNTER
			E = S+ND-1
			NEW(S:E).DATE  = SETS[NTH].VALUE
			NEW(S:E).DEPTH = DEPTHS
			VAR = DEPTHS
			ARRAY = DEPTHS
			VALUE = SETDEPTH
			IF N_ELEMENTS(NEAR) NE 1 THEN PRINT, 'ERROR: No NEAR input for WHERE_NEAREST'
			OK = WHERE_NEAREST(ARRAY,VALUE,COUNT,VALID=VALID,NEAR=NEAR,NCOMPLEMENT=ncomplement,COMPLEMENT=complement,ninvalid=ninvalid,invalid=invalid)
			IF COUNT GE 1 THEN BEGIN
				VAR[OK] = SETVAR(VALID)
				IF NCOMPLEMENT GE 1 THEN VAR(COMPLEMENT) = MISSINGS(0.0)
				IF KEYWORD_SET(INTERPOLATE) AND N_ELEMENTS(SETVAR) GE 2 THEN BEGIN
					IF KEYWORD_SET(MAKE_MISSING) THEN VAR = INTERP_XTEND(setdepth,setvar,depths,/MAKE_MISSING) ELSE $
						VAR = INTERP_XTEND(setdepth,setvar,depths)
				ENDIF
				NEW(S:E).VAR = VAR.Y
			ENDIF ELSE NEW(S:E).VAR = MISSINGS(0.0)
			COUNTER = COUNTER+ND
		ENDFOR
		NEW(COUNTER:N_ELEMENTS(NEW)-1).DATE = REPLICATE(MAXDATE,ND)
		NEW(COUNTER:N_ELEMENTS(NEW)-1).DEPTH = DEPTHS
	ENDELSE ; IF KEYWORD_SET(NODEPTH) THEN BEGIN
	F = NEW.VAR
	Y = -NEW.DEPTH
	X = DATE_2JD(NEW.DATE)-MINJD

	IF N_ELEMENTS(CUTOFF) EQ 2 THEN BEGIN
		OK = WHERE(Y LT -CUTOFF(0) OR Y GT -CUTOFF(1), COUNT)
		IF COUNT GE 1 THEN F[OK] = MISSINGS(F)
	ENDIF
	
	TRIANGULATE,X,Y,TRIANGLES
	GRID = GRIDDATA(X,Y,F,/NATURAL_NEIGHBOR,TRIANGLES=TRIANGLES,DIMENSION=DIMENSIONS,MISSING=MISSINGS(0.0))

	IMG = BYTE(GRID) & IMG[*,*]=0
	FIN = FINITE(GRID)
	OK = WHERE(FIN EQ 1,COUNT)
	IF COUNT GE 1 THEN BEGIN
		IF _PROD NE '' THEN IMG[OK] = PRODS_2BYTE(GRID[OK],PROD=_PROD) ELSE $		
		IF KEYWORD_SET(LOG) THEN IMG[OK] =BYTSCL(ALOG10(GRID[OK]),MIN=ALOG10(MINVAR), MAX=ALOG10(MAXVAR), TOP=_TOP_COLOR) ELSE $
			IMG[OK] =BYTSCL(GRID[OK],MIN=MINVAR, MAX=MAXVAR, TOP=_TOP_COLOR)
	ENDIF
	OK = WHERE(FIN EQ 0, COUNT)
	IF COUNT GE 1 THEN IMG[OK] = MISSING_COLOR
  OUT_IMAGE = IMG
  IF KEYWORD_SET(RETURN_IMAGE) THEN GOTO, DONE
  IF KEYWORD_SET(ADD_YEAR_TITLE) THEN _YTITLE = '' ELSE _YTITLE = YTITLE
  IM = IMAGE(IMG,RGB_TABLE=CPAL_READ(_PAL),AXIS_STYLE=2,LAYOUT=LAYOUT,XMAJOR=0,YMAJOR=0,XMINOR=0,YMINOR=0,/CURRENT,MARGIN=MARGIN,TITLE=TITLE,YTITLE='',FONT_SIZE=FONT_SIZE)
  XAX = AXIS('X',LOCATION=[0,0],TICKNAME=XTICKNAME(0:-1),MAJOR=XMAJOR,MINOR=XMINOR,TICKVALUES=[JD_2DOY(XTICKVALUES(0:-2)),MAX(IM.XRANGE)],TITLE=XTITLE,TICKLEN=0.02,TARGET=IM,TICKFONT_SIZE=FONT_SIZE)
  IF KEYWORD_SET(ADD_YEAR_TITLE) AND YTITLE NE '' THEN TXT = TEXT(MIN(IM.XRANGE)-1,MEAN(IM.YRANGE),YTITLE,ALIGNMENT=1,VERTICAL_ALIGNMENT=0.5,CLIP=0,COLOR='BLACK',FONT_SIZE=FONT_SIZE,/DATA,TARGET=IM,ORIENTATION=ORIENTATION)
 ; IF TITLE  NE '' THEN TXT = TEXT(MIN(IM.XRANGE),MAX(Y),TITLE,ALIGNMENT=0,COLOR='BLACK',FONT_SIZE=12,/DATA,TARGET=IM)

;	img_con, IMG,IMG, nocontour=NOCONTOUR,XSTYLE=1,YSTYLE=1,YRANGE=YRANGE,XRANGE=XRANGE,XTICKNAME=XTICKNAME,XTICKS=XTICKS,YTICKS=YTICKS,YTICKNAME=YTICKNAME,$
;    YTITLE=YTITLE,XTITLE=XTITLE,TICKLEN=TICKLEN,levels=CONTOUR_LEVELS,c_colorS=CONTOUR_COLORS,C_ANNOTATION=CONTOUR_LABELS, BACKGROUND=255, _EXTRA=_extra,XMINOR=XMINOR,YMINOR=YMINOR

	IF N_ELEMENTS(AY_GRID) EQ 1 THEN BEGIN
    CASE AY_GRID OF 
		  'SECOND' 	: AY = DATE_AXIS([MINJD,MAXJD],/SECOND)
		  'MINUTE' 	: AY = DATE_AXIS([MINJD,MAXJD],/MINUTE)
  		'HOUR' 		: AY = DATE_AXIS([MINJD,MAXJD],/HOUR)
  		'DAY' 		: AY = DATE_AXIS([MINJD,MAXJD],/DAY)
  		'MONTH' 	: AY = DATE_AXIS([MINJD,MAXJD],/MONTH)
  		'YEAR' 		: AY = DATE_AXIS([MINJD,MAXJD],/YEAR)
  	ENDCASE	
		XX = AY.TICKV - MINJD
		XX[0] = 0
;		GRIDS,X=XX, /NO_Y, COLOR = 0, THICK = 1
	ENDIF
	TARGET=IM
  DONE:
END

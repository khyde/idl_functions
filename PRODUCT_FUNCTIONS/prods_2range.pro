; $ID:	PRODS_2RANGE.PRO,	2020-07-08-15,	USER-KJWH	$
; #########################################################################; 
FUNCTION PRODS_2RANGE,PROD, PRANGE, OUTPROD=OUTPROD
;+
; PURPOSE:  RETURN THE EXTRACTED RANGE FROM PARSING A COMPOUND PROD NAME 
;          [OR THE RANGE FROM PRODS_MASTER IF PROD STRING IS NOT COMPOUND BUT IS A VALID PROD]
;
; CATEGORY: PRODS FAMILY;
;
;
; INPUTS: 
;      PROD...... STRING WITH THE PROD NAME AND THE RANGE SEPARATED BY UNDERSCORES [OR A VALID PROD NAME]
;      PRANGE.... OPTIONAL RANGE FOR THE PROD
;
;
; KEYWORDS: NONE
;
; OUTPUTS: THE RANGE TO USE FOR THE PROD BASED ON PARSING THE PROD STRING 
;          OR THE RANGE FROM PRODS_READ AND THE PRODS_MASTER
;
; OPTIONAL OUTPUT:
;     OUTPROD.... THE PRODUCT NAME SEPARATED FROM THE INPUT RANGE (e.g. If the input PROD is 'CHLOR_A_0.1_10.0' then the OUTPROD is 'CHLOR_A')
;
; EXAMPLES:
;          PRINT,PRODS_2RANGE('BBP_412')
;          PRINT,PRODS_2RANGE('SST_2_10'); =  2.0000000       10.000000
;          PRINT,PRODS_2RANGE('SST_-2_10'); =  -2.0000000       10.000000
;          PRINT,PRODS_2RANGE('SST_10_2'); =  2.0000000       10.000000
;          PRINT,PRODS_2RANGE('SST_.001_2.1'); = 0.0010000000       2.1000000
;          PRINT,PRODS_2RANGE('SST_2A_10B'); = ERROR: PROD STRING IS NOT CORRECT
;          PRINT,PRODS_2RANGE('SST'); = -3.0000000       35.000000 
;          PRINT,PRODS_2RANGE('SST',[0,40]); = 0.0000000       40.000000 PRANGE PROVIDED
;          PRINT,PRODS_2RANGE('SST_0_40');    = 0.0000000       40.000000 RANGE IMPLIED IN PROD
;          PRINT,PRODS_2RANGE('CHLOR_A_0.1_10.0',OUTPROD=OUTPROD) & P, OUTPROD
;          PRINT,PRODS_2RANGE('TEMP_-32_212',OUTPROD=OUTPROD) & P, OUTPROD
;          PRINT,PRODS_2RANGE('TEMPERATURE_-32_212',OUTPROD=OUTPROD) & P, OUTPROD
;          PRINT,PRODS_2RANGE('JUNK_0.01_0.05',OUTPROD=OUTPROD) & P, OUTPROD
;          PRINT,PRODS_2RANGE('CHLOR_A-PAN',OUTPROD=OUTPROD) & P, OUTPROD
;          PRINT,PRODS_2RANGE('SST-N_4UM') ; SEPARATES OUT THE ALGORITHM FROM THE PROD
;          PRINT,PRODS_2RANGE('SST-N_4UM_1_2')  ; SEPARATES OUT THE ALGORITHM FROM THE PROD WHILE RETAINING THE RANGE
;          PRINT,PRODS_2RANGE('SST-N_4UM_-1_2')  ; SEPARATES OUT THE ALGORITHM FROM THE PROD WHILE RETAINING THE RANGE THAT CONTAINS A NEGATIVE NUMBER
;
; MODIFICATION HISTORY:
;     OCT 07, 2016  WRITTEN BY: J.E. O'REILLY
;     NOV 12, 2016 - JEOR: IF N_ELEMENTS(PRANGE) EQ 2 THEN RETURN, PRANGE
;     FEB 17, 2017 - JEOR: CHECK IF PROD IS COMPOUND THEN CHECK IF SECOND COMPONENT IS NUMERIC [IF NOT THEN PROD = FIRST COMPONENT ]
;     FEB 21, 2017 - KJWH: Added OUTPROD keyword to return the valid prod without the RANGE
;     MAR 11, 2017 - JEOR: TESTES AFTER FIXING BUG IN PRODS_TICKS
;     APR 01, 2017 - KJWH: Changed IF NUMERIC(T[1]) EQ 0 THEN to IF VALIDS('ALGS',T[1]) THEN PROD = T[0] to fix a bug when the range included a negative value (e.g. SST_-1_10)
;     MAR 02, 2018 - JEOR: CHANGED T = STR_SEP(PROD,'-') TO T = STR_SEP(PROD,'_') BEFORE CODE :   IF NOF(T) EQ 2 THEN BEGIN
;     MAR 06, 2018 - KJWH: Updated logic when the prod is invalid and added:
;                            OUTPROD = PROD
;                            RETURN, [] ; (for the range)
;     MAY 09, 2018 - KJWH: CHANGED T = STR_SEP(PROD,'_') back to T = STR_SEP(PROD,'-') at the beginning of the program.  This step will remove an algorithm from a PROD name if present (added example).
;                          Updated the code to remove the ALGORITHM if both the ALG and RANGE (positive and negative) are provided in the PROD name (see SST-N_4UM examples)                       
;-
; #########################################################################

; ******************************
  ROUTINE_NAME  = 'PRODS_2RANGE'
; ******************************
  IF N_ELEMENTS(PRANGE) EQ 2 THEN RETURN, DOUBLE(PRANGE)

  T = STR_SEP(PROD,'-') ; LOOKING FOR THE ALGORITHM NAME.  IF THE '-' IS PRESENT AND T(1) IS A VALID ALG, THEN REMOVE IT FROM THE PROD NAME
  ALG = []
  IF NOF(T) GT 1 THEN IF NUMBER(T[1]) EQ 0 THEN BEGIN     ; IF T[1] IS NOT A NUMBER THEN LOOK FOR THE ALG NAME
    IF VALIDS('ALGS',T[1]) THEN ALG = T[1] ELSE BEGIN ; IF T[1] IS NOT A VALID ALG THEN PARSE FURTHER TO LOOK FOR THE ALGORITHM NAME
      A = STR_SEP(T[1],'_')                           ; PARSE THE NAME BASED ON UNDERSCORES
      A = A[WHERE(A NE '')]                           ; REMOVE ANY TRAILING BLANKS
      IF NOF(A) GE 3 THEN A = GET(A,NUM=NOF(A)-2)     ; REMOVE ANY NUMBERS REPRESENTING THE RANGE (NOTE, IT IS EXPECTED THAT AN ALG WILL HAVE NO MORE THAN 1 UNDERSCORE)
      ALG = STRJOIN(A,'_')                            ; JOIN THE ALG BACK TOGETHER
      IF VALIDS('ALGS',ALG) EQ '' THEN ALG = []       ; VALIDATE THE ALG
    ENDELSE
    IF ALG NE [] THEN PROD = REPLACE(PROD,'-'+ALG,'') ; REMOVE THE ALG FROM THE INPUT PRODUCT NAME
  ENDIF;IF NOF(T) EQ 2 THEN BEGIN

  IF VALIDS('PRODS',PROD,/VALID) THEN BEGIN ;===> IF VALID PROD THEN SKIP TRYING TO PARSE RANGE FROM PROD [BECAUSE MANY VALID PRODS HAVE UNDERSCORS IN THEIR NAME]
    S = PRODS_READ(PROD)
    OUTPROD = S.PROD
    RETURN, DOUBLE([S.LOWER,S.UPPER])
  ENDIF;IF VALIDS('PRODS',PROD,/VALID) THEN BEGIN

  T = STR_SEP(PROD,'_')  
  RANGE = GET(T,NUM=2,/LAST)

  CASE [1] OF ;===> CHECK IF PROD IS COMPOUND THEN CHECK IF SECOND COMPONENT IS NUMERIC 
    TOTAL(IS_NUM(RANGE)) EQ 0: BEGIN
      IF VALIDS('PRODS',PROD,/VALID) THEN BEGIN
        S = PRODS_READ(PROD)
        OUTPROD = S.PROD
        RETURN, DOUBLE([S.LOWER,S.UPPER])
      ENDIF ELSE BEGIN
        OUTPROD=PROD
        RETURN, [] ; 'ERROR: PROD STRING IS NOT CORRECT'
      ENDELSE
    END;TOTAL(IS_NUM(RANGE)) EQ 0: BEGIN

    TOTAL(IS_NUM(RANGE)) EQ 2: BEGIN
      IF FIRST(DOUBLE(RANGE)) GT LAST(DOUBLE(RANGE)) THEN RANGE = DOUBLE(REVERSE(RANGE))
      OUTPROD = STRJOIN(GET(T,NUM=N_ELEMENTS(T)-2),'_')
      RETURN,DOUBLE(RANGE)  
    END; TOTAL(IS_NUM(RANGE)) EQ 2: BEGIN
      
    ELSE: RETURN,[]
  ENDCASE;CASE (1) OF

END; #####################  END OF ROUTINE ################################

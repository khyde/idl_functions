; $ID:	WHERE_NEAREST.PRO,	2020-06-26-15,	USER-KJWH	$
; #########################################################################################################
FUNCTION  WHERE_NEAREST, ARRAY,VALUES,COUNT, NEAR=NEAR, VALID=VALID,$
                         NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT,NINVALID=NINVALID,INVALID=INVALID; 
;+
;	PURPOUSE:  THIS FUNCTION FINDS THE INDICES IN ARRAY WHICH ARE NEAREST TO VALUES ARRAY AND WITHIN A TOLERANCE (NEAR).
;            ARRAY AND VALUES MUST BE NUMERIC TYPES
;
;	RESULT = WHERE_NEAREST(ARRAY, VALUES, NEAR=NEAR)
;
; NOTES:
;  THE ORIGINAL ORDER OF ELEMENTS IN ARRAY AND VALUES IS NOT CHANGED BY THIS PROGRAM
;	 IDL'S VALUE_LOCATE REQUIRES AT LEAST 2 ELEMENTS IN ARRAY (VECTOR)
;	 IF ARRAY HAS ONLY ONE ELEMENT THEN THIS PROGRAM DUPLICATES _ARRAY TO GET THROUGH VALUE_LOCATE

; HISTORY:
;	 MAY 5, 2003	WRITTEN BY:	J.E. O'REILLY, NOAA, 28 TARZWELL DRIVE, NARRAGANSETT, RI 02882
;	 JUL 5,2014,JOR UPDATED CODE, FORMATTING
;  NOV 13,2014,JOR REPLACED RETURN, -1 WITH RETURN,[]
;  JAN 06,2017, JOR :  TO ENSURE A FIND    _NEAR = MAX(ARRAY,/NAN)[ DO NOT SET TO ZERO]

;	 
;-
; #########################################################################################################

;***************************  
ROUTINE_NAME='WHERE_NEAREST'
;***************************  

;	====> IF NEAR IS NOT PROVIDED THEN SET IT TO THE FIRST VALUE WITH DATA TYPE FROM ARRAY
  IF NONE(NEAR) THEN BEGIN
    _NEAR = MAX(ARRAY,/NAN)
  ENDIF ELSE BEGIN
    _NEAR = NEAR
  ENDELSE;IF NONE(NEAR) THEN BEGIN

; ===> DETERMINE SIZE,AND IDLTYPES OF ARRAY AND VALUES
  SZ_ARRAY 	= SIZE(ARRAY,/STRUCT)
  SZ_VALUES = SIZE(VALUES,/STRUCT)

; ===> ENSURE THAT ARRAY AND VALUES ARE BOTH NUMERIC
  IF NUMERIC(ARRAY) EQ 0 OR NUMERIC(VALUES) EQ 0 THEN BEGIN
  	PRINT,'ERROR: ARRAY AND VALUES MUST BOTH BE NUMERIC'
    COUNT = 0L

    NCOMPLEMENT = SZ_ARRAY.N_ELEMENTS
    COMPLEMENT  = LINDGEN(SZ_ARRAY.N_ELEMENTS)
    NINVALID=SZ_VALUES.N_ELEMENTS
    INVALID = LINDGEN(SZ_VALUES.N_ELEMENTS)
    RETURN, []
  ENDIF;IF NUMERIC(ARRAY) EQ 0 OR NUMERIC(VALUES) EQ 0 THEN BEGIN

; ===> ENSURE THAT BOTH ARRAY AND VALUES ARE NOT EMPTY
  IF SZ_ARRAY.N_ELEMENTS  EQ 0 OR SZ_VALUES.N_ELEMENTS  EQ 0 THEN RETURN, []

; ===> COPY ARRAY INTO _ARRAY (_ARRAY MUST HAVE AT LEAST 2 ELEMENTS TO GET THROUGH VALUE_LOCATE)
  IF SZ_ARRAY.N_ELEMENTS EQ 1 THEN _ARRAY = [ARRAY,ARRAY] ELSE _ARRAY = ARRAY

; ===> SORT _ARRAY
  INDEX 		= LINDGEN(SZ_ARRAY.N_ELEMENTS)
  SRT 			= SORT(_ARRAY)
  _ARRAY 		= _ARRAY(SRT)
  INDEX_ARRAY	= INDEX(SRT)

;	===> GET SUBSCRIPTS OF THE ARRAY ELEMENTS WHICH ARE NEAREST TO EACH ELEMENT IN THE VALUES ARRAY
 	SUBS_ARR_LOWER  	= VALUE_LOCATE(_ARRAY, [VALUES]) ; (ENSURE VALUES IS AN ARRAY EVEN WHEN ONLY 1 VALUE)
  SUBS_ARR_UPPER    = (SUBS_ARR_LOWER + 1) < (SZ_ARRAY.N_ELEMENTS-1L)

  DIF_LOWER = ABS(_ARRAY(SUBS_ARR_LOWER) - [VALUES])
  DIF_UPPER = ABS(_ARRAY(SUBS_ARR_UPPER) - [VALUES])
  TEST_DIF  = DIF_LOWER LE DIF_UPPER

  SUBS_NEAREST = LONARR(SZ_VALUES.N_ELEMENTS)
  OK = WHERE(TEST_DIF EQ 1,COUNT)
  IF COUNT GE 1 THEN SUBS_NEAREST[OK] = SUBS_ARR_LOWER[OK]
	OK = WHERE(TEST_DIF EQ 0,COUNT)
  IF COUNT GE 1 THEN SUBS_NEAREST[OK] = SUBS_ARR_UPPER[OK]


; ===> EXCHANGE SUBS_NEAREST SUBSCRIPTS FOR ARRAY FOR ARRAY SUB_NEAREST
  SUBS_NEAREST = INDEX_ARRAY([SUBS_NEAREST])

; ===> DETERMINE WHICH ELEMENTS IN ARRAY(SUBS_NEAREST) ARE WITHIN NEAR
 	VALID = WHERE( ABS(ARRAY[SUBS_NEAREST] - VALUES) LE _NEAR,N_VALID, NCOMPLEMENT=NINVALID,COMPLEMENT=INVALID)

  COUNT= N_VALID
; ===> IF NONE OF VALUES MATCH _ARRAY
	IF N_VALID EQ 0 THEN BEGIN
		NCOMPLEMENT = SZ_ARRAY.N_ELEMENTS
		COMPLEMENT = LINDGEN(SZ_ARRAY.N_ELEMENTS)
    RETURN, [] ;;;
  ENDIF ELSE BEGIN
;		===> CHECK IF ORIGINAL ARRAY HAD ONLY 1 ELEMENT
    IF  SZ_ARRAY.N_ELEMENTS EQ 1 THEN BEGIN
			COUNT = 1
			NCOMPLEMENT = 0L
			COMPLEMENT = -1L
			RETURN, 0L
		ENDIF ELSE BEGIN ; ORIGINAL ARRAY HAD MORE THAN 1 ELEMENT
  	  SUBS =  SUBS_NEAREST(VALID)
 			IN=WHERE_IN(LINDGEN(SZ_ARRAY.N_ELEMENTS), SUBS, NCOMPLEMENT=NCOMPLEMENT, COMPLEMENT=COMPLEMENT)
 		ENDELSE ; IF  SZ_ARRAY.N_ELEMENTS EQ 1 THEN BEGIN
  ENDELSE ; IF N_VALID EQ 0 THEN BEGIN
  RETURN, SUBS


END; #####################  END OF ROUTINE ################################

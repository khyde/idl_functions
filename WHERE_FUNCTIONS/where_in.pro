; $ID:	WHERE_IN.PRO,	2020-06-30-17,	USER-KJWH	$
; ##########################################################################
FUNCTION WHERE_IN, ARRAY,VALUES,COUNT,NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT,NO_SORT=NO_SORT
;+
;	THIS FUNCTION WORKS LIKE IDL'S WHERE BUT FINDS ELEMENTS IN THE ARRAY MATCHING MULTIPLE VALUES
; WHERE_IN USES IDL'S VALUE_LOCATE TO FIND THE INDICES IN ARRAY WHICH MATCH THE VALUES ARRAY.
; WHERE_IN FINDS ALL ELEMENTS IN ARRAY WHICH EXACTLY MATCH ANY ELEMENTS IN VALUE
;
;	OK = WHERE_IN(ARRAY,VALUES,COUNT,NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT)
; OUTPUT:		SUBSCRIPTS OF ARRAY MATCHING ANY VALUE IN VALUES ARRAY
; ARGUMENTS:
; 	ARRAY:	REQUIRED INPUT: A SCALAR OR ARRAY
; 	VALUES: REQUIRED INPUT: A SCALAR OR ARRAY OF VALUES TO FIND IN THE ARRAY
;   COUNT:  OUTPUT: THE NUMBER OF ARRAY ELEMENTS MATCHING ANY ELEMENT IN VALUES


; KEYWORDS:
;   NCOMPLEMENT:  OUTPUT: THE NUMBER OF ARRAY ELEMENTS NOT MATCHING ANY ELEMENT IN VALUES
;    COMPLEMENT:  OUTPUT: THE SUBSCRIPTS OF ARRAY NOT MATCHING ANY VALUE IN VALUES ARRAY
;
; EXAMPLE:
;		ARRAY=['ZEBRA','CAT','BIRD','CAT','BIR','CAT','BIRD','CAT','BIRD','DOG','CAT']
;		VALUES = ['DOG','BIRD']
;		PRINT, ARRAY,VALUES
;		OK=WHERE_IN(ARRAY,VALUES,COUNT,NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT)
;		PRINT,'FOUND '+NUM2STR(COUNT)
;		IF COUNT GE 1 THEN PRINT, ARRAY[OK]
;		PRINT,'NOT FOUND '+NUM2STR(NCOMPLEMENT)
;		IF NCOMPLEMENT GE 1 THEN PRINT,ARRAY(COMPLEMENT)
;

; NOTES:
;  THE ORIGINAL ORDER OF ELEMENTS IN ARRAY AND VALUES IS NOT CHANGED BY THIS PROGRAM
;	 THE SUBSCRIPTS RETURNED REFER TO THE ORIGINAL INPUT ARRAY ORDER

;
; HISTORY:
;	 MAY 5,  2003	WRITTEN BY:	J.E. O'REILLY
;	 JUN 11, 2012 - JOR:  Added INITIALIZE COUNT TO ZERO
;	 NOV 13, 2014 - JOR:  Replaced RETURN, -1 with RETURN,!NULL
;	 DEC 03, 2015 - KJWH: Added code for the NO_SORT keyword
;-
; ##########################################################################################
;***********************
  ROUTINE_NAME='WHERE_IN'
;***********************
;
;===> INITIALIZE COUNT TO ZERO
  COUNT=0
; =====> DETERMINE SIZE,AND IDLTYPES OF ARRAY AND VALUES
  SZ_ARRAY = SIZE(ARRAY,/STRUCT)
  SZ_VALUES = SIZE(VALUES,/STRUCT)

; =====> ENSURE THAT BOTH ARRAY AND VALUES ARE NOT EMPTY
  IF SZ_ARRAY.N_ELEMENTS  EQ 0 OR SZ_VALUES.N_ELEMENTS  EQ 0 THEN RETURN, !NULL

; =====> COPY ARRAY INTO _ARRAY (_ARRAY MUST HAVE AT LEAST 2 ELEMENTS TO GET THROUGH VALUE_LOCATE)
  IF SZ_ARRAY.N_ELEMENTS EQ 1 THEN _ARRAY = [ARRAY,ARRAY] ELSE _ARRAY = ARRAY

; =====> SORT _ARRAY
  INDEX 		= LINDGEN(N_ELEMENTS(_ARRAY))
  SRT 			= SORT(_ARRAY)
  _ARRAY 		= _ARRAY(SRT)
  INDEX 		= INDEX(SRT)

; =====> COPY AND SORT VALUES INTO _VALUES
  SRT 			= SORT(VALUES)
  _VALUES 	= VALUES(SRT)

;	=====> GET SUBSCRIPTS OF ARRAY ELEMENTS NEAREST TO EACH ELEMENT IN THE VALUES ARRAY
  SUBS_ARR 		= VALUE_LOCATE(_ARRAY, _VALUES)

; =====> NOW DETERMINE WHICH ELEMENTS IN SUBS_ARR ARE VALID
  VALID	 = WHERE(_ARRAY(SUBS_ARR) EQ	_VALUES 				, COUNT)

; =====> IF NONE OF _VALUES MATCH _ARRAY THEN RETURN !NULL ;
  IF COUNT EQ 0 THEN BEGIN
    SUBS = !NULL
  	NCOMPLEMENT = SZ_ARRAY.N_ELEMENTS
    COMPLEMENT 	= LINDGEN(NCOMPLEMENT)
    RETURN,SUBS
  ENDIF ELSE BEGIN
 	SUBS_VALID = SUBS_ARR(VALID)

;		=====> DETERMINE SUBSCRIPTS OF _ARRAY WITHIN _ARRAY
	SUBS_ARR_ARR = VALUE_LOCATE(_ARRAY,_ARRAY)

;		=====> IF SUBS_VALID HAS ONLY 1 ELEMENT THEN DUPLICATE (TO GET THROUGH VALUE_LOCATE)
  IF N_ELEMENTS(SUBS_VALID) EQ 1 THEN _SUBS_VALID = [SUBS_VALID,SUBS_VALID] ELSE _SUBS_VALID = SUBS_VALID


;		=====> LOCATE SUBSCRIPT IN _SUBS_VALID THAT MATCH SUBSCRIPTS IN SUBS_ARR_ARR
  SUBS_SUBS = VALUE_LOCATE(_SUBS_VALID,SUBS_ARR_ARR)
  SUBS 			= WHERE(_SUBS_VALID(SUBS_SUBS) EQ SUBS_ARR_ARR,COUNT,NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT)

;		=====> CHECK IF ORIGINAL ARRAY HAD ONLY 1 ELEMENT
  IF N_ELEMENTS(SUBS) EQ 2 AND SZ_ARRAY.N_ELEMENTS EQ 1 THEN BEGIN
    SUBS=SUBS[0] & COUNT = 1 & INDEX = 0L
  ENDIF

;		=====> SORT SUBSCRIPTS IN ASCENDING ORDER (ORIGINAL ORDER OF INPUT ARRAY)
  IF NCOMPLEMENT GE 1 THEN BEGIN
   	COMPLEMENT = INDEX(COMPLEMENT)
   	IF NOT KEYWORD_SET(NO_SORT) THEN COMPLEMENT=COMPLEMENT[SORT(COMPLEMENT)]
  ENDIF
  IF COUNT GE 1 THEN BEGIN
  	SUBS=INDEX(SUBS)
  	IF NOT KEYWORD_SET(NO_SORT) THEN SUBS = SUBS[SORT(SUBS)]
  ENDIF
  RETURN, SUBS
  ENDELSE

END; #####################  END OF ROUTINE ################################

; $ID:	MAPS_REMAP.PRO,	2023-09-21-13,	USER-KJWH	$
;################################################################################################
  FUNCTION MAPS_REMAP, ARRAY, MAP_IN=MAP_IN, MAP_OUT=MAP_OUT, PX_OUT=PX_OUT, PY_OUT=PY_OUT, $
                       BINS=BINS, MSUBS=MSUBS,$
                       INIT=INIT, CENTER=CENTER, LONLAT_STRUCT=LONLAT_STRUCT,$
  										 LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX,$
  										 CONTROL_LONS=CONTROL_LONS, CONTROL_LATS=CONTROL_LATS,$
  									   SUBSET_LONS=SUBSET_LONS, SUBSET_LATS=SUBSET_LATS,$
  										 ERROR=ERROR, DO_MASK=DO_MASK, MAP_SUBSET=MAP_SUBSET, GRID_METHOD=GRID_METHOD,$
                       STRUCT_XPYP= STRUCT_XPYP 										
;+
; NAME: MAPS_REMAP
;      
;
; PURPOSE: REMAP DATA FROM ONE MAP PROJECTION TO ANOTHER.
;      
;
; EXAMPLES:
;
;       EXTRACTING NEC REGION FROM A COMPLETE GLOBAL ARRAY (-180,180,-90,90N):
;       SLIDEW,[2880,1440] & MAP_GEQ & MAP_CONTINENTS,/HIRES & GEQ=TVRD() & PAL_36 & NEC = MAPS_REMAP(GEQ,MAP_IN='GEQ',MAP_OUT='NEC')&SLIDEW,NEC
;
; INPUTS:
;       	ARRAY............  A 2-D MAP ARRAY
;		
;	KEYWORDS: 
;	        MAP_IN............ NAME OF THE MAP MATCHING THE INPUT ARRAY
;	        MAP_OUT........... NAME FOR THE OUTPUT MAP
;	        INIT.............. INITIALIZE COMMON MEMORY
;         PX_OUT............ PIXEL X  DIMENSION FOR THE OUTPUT MAP (DEFAULT SIZE IS TAKEN FROM MAP_SIZE.PRO (.PX) (.PY)
;         PY_OUT............ PIXEL Y  DIMENSION FOR THE OUTPUT MAP (DEFAULT SIZE IS TAKEN FROM MAP_SIZE.PRO
;         LONS.............. LONGITUDES ARRAY (CONTROL POINT MAPPING)
;         LATS.............. LATITUDES ARRAY  (CONTROL POINT MAPPING);
;         MSUBS............. VALID OUTPUT (MAP_OUT) SUBSCRIPTS FOR THE PIXELS IN MAP_OUT
;	        CENTER............ USE THE CENTER OF THE PIXEL [PASSED TO CONGRID & IMG_XPYP]
;	        LONMIN............ MINIMUM LONGITUDE [WHEN MAP_IN = GEQ_PART OR INPUT TO MAPS_MUR_SUBSET]
;         LONMAX............ MAXIMUM LONGITUDE [WHEN MAP_IN = GEQ_PART OR INPUT TO MAPS_MUR_SUBSET]
;         LATMIN............ MINIMUM LATITUDE  [WHEN MAP_IN = GEQ_PART OR INPUT TO MAPS_MUR_SUBSET]
;         LATMAX............ MAXIMUM LATITUDE  [WHEN MAP_IN = GEQ_PART OR INPUT TO MAPS_MUR_SUBSET]
;         CONTROL_LONS...... ARRAY OF LONGITUDES FOR LOCATIONS IN INPUT ARRAY 
;         CONTROL_LATS...... ARRAY OF LATITUDES FOR LOCATIONS IN INPUT ARRAY
;         SUBSET_LONS....... LONS OF THE OUTPUT SUBSET MAP (FOR L3B_2MAP STEP)
;         SUBSET_LATS....... LATS OF THE OUTPUT SUBSET MAP (FOR L3B_2MAP STEP)
;         ERROR............. A STRING INDICATING THE ERROR IF ENCOUNTERED
;         DO_MASK........... APPLY MASK FROM TRIANGLES WHEN CALLING MAPS_LONLAT_GRID
;         MUR_SUBSET........ EXTRACT/SUBSET MUR DATA	 
;         GRID_METHOD....... 'NEARESTNEIGHBOR' OR 'NATURALNEIGHBOR'  
;         STRUCT_XPYP....... OUTPUT: THE CURRENT XPYP STRUCTURE [BEING ADDED TO STRUCT_MAPS_REMAP IN COMMON   
;	        
;
;			ADDITIONAL 'SPECIAL' MAPS ARE ALSO PERMITED IN MAP_IN WHICH ARE NOT
;			GENERATED USING MAP_SET BUT WHERE THE LON,LAT FOR EACH PIXEL ARE PREDEFINED. THESE ARE:
;				L3B (NASA LEVEL 3 BIN,L3B9,L3B4,L3B2,L3B1,L3B10);
;				NENA (RUTGERS ROMS MAP, NORTHEAST NORTH ATLANTIC, 9KM)

;
; OUTPUTS:
;     A 2-D MAP IMAGE FROM THE INPUT ARRAY;
;			ERROR: STRING INDICATING THE EXACT ERROR 
;
;
;	NOTES:
;
;			1)THIS ROUTINE DETERMINES THE CENTER LONS,LATS OF EVERY PIXEL IN THE OUTPUT MAP (MAP_OUT)
;			2)THEN USES THESE LONS,LATS TO IDENTIFY THE CORRESPONDING PIXEL COORDINATES (SUBSCRIPTS) 
;			3)WITHIN THE INPUT MAP (MAP_IN).
;
;			4)THE REMAPPING SUBSCRIPTS FOR EACH MAP_IN-MAP_OUT-PX_OUT-PY_OUT COMBINATION ARE STORED IN 
;			COMMON MEMORY IN A STRUCTURE NAMED COMMON_MAPS_REMAP.  
;			5)SUBSEQUENT CALLS TO MAPS_REMAP THAT USE THE SAME MAP_IN-MAP_OUT-PX_OUT-PY_OUT COMBINATION
;			USE THE STORED REMAPPING SUBSCRIPTS IN THE COMMON_MAPS_REMAP STRUCTURE 
;			TO GREATLY SPEED UP THE REMAPPING.
;
;			6)IF TOO MANY UNIQUE MAP_IN-MAP_OUT-PX_OUT-PY_OUT COMBINATIONS 
;			ARE STORED IN THE COMMON_MAPS_REMAP STRUCTURE THEN
;			THE PROGRAM MAY TIE UP TOO MUCH MEMORY AND PERFORM POORLY.
;			IF SO, THEN USE THE KEYWORD REFRESH TO REINITIALIZE THE COMMON_MAPS_REMAP STRUCTURE
;			COMBINATION AND PROVIDE A NEW GROUP OF MAP_IN-MAP_OUT-PX_OUT-PY_OUT COMBINATIONS
;
; MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, OCTOBER 20,2005
;				NOV 5,  2005 - JEOR: No longer use ROUND 
;				        2013 - KJWH: Added work around for 'EQUIDISTANT_CYLINDRICAL' map
;				FEB 19, 2015 - KJWH: Removed LME and FAP map information
;				                     Found a bug at line 475 in the MAPS_SET, MAP_IN call.  If the pxy of the input map is not the default, the output is incorrect.
;				                     * For example, if the input is a 512 X 512 NEC map, the call to maps_set assumes it is still a 1024 X 1024 map and the resulting output is incorrect.
;				FEB 25,2015  - JEOR: Minor formatting changes 
;				AUG 12, 2015 - KJWH: Replaced the CALL_PROCEDURE, 'MAP_'+MAP_OUT with MAP_SET, MAP_OUT
;				                     Added a buffer when finding the MIN and MAX, LON and LAT when remapping lonlat data
;		    NOV 24, 2015 - JEOR: Copied from MAP_REMAP, added keyword INIT, removed keywords REFRESH, METHOD, and NULL
;		                         Renamed CENTER_PIXEL TO CENTER
;		    MAR 17, 2016 - KJWH: Added CASE block for special MAP_INs (AVHRR, MUR, LONLAT)
;		    MAR 18, 2016 - JEOR: Following code added to prevent program from stopping
;		                           SZ_MAP_IN = SIZEXYZ(ARRAY) ;[NO OTHER INPUTS ALLOWED]
;                              ELSE: GOTO,REGULAR_MAPS
;                              Changed from STRUCT_MAP_REMAP= to STRUCT_MAPS_REMAP=
;       MAR 21, 2016 - KJWH: Removed OLD LONLAT to MAP block
;                            Formatting                 
;       APR 06, 2016 - JEOR: Added keyword DO_MASK
;       APR 28, 2016 - JEOR: Added keywords MUR_SUBSET & GRID_METHOD
;       APR 29, 2016 - KJWH: Updated formatting
;       MAY 03, 2016 - KJWH: Updated MUR_SUBSET call
;       MAY 04, 2016 - KJWH: Changed MUR_SUBSET to MAP_SUBSET
;                            Added MAPS_AVHRR_SUBSET
;       MAY 25, 2016 - KJWH: Updated SUBSET map information    
;       JUN 23, 2016 - KJWH: Added L3B1 map
;                            Updated the L3B functions  
;       JUL 01, 2016 - KJWH: Changed STRMID(MAP,0,3) EQ 'L3B' to HAS(MAP,'L3B')     
;       JUL 29, 2016 - KJWH: Added the LONS and LATS the keywords in the call to MAPS_L3B_2MAP  
;       AUG 01, 2016 - KJWH: Added MAP_OUT EQ 'L3B' to the MAP_SUBSET check       
;                            Moved the L3B MAP_IN check to the top   
;       NOV 07, 2016 - KJWH: Removed CONTROL_SUBS_LONS/LATS keywords - OBSOLETE      
;                            Added SUBSET_LATS and SUBSET_LONS keywords as input to MAPS_L3B_2MAP 
;       MAR 04, 2017 - JEOR: ADDED KEYWORD  STRUCT_XPYP 
;                            IF KEY(INIT) THEN GONE,STRUCT_MAPS_REMAP
;                            CLEANED UP KEYWORDS DOCUMENTATION
;                            FIXED EXAMPLE [ADDED PAL_36]
;                            DELETED  MAP_IN = 'L3B' [CORRUPTING MAP_IN]
;                            CASE [1] OF
;                            HAS(MAP_IN,'L3B'): BEGIN
;                            ADDED KEYWORD STRUCT_XPYP  IN CALL TO MAPS_L3B_2MAP
;       MAR 05, 2017 - JEOR: ADDED 'L3B2' AND 'L3B10' IN CASE MAP_OUT OF  
;       MAR 10, 2017 - KJWH: Minor formatting updates     
;       AUG 25, 2017 - KJWH: Added steps with convert L3B and GS maps (MAY NEED SOME TESTING)     
;       AUG 22, 2018 - KJWH: Changed the keyword SUBS to MSUBS to avoid IDL's "Ambiguous keyword abbreviation" error    
;       FEB 07, 2020 - KJWH: Added OISST maps (similar to the AVHRR and MUR maps)
;       JUL 09, 2020 - KJWH: Added COMPILE_OPT IDL2
;                            Changed subscript () to []		
;       FEB 18, 2022 - KJWH: Changed SEASCAPES to NOAA5KM                     		                    
;-
;#################################################################################################################################################################
  ROUTINE_NAME = 'MAPS_REMAP'
  COMPILE_OPT IDL2
  
  COMMON MAPS_REMAP_, STRUCT_MAPS_REMAP
  IF KEY(INIT) THEN GONE,STRUCT_MAPS_REMAP
  ERROR = ''
  
  IF NONE(ARRAY) OR NONE(MAP_IN) OR NONE(MAP_OUT)  THEN MESSAGE,'ERROR: ARRAY, MAP_IN & MAP_OUT ARE REQUIRED'
       
  MAP_IN  = STRUPCASE(MAP_IN)
  MAP_OUT = STRUPCASE(MAP_OUT)

  ; ===> IF MAP_IN IS L3B1, L3B4 OR L3B9 THEN ASSIGN MAP_IN TO L3B
  IF HAS(MAP_IN,'L3B') THEN  L3B = MAP_IN
   
; ===> LOOK FOR SPECIAL MAP_REMAP CASES
  SUBSET_POS = STRPOS(MAP_OUT,'SUBSET')
  IF SUBSET_POS GE 0 THEN BEGIN
    IF MAP_IN EQ 'AVHRR' OR MAP_IN EQ 'MUR' OR MAP_IN EQ 'L3B' THEN MAP_SUBSET = 1
  ENDIF
  
; ===> GET THE SIZE OF THE INPUT ARRAY
  SZ_MAP_IN = SIZEXYZ(ARRAY, PX=PX_MAP_IN, PY=PY_MAP_IN)
  
; ===> Get the default array sizes for the MAP_OUT  
  M = MAPS_SIZE(MAP_OUT,PX=_PX_OUT,PY=_PY_OUT)
  IF M.ERROR NE 0 AND KEY(MAP_SUBSET) EQ 0 THEN MESSAGE,'ERROR: INVALID MAP_OUT'
  IF ANY(PX_OUT) THEN _PX_OUT = PX_OUT  ; Overwrite MAPS_SIZE default with input PX_OUT and PY_OUT
  IF ANY(PY_OUT) THEN _PY_OUT = PY_OUT

; ===> If MAP_OUT is L3B4 or L3B9 then make sure _PX_OUT and _PY_OUT are correct
  IF HAS(MAP_OUT,'L3B') THEN BEGIN
  	_PX_OUT = M.PX
  	_PY_OUT = M.PY
  ENDIF
  
; ===> If not PX or PY info for the MAP_OUT, revert back to the input array dimensions  
  IF M.PX EQ 0 AND M.PY EQ 0 THEN BEGIN
  	_PX_OUT = PX_MAP_IN
  	_PY_OUT = PY_MAP_IN
  ENDIF
 
; ===> SPECIAL MAPPING CASES
  IF MAP_OUT EQ MAP_IN THEN RETURN, CONGRID(ARRAY, _PX_OUT, _PY_OUT, /CENTER)  ; KIM,JAY REBIN INSTEAD OF CONGRID ?
  
  CASE [1] OF
    MAP_IN EQ 'AVHRR': BEGIN
      IF HAS(MAP_OUT,'L3B') THEN RETURN, MAPS_AVHRR_2BIN(ARRAY, MAP_OUT, INIT=INIT)
      IF KEY(MAP_SUBSET)    THEN RETURN, MAPS_AVHRR_SUBSET(ARRAY, MAP_OUT=MAP_OUT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, INIT=INIT)
                                 RETURN, MAPS_AVHRR_2MAP(ARRAY, MAP_OUT, INIT=INIT)
    END
      
    MAP_IN EQ 'MUR': BEGIN
      IF HAS(MAP_OUT,'L3B') THEN RETURN, MAPS_MUR_2BIN(ARRAY, MAP_OUT, MAP_SUBSET=MAP_SUBSET, INIT=INIT)
      IF KEY(MAP_SUBSET)    THEN RETURN, MAPS_MUR_SUBSET(ARRAY, MAP_OUT=MAP_OUT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, INIT=INIT)
                                 RETURN, MAPS_MUR_2MAP(ARRAY, MAP_OUT, INIT=INIT)
    END
    
    MAP_IN EQ 'GEOPOLAR': BEGIN
      IF HAS(MAP_OUT,'L3B') THEN RETURN, MAPS_GEOPOLAR_2BIN(ARRAY, MAP_OUT, INIT=INIT, LONS=CONTROL_LONS, LATS=CONTROL_LATS)
      IF KEY(MAP_SUBSET)    THEN RETURN, MAPS_MUR_SUBSET(ARRAY, MAP_OUT=MAP_OUT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, INIT=INIT)
      RETURN, MAPS_MUR_2MAP(ARRAY, MAP_OUT, INIT=INIT)
    END
    
    MAP_IN EQ 'NOAA5KM': BEGIN
      IF HAS(MAP_OUT,'L3B') THEN RETURN, MAPS_NOAA5KM_2BIN(ARRAY, MAP_OUT, INIT=INIT, LONS=CONTROL_LONS, LATS=CONTROL_LATS)
      IF KEY(MAP_SUBSET)    THEN MESSAGE, 'ERROR: Need to create the MAPS_NOAA5KM_SUBSET' ; RETURN, MAPS_OISST_SUBSET(ARRAY, MAP_OUT=MAP_OUT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, INIT=INIT)
      MESSAGE, 'ERROR: Need to create MAPS_NOAA5KM_2MAP' ; RETURN, MAPS_OISST_2MAP(ARRAY, MAP_OUT, INIT=INIT)
    END
    
    MAP_IN EQ 'OISST': BEGIN
      IF HAS(MAP_OUT,'L3B') THEN RETURN, MAPS_OISST_2BIN(ARRAY, MAP_OUT, INIT=INIT)
      IF KEY(MAP_SUBSET)    THEN RETURN, MAPS_OISST_SUBSET(ARRAY, MAP_OUT=MAP_OUT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, INIT=INIT)
      RETURN, MAPS_OISST_2MAP(ARRAY, MAP_OUT, INIT=INIT)
    END
    
    MAP_IN EQ 'LONLAT': RETURN, MAPS_LONLAT_GRID(ARRAY, METHOD=GRID_METHOD, MAP_OUT=MAP_OUT, LON=CONTROL_LONS, LAT=CONTROL_LATS, STRUCT=LONLAT_STRUCT, INIT=INIT, DO_MASK=DO_MASK)
    
    HAS(MAP_IN,'L3B'):  RETURN, MAPS_L3B_2MAP(ARRAY,BINS,MAP_IN=L3B,MAP_OUT=MAP_OUT,LONS=SUBSET_LONS,LATS=SUBSET_LATS,INIT=INIT, STRUCT_XPYP= STRUCT_XPYP)
    
    IS_GSMAP(MAP_IN): IF IS_L3B(MAP_OUT) THEN RETURN, MAPS_L3BGS_SWAP(ARRAY) ELSE GOTO, REGULAR_MAPS
          
    ELSE: GOTO,REGULAR_MAPS
  ENDCASE;CASE (1) OF  
  
  REGULAR_MAPS:

; ===> MAKE A STRING FOR THE PARTICULAR MAP_IN-MAP_OUT-PX_OUT-PY_OUT COMBINATION
  MAP_TXT = MAP_IN+'_'+STRTRIM(PX_MAP_IN,2)+'_'+STRTRIM(PY_MAP_IN,2)+'_'+STRTRIM(STRUPCASE(MAP_OUT),2)+'_'+STRTRIM(_PX_OUT,2)+'_'+STRTRIM(_PY_OUT,2)

; ===> ADD DUMMY MAP TAG TO INITIALIZE THE STRUCT_MAPS_REMAP STRUCTURE
  IF NONE(STRUCT_MAPS_REMAP) OR KEY(INIT) THEN STRUCT_MAPS_REMAP=CREATE_STRUCT('_','')

; ===> Add the MAP_IN-MAP_OUT-PX_OUT-PY_OUT combination to STRUCT_MAPS_REMAP if it is not already present
  OK_TAG = WHERE(TAG_NAMES(STRUCT_MAPS_REMAP) EQ MAP_TXT,COUNT)

	IF COUNT EQ 0 THEN BEGIN ; If the MAP combo is not in the structure

		CASE MAP_OUT OF
      'L3B1':  STR = MAPS_L3B_2LONLAT(MAP_OUT,LATS=LATS,LONS=LONS) ; ===> GET ALL BINS AND THEIR LON AND LATS
      'L3B2':  STR = MAPS_L3B_2LONLAT(MAP_OUT,LATS=LATS,LONS=LONS) ; ===> GET ALL BINS AND THEIR LON AND LATS
      'L3B4':  STR = MAPS_L3B_2LONLAT(MAP_OUT,LATS=LATS,LONS=LONS) ; ===> GET ALL BINS AND THEIR LON AND LATS
      'L3B9':  STR = MAPS_L3B_2LONLAT(MAP_OUT,LATS=LATS,LONS=LONS) ; ===> GET ALL BINS AND THEIR LON AND LATS
      'L3B10': STR = MAPS_L3B_2LONLAT(MAP_OUT,LATS=LATS,LONS=LONS) ; ===> GET ALL BINS AND THEIR LON AND LATS    
      'L3B':  RETURN, 'ERROR: L3B is not a valid MAP_OUT.  Must use L3B1, L3B4 OR L3B9'

      'NENA' : BEGIN
        M=READ_MATFILE(!S.MAPINFO+'ROMS-NENA-LON-SURFACE.MAT') & LONS=M.(1).DATA
        M=READ_MATFILE(!S.MAPINFO+'ROMS-NENA-LAT-SURFACE.MAT') & LATS=M.(1).DATA
        SZ  = SIZE(LONS,/STRUCT)
        IF _PX_OUT NE SZ.DIMENSIONS[0] OR  _PY_OUT NE SZ.DIMENSIONS[1] THEN BEGIN  ; CONGRID IF NEEDED
          LONS = CONGRID(LONS, _PX_OUT,_PY_OUT, /CENTER,/INTERP)
          LATS = CONGRID(LATS, _PX_OUT,_PY_OUT, /CENTER,/INTERP)
        ENDIF
      END ; 'NENA'
      
      ELSE : BEGIN  ; ALL OTHER NORMAL MAPS
;       ===> GET DEVICE COORDINATES FOR EVERY PIXEL (MID PIXEL)
        IF MAP_IN EQ 'LONLAT' AND NOT KEYWORD_SET(CENTER_PIXEL) THEN IXY = IMG_XPYP([_PX_OUT,_PY_OUT]) ELSE $   ; WHEN REMAPPING FROM LATLONS, DO NOT USE THE CENTER OF THE PIXEL
                                                                     IXY = IMG_XPYP([_PX_OUT,_PY_OUT],/CENTER)

        ZWIN,[_PX_OUT,_PY_OUT]                             ; SET UP MAP_OUT PROJECTION IN Z BUFFER DEVICE
        MAPS_SET,MAP_OUT          
          XYZ=CONVERT_COORD(IXY.X,IXY.Y,/DEVICE,/TO_DATA)  ; GET THE LON/LAT
          GONE,IXY
          LONS = REFORM(XYZ[0,*],_PX_OUT,_PY_OUT)
          LATS = REFORM(XYZ[1,*],_PX_OUT,_PY_OUT)
          GONE,XYZ
        ZWIN
      END ; ELSE ; ALL OTHER NORMAL MAPS
    ENDCASE ; CASE MAP_OUT OF

; 	###############
		CASE MAP_IN OF
; ------------------
  		'GEQ': BEGIN
  			ZWIN,ARRAY
  				MAPS_SET,'GEQ'
  				XYZ=CONVERT_COORD(LONS,LATS,/DATA,/TO_DEVICE,/DOUBLE)
  			ZWIN
  			XP =    REFORM(XYZ[0,*],_PX_OUT,_PY_OUT)
    		YP =    REFORM(XYZ[1,*],_PX_OUT,_PY_OUT)
  			OK=WHERE(XP EQ PX_MAP_IN,COUNT) ; Allow wrap around in the east to west direction only (i.e. when rounded XP is equal to PX_MAP_IN (+180) then set XP to 0 (-180) to avoid this data from being missing)
  			IF COUNT GE 1 THEN XP[OK] = 0
  		END ; 'GEQ'
  		
; ------------------
  		'GEQ_PART': BEGIN
  		  IF N_ELEMENTS(LATMIN) NE 1 OR N_ELEMENTS(LATMAX) NE 1 OR N_ELEMENTS(LONMIN) NE 1 OR N_ELEMENTS(LONMAX) NE 1 THEN BEGIN
  		    RETURN, 'ERROR: Must provide LATMIN, LATMAX, LONMIN and LONMAX when MAP_IN=GEQ_PART'
  		  ENDIF
  		  ZWIN,ARRAY
  		  MAP_GEQ_PART, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN,LATMAX=LATMAX
  		  XYZ=CONVERT_COORD(LONS,LATS,/DATA,/TO_DEVICE)
  		  ZWIN
  		  XP =    REFORM(XYZ[0,*],_PX_OUT,_PY_OUT)
  		  YP =    REFORM(XYZ[1,*],_PX_OUT,_PY_OUT)
  		END ; GEQ_PART
 
 ; ------------------
  		'NENA': BEGIN ;  REQUIRES ADDITIONAL STEPS SINCE THIS PROJECTION CAN NOT BE DUPLICATED WITH MAP_SET
  		  M=READ_MATFILE(!S.MAPINFO+'ROMS-NENA-LON-SURFACE.MAT') & _LONS=M.(1).DATA
  		  M=READ_MATFILE(!S.MAPINFO+'ROMS-NENA-LAT-SURFACE.MAT') & _LATS=M.(1).DATA
  		  SZ  = SIZE(_LONS,/STRUCT)
  	
  		  IF PX_MAP_IN NE SZ.DIMENSIONS[0] OR  PY_MAP_IN NE SZ.DIMENSIONS[1] THEN BEGIN ; CONGRID IF NEEDED
  		    _LONS = CONGRID(_LONS, PX_MAP_IN,PY_MAP_IN, /CENTER,/INTERP)
  		    _LATS = CONGRID(_LATS, PX_MAP_IN,PY_MAP_IN, /CENTER,/INTERP)
  		  ENDIF; IF PX_MAP_IN NE SZ.DIMENSIONS(0) OR  PY_MAP_IN NE SZ.DIMENSIONS(1) THEN BEGIN
  
  		  IXY = IMAGE_PXPY([PX_MAP_IN,PY_MAP_IN],/CENTER) ; GET DEVICE COORDINATES FOR EVERY PIXEL (MID PIXEL)
  		  ZWIN,[_PX_OUT,_PY_OUT]
  		  MAPS_SET,MAP_OUT
  		  MISSING=MISSINGS(0.0)
  		  XP = MAP_PATCH_NARR( FLOAT(IXY.X), FLOAT(_LONS), FLOAT(_LATS), MISSING=MISSING,XSIZE=XSIZE,XSTART=XSTART,YSIZE=YSIZE,YSTART=YSTART)
  		  YP = MAP_PATCH_NARR( FLOAT(IXY.Y), FLOAT(_LONS), FLOAT(_LATS), MISSING=MISSING,XSIZE=XSIZE,XSTART=XSTART,YSIZE=YSIZE,YSTART=YSTART)
  		  ZWIN
  
  		  OK = WHERE(XP EQ MISSING OR YP EQ MISSING,COUNT)
  		  IF COUNT GE 1 THEN BEGIN
  		    XP[OK] = -1
  		    YP[OK] = -1
  		  ENDIF
  		END ; 'NENA'

; ------------------
  		ELSE: BEGIN ; ALL OTHER REGULAR IDL MAP PROGRAMS THAT CALL MAPS_SET
  			ZWIN,ARRAY
  				MAPS_SET,MAP_IN; , PX_MAP_IN, PY_MAP_IN
  				XYZ= CONVERT_COORD(LONS,LATS,/DATA,/TO_DEVICE,/DOUBLE)
  			ZWIN
  			XP =  REFORM(XYZ[0,*],_PX_OUT,_PY_OUT)
   			YP =  REFORM(XYZ[1,*],_PX_OUT,_PY_OUT)
  			GONE, XYZ
  		END ; ELSE
    ENDCASE ; CASE MAP_IN OF
		GONE, LONS & GONE, _LONS
		GONE, LATS & GONE, _LATS 
		GONE, XYZ  & GONE, IXY
		GONE, ARRBINS & GONE, LARR

    STRUCT_XPYP = CREATE_STRUCT('MAP_TXT',MAP_TXT,'MAP_IN', MAP_IN, 'PX_MAP_IN',   PX_MAP_IN,  'PY_MAP_IN',   PY_MAP_IN,$
    'MAP_OUT',MAP_OUT,     'MAP_OUT_PX', _PX_OUT,     'MAP_OUT_PY', _PY_OUT, 'XP', XP,'YP', YP)

		;   ===> ADD ANOTHER MAP_IN-MAP_OUT-PX_OUT-PY_OUT UNIQUE LAYER (TAG) TO THE STRUCT_MAPS_REMAP STRUCTURE
		STRUCT_MAPS_REMAP=CREATE_STRUCT(TEMPORARY(STRUCT_MAP_REMAP),MAP_TXT,$
		  CREATE_STRUCT('MAP_IN', MAP_IN, 'PX_MAP_IN',   PX_MAP_IN,  'PY_MAP_IN',   PY_MAP_IN,$
		  'MAP_OUT','',     'MAP_OUT_PX', _PX_OUT,     'MAP_OUT_PY', _PY_OUT, 'XP', XP,'YP', YP))


; ******************************************************************************************************
  ENDIF ; IF COUNT EQ 0 THEN BEGIN ===> If the MAP combo is not in the structure
; ******************************************************************************************************


; ===> FIND THE RIGHT MAP INFO/LAYER IN THE STRUCT_MAPS_REMAP STRUCTURE
  OK_TAG  = WHERE(TAG_NAMES(STRUCT_MAPS_REMAP) EQ MAP_TXT,COUNT)
  IF COUNT NE 1 THEN STOP

  MP = ARRAY[STRUCT_MAPS_REMAP.(OK_TAG).XP, STRUCT_MAPS_REMAP.(OK_TAG).YP]
  IF NONE(STRUCT_XPYP) THEN STRUCT_XPYP = CREATE_STRUCT('MAP_TXT',MAP_TXT,'MAP_IN', MAP_IN, 'PX_MAP_IN',   PX_MAP_IN,  'PY_MAP_IN',   PY_MAP_IN,$
    'MAP_OUT',MAP_OUT,     'MAP_OUT_PX', _PX_OUT,     'MAP_OUT_PY', _PY_OUT, 'XP', STRUCT_MAPS_REMAP.(OK_TAG).XP,'YP',  STRUCT_MAPS_REMAP.(OK_TAG).YP)
  GONE,XP
  GONE,YP
; ===> CHECK FOR ANY XP AND YP OUTSIDE THE RANGE OF MAP_OUT_PX,MAP_OUT_PY
  OK=WHERE(STRUCT_MAPS_REMAP.(OK_TAG).XP LT 0 OR STRUCT_MAPS_REMAP.(OK_TAG).XP GE PX_MAP_IN OR $
           STRUCT_MAPS_REMAP.(OK_TAG).YP LT 0 OR STRUCT_MAPS_REMAP.(OK_TAG).YP GE PY_MAP_IN,COUNT, NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=MSUBS)
  IF COUNT GE 1 THEN MP[OK] = MISSINGS(MP)

  RETURN, MP

END; #####################  END OF ROUTINE ################################







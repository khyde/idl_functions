; $ID:	D3_TRANSPOSE.PRO,	2020-07-01-12,	USER-KJWH	$
;############################################################################3
PRO D3_TRANSPOSE, INPUT_LUN, OUTPUT_LUN, INPUT_DIMENSIONS, PERMUTATION, $
                          DATA_TYPE, MEMGB=MEMGB, PROGRESS=PROGRESS, COMPLETE=COMPLETE, TOTAL=TOTAL
;+
; THIS PROGRAM PERFORMS A GENERALIZED TRANSPOSE OF A 3D MATRIX.
; THE MATRICES ARE ASSUMED TO BE LARGE AND ARE STORED IN FILES. DUE TO THE LARGE SIZE, IT
; MAY NOT BE POSSIBLE TO SIMPLY USE THE IDL TRANSPOSE FUNCTION.
; THE APPLICATION OF THIS TRANSPOSE IS TO CONVERT ISERIES IMAGE FILES TO PSERIES FILES
; OR TO CONVERT PSERIES FILES TO ISERIES FILE.
; PSERIES = TRANSPOSE(ISERIES, [2, 0, 1])     ; FORWARD TRANSPOSE
; ISERIES = TRANSPOSE(PSERIES, [1, 2, 0])     ; REVERSE TRANSPOSE
;
; THE PSERIES TO ISERIES REVERSE TRANSPOSE CAN BE DONE IN ONE STEP 
; USING CODE WHICH WAS FOUND IN  TS_IMAGES_PSERIES_2ISERIES.PRO.
; 
; THE ISERIES TO PSERIES FORWARD TRANSPOSE CANNOT BE DONE AS EFFICIENTLY 
; IN ONE STEP, BUT MAY BE PERFORMED USING TWO REVERSE TRANSPOSES AS FOLLOWS:
; TEMPSERIES = TRANSPOSE(ISERIES, [1, 2, 0])
; PSERIES = TRANSPOSE(TEMPSERIES, [1, 2, 0])
; 
; IF WHEN DOING THE FORWARD TRANSPOSE, THE FIRST DIMENSION IS 1 
; (WHICH HAPPENS WITH "BINNED" DATA)
; ONLY ONE REVERSE TRANSPOSE IS REQUIRED WITH TWO ARRAY REFORMATS AS FOLLOWS:
; GIVEN THAT THE ARRAY DIMENSIONS ARE [1, D1, D2],
; TEMPSERIES1 = REFORM(ISERIES, D1, 1, D2)
; TEMPSERIES2 = TRANSPOSE(TEMPSERIES1, [1, 2, 0])
; PSERIES =     REFORM(TEMPSERIES2, 1, D2, D1)
; 
; THE POSSIBLE TRANSPOSE ARGUMENTS ARE:
;     TRANSPOSE[0, 1, 2] - THE NULL TRANSPOSE, SIMPLY MAKE A COPY OF THE FILE, BUT NOT CURRENTLY ALLOWED
;     TRANSPOSE[0, 2, 1] - NOT CURRENTLY ALLOWED
;     TRANSPOSE[1, 0, 2] - SHOULD BE EASY TO IMPLEMENT BUT NOT CURRENTLY ALLOWED
;     TRANSPOSE[1, 2, 0] - THE PSERIES TO ISERIES REVERSE TRANSPOSE
;     TRANSPOSE[2, 0, 1] - THE ISERIES TO PSERIES FORWARD TRANSPOSE USING 2 STEPS
;     TRANSPOSE[2, 1, 0] - NOT CURRENTLY ALLOWED
;     
; SYNTAX:
;   D3_TRANSPOSE, FILE_IN, OUTPUT_LUN, INPUT_DIMENSIONS, PERMUTATION, $
;           DATA_TYPE, MEMGB=MEMGB, PROGRESS=PROGRESS, COMPLETE=COMPLETE, TOTAL=TOTAL
;   
; ARGUMENTS:
;   INPUT_LUN         - LOGICAL UNIT NUMBER FOR INPUT FILE
;   OUTPUT_LUN        - LOGCIAL UNIT NUMBER FOR OUTPUT FILE
;   INPUT_DIMENSIONS  - 3 MEMBER VECTOR CONTAINING THE INPUT MATRIX DIMENSIONS
;   PERMUTATION       - 3 MEMBER VECTOR CONTAINING THE TRANSPOSE PERMUTATION
;   DATA_TYPE         - STRING, 'INT' OR 'FLT'
;   MEMGB             - (OPTIONAL) SPECIFY THE AMOUNT OF SYSTEM MEMORY TO USE FOR THE OPERATION
;   PROGRESS          - (OPTIONAL) IF TRUE (NON-ZERO), PRINT PROGRESS OF THE OPERATION
;   COMPLETE          - (OPTIONAL) FOR INTERNAL USE, NUMBER OF OPERATIONS COMPLETED SO FAR
;   TOTAL             - (OPTIONAL) FOR INTERNAL USE, THE TOTAL NUMBER OF OPERATIONS
;   
; LIMITATIONS:
;   THE ARRAYS ARE CURRENTLY ASSUMED TO BE TWO-BYTE INTEGERS.
;   ONLY THE [1,2,0] AND [2,0,1] PERMUTATIONS ARE ALLOWED.
;   MAXIMUM SYSTEM MEMORY SHOULD BE DYNAMICALLY DETERMINED BUT IS ONLY SET STATICALLY HERE.
; 
; HISTORY:
;   2011-11-25  WRITTEN BY ROBERT G. COX, INTEGRATED STATISTICS
;   2012-02-10  ADDED DATA_TYPE PARAMETER AND MODIFIED DATA TYPES TO PROCESS 'INT' OR 'FLT' DATA
;   2012-02-15  ADDED MEMGB KEYWORD TO SPECIFY AMOUNT OF MEMORY TO USE
;   JUL 27,2014,JOR MINOR CHANGES, FORMATTING
;   APR 13,2015,JOR: TEMP_FILE = !S.IDL_TEMP+'TEMP_TRANSPOSE_FILE'
;                    RENAMED FROM 'MATRIX_TRANSPOSE_3D' TO D3_TRANSPOSE TO MATCH THE D3 FAMILY NAMES
;   APR 23,2015,JOR  ADDED CLOSE,INPUT_LUN,OUTPUT_LUN


;
;-
;****************************
ROUTINE_NAME = 'D3_TRANSPOSE'
;****************************
;===> OPEN INPUT_FILE

  
  IF NOT KEYWORD_SET(PROGRESS) THEN PROGRESS = 0
  IF PROGRESS NE 0 THEN PROGRESS = 1
  
  D0 = INPUT_DIMENSIONS[0]
  D1 = INPUT_DIMENSIONS[1]
  D2 = INPUT_DIMENSIONS[2]
  P0 = PERMUTATION[0]
   P1 = PERMUTATION[1]
  P2 = PERMUTATION[2]
  
  PRINT, FORMAT='("*** D3_TRANSPOSE: D0: ", I7, ", D1: ", I7, ", D2: ", I7, '$
          + '", PERMUTATION: [", I1, ",", I1, ",", I1, "]")', D0, D1, D2, P0, P1, P2
  
  IF DATA_TYPE EQ 'INT' THEN DATUM_BYTES = 2
  IF DATA_TYPE EQ 'FLT' THEN DATUM_BYTES = 4
  
  PERMUTATIONS = [[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]]
  
  PERMUTATION_INDEX = -1
  FOR I=0, 5 DO BEGIN
    IF ARRAY_EQUAL(PERMUTATION, PERMUTATIONS[*,I]) THEN BEGIN
      PERMUTATION_INDEX = I
    ENDIF
  ENDFOR
  
  ; MAX_MEMORY SPECIFIES THE AMOUNT OF SYSTEM MEMORY TO USE FOR THIS OPERATION.
  ; THIS IS DEPENDENT ON THE AMOUNT OF SYSTEM MEMORY AVAILABLE, IN THE CURRENT CASE, 12GB.
  ; THIS SHOULD BE DETERMINED AUTOMATICALLY WITH MAX_MEMORY SET TO SOMETHING LIKE
  ; 2/3 OF THE TOTAL SYSTEM MEMORY.
  IF NOT KEYWORD_SET(MEMGB) THEN BEGIN
    MAX_MEMORY = 5ULL*1024*1024*1024  ; 5GB
  ENDIF ELSE BEGIN
    MAX_MEMORY = MEMGB*1024*1024*1024
  ENDELSE
  ;MAX_MEMORY = 8ULL*1024*1024*1024  ; 8GB
  ;MAX_MEMORY = 3ULL*1024*1024*1024  ; 3GB
  MAX_MEMORY = 1ULL*1024*1024*1024  ; 1GB
  ;MAX_MEMORY = 64ULL*1024*1024      ; 64MB
  ;MAX_MEMORY = 1ULL*1024*1024       ; 1MB
  ;MAX_MEMORY = 2ULL*1024*1024        ; 2MB
  
  ARRAY_SIZE = ULONG64(DATUM_BYTES)*D0*D1*D2
          
  CASE PERMUTATION_INDEX OF
  
    3:  BEGIN ; [1, 2, 0], REVERSE OR PSERIES TO ISERIES
          ;D0 - PX
          ;D1 - PY
          ;D2 - N_IMAGES


          CHUNK_SIZE = CEIL(D2*FLOAT(MAX_MEMORY)/ARRAY_SIZE,/L64)
          N2_CHUNKS = CEIL(FLOAT(D2)/CHUNK_SIZE)
        
          ;COMPLETE = N2_CHUNKS * D0
          IF NOT KEYWORD_SET(TOTAL) THEN TOTAL = N2_CHUNKS * D0
          IF NOT KEYWORD_SET(COMPLETE) THEN COMPLETE = 0
          
          FOR I2_CHUNK = 0, N2_CHUNKS-1 DO BEGIN
            I2 = I2_CHUNK * CHUNK_SIZE
        
            IF I2_CHUNK EQ N2_CHUNKS-1 THEN BEGIN
              I2_SIZE = ((D2-1) MOD CHUNK_SIZE)+1
            ENDIF ELSE BEGIN 
              I2_SIZE = CHUNK_SIZE
            ENDELSE
          
            PRINT, FORMAT="('I2_CHUNK:', I4, ' OF ', I4, ', SIZE: ', I5)", I2_CHUNK+1, N2_CHUNKS, I2_SIZE
            
            IF DATA_TYPE EQ 'INT' THEN HOLDER = INTARR(D0, D1, I2_SIZE)
            IF DATA_TYPE EQ 'FLT' THEN HOLDER = FLTARR(D0, D1, I2_SIZE)

;STOP


            READU, INPUT_LUN, HOLDER
            PROGRESS_INTERVAL = 1.0  ;SECONDS
            TIME_START = SYSTIME(/SECONDS)
            
            FOR I0 = 0, D0-1 DO BEGIN
              TIME_NOW = SYSTIME(/SECONDS)
              TIME_ELAPSED = TIME_NOW - TIME_START
              IF TIME_ELAPSED GE PROGRESS_INTERVAL THEN BEGIN
                TIME_START = TIME_NOW
                IF PROGRESS EQ 1 THEN BEGIN
                  PERCENT = 100.0 * (COMPLETE + I0 + D0*I2_CHUNK) / TOTAL
                  PRINT, FORMAT="('  I0:', I9, ' OF ', I9, ', I2_CHUNK:', I4, ' OF ', I4, ', ', F5.1, '%')",$
                      I0, D0, I2_CHUNK+1, N2_CHUNKS, PERCENT
                ENDIF
              ENDIF  
              
              LINES = REFORM(HOLDER(I0,*,*))
              PTR = (ULONG64(I0)*D1*D2 + I2*D1)*DATUM_BYTES
              POINT_LUN, OUTPUT_LUN, PTR
              WRITEU, OUTPUT_LUN, LINES
              LINES = 0   ; DEALLOCATE
            ENDFOR
            HOLDER = 0    ; DEALLOCATE
          ENDFOR
          COMPLETE = N2_CHUNKS * D0
    
        END
        
    4:  BEGIN ; [2, 0, 1], FORWARD OR ISERIES TO PSERIES
          IF D0 GT 1 THEN BEGIN
            ; THIS OPERATION USES TWO [1, 2, 0] TRANSPOSES WITH AN INTERMEDIATE RESULTS FILE.
            
            ; DETERMINE THE TOTAL NUMBER OF OPERATIONS FOR CALCULATING AND PRINTING PROGRESS
            CHUNK_SIZE1 = CEIL(D2*FLOAT(MAX_MEMORY)/ARRAY_SIZE,/L64)
            N2_CHUNKS1 = CEIL(FLOAT(D2)/CHUNK_SIZE1)
            TOTAL1 = N2_CHUNKS1 * D0
            CHUNK_SIZE2 = CEIL(D0*FLOAT(MAX_MEMORY)/ARRAY_SIZE,/L64)
            N2_CHUNKS2 = CEIL(FLOAT(D0)/CHUNK_SIZE2)
            TOTAL2 = N2_CHUNKS2 * D1
            TOTAL = TOTAL1 + TOTAL2
            COMPLETE = 0
            
            TEMP_FILE = !S.IDL_TEMP+'TEMP_TRANSPOSE_FILE'
            OPENW, TEMP_LUN, TEMP_FILE, /GET_LUN
            IF PROGRESS EQ 1 THEN BEGIN
              PRINT, 'MATRIX TRANSPOSE, 1ST OF 2.'
            ENDIF
            D3_TRANSPOSE, INPUT_LUN, TEMP_LUN, [D0, D1, D2], [1, 2, 0], DATA_TYPE, $
                  MEMGB=MEMGB, PROGRESS=PROGRESS, COMPLETE=COMPLETE, TOTAL=TOTAL
            CLOSE, TEMP_LUN
            OPENR, TEMP_LUN, TEMP_FILE, /GET_LUN
            IF PROGRESS EQ 1 THEN BEGIN
              PRINT, 'MATRIX TRANSPOSE, 2ND OF 2.'
            ENDIF
            D3_TRANSPOSE, TEMP_LUN, OUTPUT_LUN, [D1, D2, D0], [1, 2, 0], DATA_TYPE, $
                  MEMGB=MEMGB, PROGRESS=PROGRESS, COMPLETE=COMPLETE, TOTAL=TOTAL
            CLOSE, TEMP_LUN
          ENDIF ELSE BEGIN
            ; D0 IS 1 - ONLY NEED ONE [1, 2, 0] TRANSPOSE WITH TWO REFORMS.
            ; SINCE THE FILES ARE INDEPENDENT OF ARRAY FORMAT, THE FIRST REFORM IS DONE
            ; WHILE SPECIFYING THE ARRAY DIMENSIONS TO THE TRANSPOSE, AND THE SECOND REFORM
            ; IS NOT NECESSARY.
            D3_TRANSPOSE, INPUT_LUN, OUTPUT_LUN, [D1, 1, D2], [1, 2, 0], DATA_TYPE, $
                MEMGB=MEMGB, PROGRESS=PROGRESS
          ENDELSE
          IF PROGRESS EQ 1 THEN BEGIN
            PRINT, 'MATRIX TRANSPOSE, DONE.'
          ENDIF
        END
        
    ELSE:  PRINT, ROUTINE_NAME, ': THIS TRANSPOSE PERMUTATION IS NOT SUPPORTED AT THIS TIME.'
        
  ENDCASE
CLOSE,INPUT_LUN
CLOSE,OUTPUT_LUN
  
 
END

; $ID:	SAVE_MAKE_L2.PRO,	2020-07-08-15,	USER-KJWH	$

	PRO SAVE_MAKE_L2, FILES, PRODS=PRODS, DIR_OUT=DIR_OUT, MAP_OUT=MAP_OUT, MAP_ONLY=MAP_ONLY, GET_AREA=GET_AREA, GLOBAL_ONLY=GLOBAL_ONLY,$
	                  FLAG_BITS=FLAG_BITS, SST_QUAL=SST_QUAL, METHOD=METHOD, OVERWRITE=OVERWRITE, STRUCT_RETURN=STRUCT_RETURN

;+
; NAME: SAVE_MAKE_L2
;
; PURPOSE: This function opens a SeaDAS generated L2 file and creates saves for specified maps
;
; CATEGORY: SAVE_MAKE
;
; OUTPUT: Mapped L2 .SAV files
; 
; INPUT: FILES = L2*.hdf files generated by SeaDAS or acquired from the NASA Ocean Color Web
;
; KEYWORDS: PROD = Sensor specific products to get fromt the L3b files
;           METHOD = Reprocessing method (i.e. R2015) for the output file name
;           DIR_OUT = Output directory for the .SAV files
;           MAP_OUT = The name of the MAP(s) for the output files 
;           FLAG_BITS = Bit values for the flags to be applied to the L2 files
;           OVERWRITE_SAVE = Rewrite the .SAV if it already exits
;           
; EXAMPLE:
;			FILES = FILE_SEARCH('E:\MODIS_TEST\*SEAWIFS*.hdf') & DIR_OUT = 'E:\MODIS_TEST\SAVE\' & MAPS = 'NEC' & PRODS = 'chlor_a'
;			L2_2SAVE,FILES=FILES,PRODS=PRODS,DIR_OUT=DIR_OUT,MAP_OUT=MAP_OUT, /OVERWRITE
;
;	NOTES:
;
; WRITTEN: Dec 2, 2015 - K. Hyde 28 Tarzwell Drive, NMFS, NOAA 02882 (kimberly.hyde@noaa.gov)
;          Adapted from L2_2SAVE
;
; MODIFICATION HISTORY:
;    MAR     2016 - KJWH: Added ability to save the mapping information
;    MAR 30, 2016 - KJWH: Added ability to save the PIXEL_AREAS, WIDTHS and HEIGHTS for each file 	
;    APR 01, 2016 - KJWH: Added a step to check the size of the arrays before being passed into MAPS_PIXAREA		
;		 APR 26, 2016 - KJWH: Added step to save the GLOBAL information from the .nc file	 
;		 AUG 02, 2016 - KJHW: Changed SKIP_AREAS to GET_AREAS 
;		 SEO 14, 2016 - KJWH: Changed output structure tag from INFILE to NCFILES to be consistent with other savefiles
;-
;	****************************************************************************************************
	ROUTINE_NAME = 'SAVE_MAKE_L2'

  ERROR = 0
  DASH=DELIMITER(/DASH)
  SL=PATH_SEP()
  MAP_IN = 'LONLAT'

	IF NONE(FILES)     THEN FILES     = DIALOG_PICKFILE(TITLE='satellite files')
	IF KEY(DATE_RANGE) THEN FILES     = DATE_SELECT(FILES,DATE_RANGE,COUNT=COUNT_FILES) & IF FILES EQ [] THEN GOTO, DONE
	IF NONE(MAP_OUT)   THEN MAPS      = 'LONLAT'      ELSE MAPS = MAP_OUT[WHERE(VALIDS('MAPS', MAP_OUT) NE '',/NULL)] & IF NONE(MAPS) THEN MAPS = 'LONLAT'
	IF NONE(N_EXCLUDE) THEN N_EXCLUDE = 100
  IF NONE(METHOD)    THEN METHOD    = 'R2015'
  IF NONE(FLAG_BITS) THEN FLAG_BITS = [0,1,2,3,4,5,8,9,10,12,14,15,16,25]
  IF NONE(SST_QUAL)  THEN SST_QUAL  = 2
  
  SAVEPRODS = PRODS(WHERE(STRUPCASE(PRODS) NE 'L2_FLAGS',COUNT,/NULL))  ; Create a list of products to save
  GETPRODS  = SAVE_MAKE_L2_GETPRODS(SAVEPRODS) 
  
; ===> CREATE SAVE, LOG, EXCLUDE AND MAP_INFO OUTPUT DIRECTORIES FOR EACH MAP  
  FA = FILE_PARSE(FILES[0])
  FOR M=0, N_ELEMENTS(MAPS)-1 DO BEGIN
    IF NONE(DIR_OUT) THEN DIR_SAVE = REPLACE(FA[0].DIR,FA[0].SUB,MAPS(M)+SL+'SAVE') ELSE DIR_SAVE = DIR_OUT+MAPS(M)+SL+'SAVE'+SL
    DIR_TEST, [DIR_SAVE,REPLACE(DIR_SAVE,'SAVE','_LOG'),REPLACE(DIR_SAVE,'SAVE','_EXCLUDE'),REPLACE(DIR_SAVE,'SAVE','_MAP_INFO')] 
  ENDFOR
  IF NONE(DIR_OUT) THEN DIR_AREA    = REPLACE(FA.DIR,FA.SUB,'MAP_AREAS') ELSE DIR_AREA    = DIR_OUT+'MAP_AREAS'+SL 
  IF NONE(DIR_OUT) THEN DIR_SUSPECT = REPLACE(FA.DIR,FA.SUB,'SUSPECT')   ELSE DIR_SUSPECT = DIR_OUT+'SUSPECT'  +SL+'MAP_AREAS'+ SL 
  IF NONE(DIR_OUT) THEN DIR_GLOBAL  = REPLACE(FA.DIR,FA.SUB,'GLOBAL')    ELSE DIR_GLOBAL  = DIR_OUT+'GLOBAL'   +SL 
  DIR_TEST, [DIR_AREA,DIR_SUSPECT,DIR_GLOBAL]
  
; LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL  
  FOR F=0, N_ELEMENTS(FILES)-1L DO BEGIN
    AFILE=FILES(F)
    FP = FILE_PARSE(AFILE)
    SI = SENSOR_INFO(AFILE)
    NC = [] ; Make NC null to ensure you are reading the correct file
    GD = [] ; Make GD null to ensure you are reading the correct file
    SD = [] ; Make SD null to ensure you are reading the correct file
    
; ===> Create a PIXAREA file for each file
    MAP_AREA_FILE = DIR_AREA    + FP.NAME_EXT + DASH + 'AREA.SAV'
    SUSPECT_FILE  = DIR_SUSPECT + FP.NAME_EXT + DASH + 'SUSPECT.TXT'
    IF FILE_MAKE(AFILE,SUSPECT_FILE,OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE                    ; If the SUSPECT_FILE exists and is newer than the input file, skip
  
    IF KEY(GET_AREA) AND FILE_MAKE(AFILE,MAP_AREA_FILE,OVERWRITE=OVERWRITE) EQ 1 THEN BEGIN      
      PRINT
      TXT = 'Getting GLOBAL info from: ' + AFILE
      POF,F,FILES,TXT=TXT,/NOPRO
      NC = READ_NC(AFILE, PRODS=['GLOBAL','LATITUDE','LONGITUDE'])
      IF IDLTYPE(NC) EQ 'STRING' THEN BEGIN
        TXT = 'ERROR reading ' + AFILE
        PRINT, TXT
        REPORT, TXT, DIR=DIR_LOG, /QUIET
        WRITE_TXT,SUSPECT_FILE, TXT
        FILE_MOVE, AFILE, DIR_SUSPECT, /VERBOSE
        CONTINUE
      ENDIF
      GD = NC.GLOBAL
      LAT = NC.SD.LATITUDE.IMAGE
      LON = NC.SD.LONGITUDE.IMAGE      
      SZ = SIZEXYZ(LAT,PX=PX,PY=PY)
      IF PX LT 5 OR PY LT 5 THEN BEGIN
        TXT = 'ERROR: Insufficient pixels (PX=' + ROUNDS(PX) + ', PY=' + ROUNDS(PY) + ') for ' + AFILE + ' - Writing SUSPECT_FILE...'
        PRINT, TXT  
        REPORT, TXT, DIR=DIR_LOG, /QUIET
        WRITE_TXT,SUSPECT_FILE, TXT
        FILE_MOVE, AFILE, DIR_SUSPECT, /VERBOSE
        CONTINUE
      ENDIF
      OK = WHERE(LAT GT NC.SD.LATITUDE.VALID_MAX._DATA[0]  OR $
                 LAT LT NC.SD.LATITUDE.VALID_MIN._DATA[0]  OR $
                 LON GT NC.SD.LONGITUDE.VALID_MAX._DATA[0] OR $
                 LON LT NC.SD.LONGITUDE.VALID_MIN._DATA[0],COUNT_LL)
      IF COUNT_LL GE 1 THEN BEGIN
        LAT[OK] = MISSINGS(LAT)
        LON[OK] = MISSINGS(LON)
      ENDIF
      MAREA = MAPS_PIXAREA(LONS=LON, LATS=LAT, OUTFILE=MAP_AREA_FILE) ; Skip if thin or narrow
    ENDIF ; IF NOT KEY(SKIP_AREA) AND FILE_MAKE(AFILE,MAP_AREA_FILE,OVERWRITE=OVERWRITE) EQ 1 THEN BEGIN 

; ===> Create a GLOBAL file for each file 
    GLOBALFILE = DIR_GLOBAL + FP.NAME_EXT + DASH + 'GLOBAL.SAV'
    IF FILE_MAKE(AFILE,GLOBALFILE) EQ 1 THEN BEGIN
      IF GD EQ [] THEN BEGIN ; Only read if GLOBAL is not available
        PFILE, AFILE, /R
        GD = READ_NC(AFILE,PRODS='GLOBAL')
        IF IDLTYPE(GD) EQ 'STRING' THEN BEGIN
          TXT='ERROR: CAN NOT READ '+AFILE+ '; ' + DATE_NOW()
          REPORT,TXT,DIR=DIR_LOG
          PRINT,TXT
          CONTINUE
        ENDIF
        GD=GD.GLOBAL
      ENDIF  
      PRINT, 'WRITING: ' + GLOBALFILE
      SAVE, GD, FILENAME=GLOBALFILE
      IF KEY(GLOBAL_ONLY) THEN CONTINUE
    ENDIF

    
; ************************************************************************************************************************    
    FOR M=0, N_ELEMENTS(MAPS)-1 DO BEGIN
      AMAP = MAPS(M)
      
      IF NONE(DIR_OUT) THEN DIR_SAVE  = REPLACE(FP.DIR,FP.SUB,AMAP+SL+'SAVE') ELSE DIR_SAVE = DIR_OUT+MAPS(M)+SL+'SAVE'+SL
      DIR_LOG      = REPLACE(DIR_SAVE,'SAVE','_LOG')
      DIR_EXCLUDE  = REPLACE(DIR_SAVE,'SAVE','_EXCLUDE')
      DIR_MAP_INFO = REPLACE(DIR_SAVE,'SAVE','_MAP_INFO')
      
      OUTPUT_LABEL=SI.PERIOD+DASH+SI.FILELABEL+DASH+AMAP
      EXCLUDE_FILE  = DIR_EXCLUDE + OUTPUT_LABEL  + '-EXCLUDE.TXT'
      MAP_INFO_FILE = DIR_MAP_INFO + OUTPUT_LABEL + '-LONLAT_STRUCT.SAV'
      IF FILE_MAKE(AFILE,EXCLUDE_FILE,OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE                    ; If the EXCLUDE_FILE exists and is newer than the input file, skip
      IF KEY(MAP_ONLY) AND FILE_MAKE(AFILE,MAP_INFO_FILE,OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE ; If only creating the mapping structure and the MAP_INFO file exists, skip
    
      IF FILE_MAKE(AFILE,MAP_INFO_FILE,OVERWRITE=OVERWRITE) EQ 0 THEN BEGIN
        LONLAT_STRUCT = IDL_RESTORE(MAP_INFO_FILE)
        GOTO, SKIP_EXCLUDE_CHECK
      ENDIF ELSE LONLAT_STRUCT = []
    
;     ***** Read the standard landmask for this map *****
;      STRUCT_LANDMASK = READ_LANDMASK(AMAP,/STRUCT)
;      OK_LAND     = STRUCT_LANDMASK.LAND
;      COUNT_LAND  = STRUCT_LANDMASK.COUNT_LAND
;      OK_OCEAN    = STRUCT_LANDMASK.OCEAN
;      COUNT_OCEAN = STRUCT_LANDMASK.COUNT_OCEAN
;      GONE, STRUCT_LANDMASK
      
      IF NC EQ [] THEN BEGIN
        PRINT
        TXT = 'Getting GLOBAL info from: ' + AFILE
        POF,F,FILES,TXT=TXT,/NOPRO         
        NC = READ_NC(AFILE, PRODS=['GLOBAL','LATITUDE','LONGITUDE'])
        IF IDLTYPE(NC) EQ 'STRING' THEN BEGIN
          TXT = 'ERROR reading ' + AFILE
          stop
          REPORT, TXT, DIR=REPLACE(FP.DIR,FP.SUB,'LOG'),/QUIET
          CONTINUE
        ENDIF   
      ENDIF 
      
      MP = MAPS_INFO(AMAP)
      LATMIN = MP.LIMIT[0]
      LATMAX = MP.LIMIT(2)
      LONMIN = MP.LIMIT[1]
      LONMAX = MP.LIMIT(3)
       
      SLATMIN = NC.GLOBAL.GEOSPATIAL_LAT_MIN
      SLATMAX = NC.GLOBAL.GEOSPATIAL_LAT_MAX
      SLONMIN = NC.GLOBAL.GEOSPATIAL_LON_MIN
      SLONMAX = NC.GLOBAL.GEOSPATIAL_LON_MAX
      IF SLATMAX LT LATMIN OR SLATMIN GT LATMAX OR SLONMAX LT LONMIN OR SLONMIN GT LONMAX THEN BEGIN
        TXT = AMAP + ' bounds are not within the boundaries of ' + AFILE + ' - Writing EXCLUDE_FILE...'
        PRINT, TXT  
        REPORT, TXT, DIR=DIR_LOG, /QUIET
        WRITE_TXT,EXCLUDE_FILE, TXT
        CONTINUE
      ENDIF
            
      LAT = NC.SD.LATITUDE.IMAGE
      LON = NC.SD.LONGITUDE.IMAGE
      SAT_DATA = LAT & SAT_DATA(*) = 0 ; Create a blank array to remap
      MAP_IMG = MAPS_REMAP(SAT_DATA, MAP_IN='LONLAT', MAP_OUT=AMAP, CONTROL_LONS=LON, CONTROL_LATS=LAT, LONLAT_STRUCT=LONLAT_STRUCT)
      IF IDLTYPE(MAP_IMG) EQ 'STRING' THEN BEGIN
        TXT = AMAP + ' has less than 10 pixels within the boundaries of ' + AFILE + ' - Writing EXCLUDE_FILE...'
        PRINT, TXT
        REPORT, TXT, DIR=DIR_LOG, /QUIET
        WRITE_TXT,EXCLUDE_FILE, TXT
        CONTINUE
      ENDIF
      PRINT, 'SAVING MAP_INFO_STRUCT: ' + MAP_INFO_FILE
      IF IDLTYPE(LONLAT_STRUCT) EQ 'STRUCT' THEN SAVE, LONLAT_STRUCT, FILENAME=MAP_INFO_FILE
      IF KEY(MAP_ONLY) THEN CONTINUE
    
      SKIP_EXCLUDE_CHECK:

      SAVEPRODS = []
      SAVEFILES = []
      EXCLUDES  = []
      FOR P = 0,N_ELEMENTS(PRODS)-1 DO BEGIN
        APROD = PRODS(P)        
        DIR_PROD = DIR_SAVE + APROD + SL & DIR_TEST, DIR_PROD
        SAVEFILE = DIR_PROD + OUTPUT_LABEL + DASH + APROD + '.SAV'
        EXCLUDE_PROD = DIR_EXCLUDE + OUTPUT_LABEL + DASH + APROD + '-EXCLUDE.TXT'
        IF FILE_MAKE(AFILE,EXCLUDE_PROD,OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE  ; If the EXCLUDE_FILE exists and is newer than the input file, skip
        IF FILE_MAKE(AFILE,SAVEFILE,OVERWRITE=OVERWRITE_SAVE) EQ 1 THEN BEGIN
          SAVEPRODS = [SAVEPRODS,STRUPCASE(APROD)]
          SAVEFILES = [SAVEFILES,SAVEFILE]
        ENDIF
      ENDFOR
      IF SAVEPRODS EQ [] THEN CONTINUE ; >>> No new files to create >>>>>>
       
; ===> Get the PRODUCTS in the file and construct output product-algorithm names 
      IF SIP EQ [] THEN SIP = SENSOR_INFO(AFILE,/GET_PRODS) 
      PROD_NAME    = STRSPLIT(SIP.PRODS,  SIP.DELIM,/EXTRACT,/PRESERVE_NULL)
      ALG_NAME     = STRSPLIT(SIP.ALG,    SIP.DELIM,/EXTRACT,/PRESERVE_NULL)
      L2_PROD_NAME = STRSPLIT(SIP.NC_PROD,SIP.DELIM,/EXTRACT,/PRESERVE_NULL)
      OK = WHERE(ALG_NAME NE '',COUNT)
      IF COUNT GE 1 THEN PROD_NAME[OK] = PROD_NAME[OK] + DASH + ALG_NAME[OK]

      OK=WHERE_MATCH(PROD_NAME,SAVEPRODS,COUNT, VALID=VALID, NINVALID=NINVALID,INVALID=INVALID)
      IF COUNT GE 1 THEN BEGIN
        PRODUCTS = PROD_NAME[OK]
        L2_PRODS = L2_PROD_NAME[OK]
      ENDIF
      IF NINVALID GE 1 THEN BEGIN
        CPROD = SAVEPRODS(INVALID)
        FOR C=0, N_ELEMENTS(CPROD)-1 DO BEGIN
          TXT = CPROD(C) + ': is not a valid product for file - ' + AFILE + ' - Writing EXCLUDE_FILE...'
          PRINT, TXT
;          REPORT, TXT, DIR=DIR_LOG
;          WRITE_TXT,DIR_EXCLUDE + OUTPUT_LABEL + DASH + APROD + '-EXCLUDE.TXT', TXT
;          CONTINUE
        ENDFOR
        IF NINVALID EQ N_ELEMENTS(SAVEPRODS) THEN CONTINUE ; No additional products to process
      ENDIF  
  
;      OK=WHERE_MATCH(STRUPCASE(PRODUCTS),STRUPCASE(SAVEPRODS),COUNT)
;      IF COUNT EQ 0 THEN BEGIN
;        TXT = 'ERROR: ' + SAVEPRODS + ' Are not valid products for file - ' + AFILE  
;       stop 
;        REPORT, TXT, DIR=REPLACE(FP.DIR,FP.SUB,'LOG')
;        CONTINUE
;      ENDIF ELSE L2_PRODS = L2_PRODS[OK]
     
      NC_PRODS = [L2_PRODS]
      IF SD EQ [] THEN BEGIN
        PRINT, 'READING: ' + AFILE 
        SD = READ_NC(AFILE,PRODS=[L2_PRODS,'L2_FLAGS','QUAL_SST','QUAL_SST4','FLAGS_SST','FLAGS_SST4','BIAS_SST4','BIAS_SST'])
        IF IDLTYPE(SD) EQ 'STRING' THEN BEGIN
          TXT = 'ERROR reading ' + AFILE
        stop  
          REPORT, TXT, DIR=REPLACE(FP.DIR,FP.SUB,'LOG')
          CONTINUE
        ENDIF
      SD = SD.SD
      ENDIF ; IF SD EQ [] THEN BEGIN  
            
      ; ===> Generate L2_FLAGS masks
      IF STRUCT_HAS(SD,'QUAL_SST') EQ 0 AND STRUCT_HAS(SD,'QUAL_SST4') EQ 0 THEN MASK_FLAG = SD_FLAGS_COMBO(SD.L2_FLAGS.IMAGE,FLAG_BITS) ELSE BEGIN
        MASK_FLAG = SD.QUAL_SST.IMAGE                ; For SST images, use the QUAL_SST flag instead
        MASK_FLAG(WHERE(MASK_FLAG LE SST_QUAL)) = 0  
      ENDELSE
      OK_L2_FLAGS = WHERE(MASK_FLAG GT 0, COUNT_L2_FLAGS)
      
      FOR P=0, N_ELEMENTS(L2_PRODS)-1 DO BEGIN
        APROD    = STRUPCASE(VALIDS('PRODS',SAVEPRODS(P)))
        AALG     = STRUPCASE(VALIDS('ALGS', SAVEPRODS(P)))
        SAVEFILE = SAVEFILES(P)
        POS = WHERE(STRUPCASE(TAG_NAMES(SD)) EQ STRUPCASE(L2_PRODS(P)),COUNT) & IF COUNT EQ 0 THEN STOP
        S = SD.(POS)    
        IMG = S.IMAGE
        
        ; ===>  Find FILLED/BAD data
        IF STRUCT_HAS(S,'_FILLVALUE')       THEN FV = S._FILLVALUE._DATA[0] ELSE FV = MISSINGS(IMG)
        IF STRUCT_HAS(S,'BAD_VALUE_SCALED') THEN BV = S.BAD_VALUE_SCALED    ELSE BV = MISSINGS(IMG)
        IF STRUCT_HAS(S,'VALID_MIN')        THEN MN = S.VALID_MIN._DATA[0]  ELSE MN = MIN(IMG)
        IF STRUCT_HAS(S,'VALID_MAX')        THEN MX = S.VALID_MAX._DATA[0]  ELSE MX = MAX(IMG) 

        ; ===>  Find GOOD data
        OK_GOOD=WHERE(IMG NE MISSINGS(IMG) AND IMG NE BV AND IMG NE FV AND IMG LE MX AND IMG GE MN,COUNT_GOOD,COMPLEMENT=OK_BAD,NCOMPLEMENT=COUNT_BAD) 
        
        ; ===> Scale with slope and intercept if available
        SLOPE = 1.0 & INTERCEPT = 0.0
        IF STRUCT_HAS(S,'SLOPE')            THEN SLOPE = FLOAT(S.SLOPE[0])
        IF STRUCT_HAS(S,'SCALE_FACTOR')     THEN SLOPE = FLOAT(S.SCALE_FACTOR._DATA[0])
        IF STRUCT_HAS(S,'INTERCEPT')        THEN INTERCEPT = FLOAT(S.INTERCEPT[0])
        IF STRUCT_HAS(S,'ADD_OFFSET')       THEN INTERCEPT = FLOAT(S.ADD_OFFSET._DATA[0])

        SAT_DATA = IMG * SLOPE + INTERCEPT

        ; ===>  Make "BAD" data MISSINGS
        IF COUNT_BAD GE 1 THEN SAT_DATA(OK_BAD) = MISSINGS(SAT_DATA) ; Mask out MISSING and BAD_VALUE data
        
        ; ===> Apply the L2_FLAGS mask to all products except those listed
        IF HAS(['PAR','SENZ'],APROD) EQ 0 AND COUNT_L2_FLAGS GE 1 THEN SAT_DATA(OK_L2_FLAGS) = MISSINGS(SAT_DATA) ; Mask out data based on L2 FLAGS
  
        ; ===> Remap data !!!! WILL NEED TO UPDATE ONCE MAPS_REMAP IS COMPLETE !!!!!   
        MAP_IMG = MAPS_REMAP(SAT_DATA, MAP_IN='LONLAT', MAP_OUT=AMAP, CONTROL_LONS=LON, CONTROL_LATS=LAT, LONLAT_STRUCT=LONLAT_STRUCT)
  
        STRUCT_WRITE, MAP_IMG, FILE=SAVEFILE, DATA_UNITS=UNITS(APROD), NCFILES=AFILE, ALG=AALG, PROD=APROD, GLOBALFILE=GLOBALFILE, $
          METHOD=SI.METHOD, SATELLITE=SI.SATELLITE, SENSOR=SI.SENSOR, COVERAGE=SI.COVERAGE, DATA_SOURCE=SI.SOURCE
 
      ENDFOR ; FOR P=0, N_ELEMENTS(DO_PROD)-1 DO BEGIN
    ENDFOR   ; FOR M=0, N_ELEMENTS(MAPS)-1 DO BEGIN
    SD = []
    SIP = []
  ENDFOR     ; FOR F=0, N_ELEMENTS(FILES)-1L DO BEGIN
   
 DONE:
END; #####################  End of Routine ################################

; $ID:	SAVE_MAKE_GHRSST.PRO,	2023-09-21-13,	USER-KJWH	$
 
PRO SAVE_MAKE_GHRSST, FILES, DIR_OUT=DIR_OUT, MAPS_OUT=MAPS_OUT, MAP_SUBSET=MAP_SUBSET, LOGLUN=LOGLUN, $
                      LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX, $
                      RETURN_STRUCT=RETURN_STRUCT, ANALYSIS_ERROR=ANALYSIS_ERROR, OVERWRITE=OVERWRITE 
 
;+
; NAME:
;   SAVE_MAKE_GHRSST
; 
; PURPOSE: 
;   Read GHRSST files and create mapped save files
; 
; REQUIRED INPUTS:
;   FILES........... An array of files to process
;   
; OPTIONAL INPUTS
;   DIR_OUT......... Directory to store save files of the final output data/image
;   DATERANGE....... Specify the date range of the input files
;   MAPS_OUT........ Array of maps to produce from the SST files
;   LONMIN.......... Minimum longitude to subset the original file (sent to MAPS_REMAP)
;   LONMAX.......... Maximum longitude to subset the original file (sent to MAPS_REMAP)
;   LATMIN.......... Minimum latitude to subset the original file (sent to MAPS_REMAP)
;   LATMAX.......... Maximum latitude to subset the original file (sent to MAPS_REMAP)
;   LOGLUN.......... If provided, then lun for the log file
; 
; KEYWORD PARAMETERS:
;   SAVE_STD
;   RETURN_STRUCT... Keyword sent to STRUCT_WRITE to return the SAV structure (so that it doesn't have to be read again)
;   OVERWRITE....... Overwrite file if it exists
;   REFRESH......... Refresh the MAP_REMAP common memory
; 
; OUTPUTS:
;   Creates new save files
;   
; OPTIONAL OUTPUTS
;    
; 
;
; 
; MODIFICATION HISTORY: 4 November 2013 - Modified by KHyde - Adapted read_g1_nc_exp to be compatible with KHyde's routines 
;   AUG 12, 2015 - KJWH: Renamed to SAVE_MAKE_GHRSST and updated with new functions
;                        Changed keyword REMOVE_HDF to KEEP_UNZIPPED (and updated the code accordingly)
;                        Removed PX_OUT and PY_OUT keywords (just using the MAP_SIZE defualts)
;                        Updated the OUTPUT label to be consistent with new file names
;   OCT 30, 2015 - KJWH: Added SAVE_STD keyword
;                        Updated mapping steps to include L3B maps  
;                        Removed unneeded keywords       
;   NOV 30, 2015 - KJWH: Changed DIR_LOG location to be !S.LOGS + ROUTINE_NAME
;                        In the check to find an READ_NC error, changed GOTO, DONE to CONTINUE so it will proceed to the next file 
;                        Removed old commented out code       
;   MAR 18, 2016 - KJWH: Changed DATATYPE to IDLTYPE                                               
;   MAR 29, 2016 - KJWH: Added MAPS_REMAP call to remap the SST, MASK and STD image arrays   
;   APR 25, 2016 - KJWH: Added step to write out the original GLOBAL information in the netcdf as a .SAV file       
;   AUG 02, 2016 - KJWH: Removed keyword DIR_DATASET - not used           
;   SEP 14, 2016 - KJWH: Changed the output struct tag "INFILE" to "NCFILES" to be consistent with other files
;   OCT 03, 2016 - KJWH: Updated formatting
;                        Added ORIGINAL_DATE_CREATED=GLOBAL.DATE_CREATED to the save structure
;   MAY 14, 2018 - KJWH: Removed IMAGE=SST_IMG from the save structure.  There is no need to save the data array twice.    
;   SEP 06, 2019 - KJWH: Added LOGLUN keyword  
;   FEB 17, 2022 - KJWH: Updated documentation
;                        Removed unused or duplicate keywords (SAVE_STD and DATA_ONLY)
;                        Added COMPILE_OPT IDL2   
;                        Removed the PICK FILE option and now returning an error if no files are provided 
;   MAY 12, 2022 - KJWH: Now using MAPS_MUR_2BIN to remap (and subset) the array instead of MAPS_REMAP 
;                                   
;-                        
;****************************************
  ROUTINE_NAME = 'SAVE_MAKE_GHRSST'
  COMPILE_OPT IDL2
  DASH=DELIMITER(/DASH)
  SL=PATH_SEP()
  
  IF ~N_ELEMENTS(LOGLUN) THEN LOG_LUN = [] ELSE LOG_LUN = LOGLUN
  DIR_LOG = !S.LOGS + ROUTINE_NAME + SL & DIR_TEST, DIR_LOG
  
  IF  ~N_ELEMENTS(MAPS_OUT) THEN MAPS = 'NO_MAP' ELSE MAPS = MAPS_OUT    
  IF ~N_ELEMENTS(FILES) THEN BEGIN
    MESSAGE, 'ERROR: Must provide input files.', /CONTINUE
    GOTO, DONE 
  ENDIF
  SST_FILES = FILES
  
  IF N_ELEMENTS(MAP_SUBSET) EQ 1 THEN BEGIN
    MI = MAPS_INFO(MAP_SUBSET)
  ENDIF

  DATA_UNITS='Degrees Celsius'
  KELVIN_2CEL = 273.15
  
  FP = FILE_PARSE(FILES[0])
  IF ~N_ELEMENTS(DIR_OUT) THEN DIR_OUT = REPLACE(FP.DIR,FP.SUB+SL,'')
  DIR_GLOBAL = DIR_OUT + 'GLOBAL' + SL
  DIRS_SAVE = []
  FOR M=0, N_ELEMENTS(MAPS)-1 DO DIRS_SAVE = [DIRS_SAVE,DIR_OUT + MAPS[M] + SL + 'SAVE' + SL + 'SST'  + SL]
  DIR_TEST, [DIR_GLOBAL,DIRS_SAVE]
  
  FOR NTH = 0L, N_ELEMENTS(SST_FILES)-1 DO BEGIN
    SFILE = SST_FILES[NTH]
    FP = FILE_PARSE(SFILE)
    SI = SENSOR_INFO(SFILE)
    MAP_IN = SI.MAP
    PRODS = STRSPLIT(SI.NC_PROD,SI.DELIM,/EXTRACT)
    OUTPUT_LABEL = SI.PERIOD + DASH + SI.SENSOR + DASH + SI.METHOD + DASH + SI.COVERAGE + DASH + MAPS + DASH + 'SST'
    SAVEFILES = DIRS_SAVE + OUTPUT_LABEL + '.SAV'
    GLOBALFILE = DIR_GLOBAL + SI.PERIOD + DASH + SI.SENSOR + DASH + SI.METHOD + DASH + SI.COVERAGE + DASH + 'GLOBAL' + '.SAV'

    IF FILE_MAKE(SFILE,[GLOBALFILE,SAVEFILES],OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE
    
    IF FILE_MAKE(SFILE,SAVEFILES,OVERWRITE=OVERWRITE) EQ 0 THEN BEGIN ; Just missing the GLOBAL file
      POF, NTH, SST_FILES, OUTTXT=OUTTXT,/QUIET
      PFILE, SFILE, /R, _POFTXT=OUTTXT
      SD = READ_NC(SFILE,PRODS='GLOBAL')
      IF IDLTYPE(SD) EQ 'STRING' THEN BEGIN
        TXT='ERROR: CAN NOT READ '+SFILE+ '; ' + DATE_NOW()
        REPORT,TXT,DIR=DIR_LOG
        PLUN, LOG_LUN,TXT
        CONTINUE
      ENDIF
      GLOBAL=SD.GLOBAL
      PLUN, LOG_LUN, 'WRITING: ' + GLOBALFILE
      SAVE, GLOBAL, FILENAME=GLOBALFILE
      CONTINUE
    ENDIF

;*****************************************
;Read in data and pull out SST
    POF, NTH, SST_FILES, OUTTXT=OUTTXT,/QUIET
    PFILE, SFILE, /R, _POFTXT=OUTTXT
    SD = READ_NC(SFILE,PRODS=['GLOBAL',PRODS])
    IF IDLTYPE(SD) EQ 'STRING' THEN BEGIN
      TXT='ERROR: Not able to read '+SFILE+ '; ' + DATE_NOW()
      REPORT,TXT,DIR=DIR_LOG
      PLUN, LOG_LUN,TXT
      CONTINUE
    ENDIF
    GLOBAL=SD.GLOBAL
    IF FILE_MAKE(SFILE,GLOBALFILE,OVERWRITE=OVERWRITE) THEN SAVE, GLOBAL, FILENAME=GLOBALFILE
    
IF SI.SENSOR EQ 'GEOPOLAR' THEN BEGIN ; TEMP CODE TO WORK WITH THE TEMP FILES
  SST  = SD.SD.AVERAGED_SST

  ;NOTES   = [GLOBAL.REFERENCES,GLOBAL.INSTITUTION,GLOBAL.SOURCE]
  INFILES = SFILE
  SOURCE = STRJOIN([SST.SOURCE_2,SST.SOURCE_3,SST.SOURCE_4,SST.SOURCE_5,SST.SOURCE_6,SST.SOURCE_7],';')
  GONE, SD

  ; READ IN IMAGE AND CONVERT TO CELCIUS FROM KELVIN
  SST_IMAGE   = SST.IMAGE
  OK_MISSINGS = WHERE(SST_IMAGE EQ SST._FILLVALUE[0] OR SST_IMAGE EQ MISSINGS(SST_IMAGE),COUNT_BAD)
  SST_IMAGE   = (FLOAT(SST_IMAGE) * FLOAT(SST.SCALE_FACTOR[0])) + FLOAT(SST.ADD_OFFSET[0]) - KELVIN_2CEL
  SST_IMAGE[WHERE(SST_IMAGE GT 45.0,/NULL)] = MISSINGS(0.0)  ; Remove any temperature values greater than 45
  SST_IMAGE[OK_MISSINGS] = MISSINGS(0.0) 
  
  
  FOR MTH=0, N_ELEMENTS(MAPS)-1 DO BEGIN
    IF FILE_MAKE(SFILE,SAVEFILES[MTH],OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE
    AMAP = MAPS[MTH]
    SST_IMG  = MAPS_REMAP(SST_IMAGE, MAP_IN=MAP_IN,MAP_OUT=AMAP,MAP_SUBSET=MAP_SUBSET,LONMIN=LONMIN,LONMAX=LONMAX,LATMIN=LATMIN,LATMAX=LATMAX)
  
    STRUCT_WRITE, SST_IMG, FILE=SAVEFILES[MTH], GLOBAL=GLOBAL, DATA_UNITS=UNITS('SST'), NCFILES=INFILES, FILE_NAME=SAVEFILE, LOGLUN=LOG_LUN, $
      MAP=AMAP, METHOD=METHOD, SATELLITE=SATELLITE, SENSOR=SENSOR, COVERAGE=COVERAGE, MASK_IMAGE=MASK_IMG, MASK_CODE=MASK_CODE, MASK_NAME=MASK_NAME, SOURCE=SOURCE,$
      COMMENT=SST.COMMENT,LONG_NAME=SST.LONG_NAME, STANDARD_NAME=SST.STANDARD_NAME, ROUTINE=ROUTINE_NAME
    ENDFOR
  CONTINUE
  
ENDIF ; GEOPOLAR
    
    SST  = SD.SD.ANALYSED_SST
    STD  = SD.SD.ANALYSIS_ERROR
    MASK = SD.SD.MASK
           
    NOTES   = [GLOBAL.REFERENCES,GLOBAL.INSTITUTION,GLOBAL.SOURCE]
    INFILES = SFILE
    GONE, SD 
        
; READ IN IMAGE AND CONVERT TO CELCIUS FROM KELVIN 
    SST_IMAGE   = SST.IMAGE
    OK_MISSINGS = WHERE(SST_IMAGE EQ SST._FILLVALUE[0] OR SST_IMAGE EQ MISSINGS(SST_IMAGE),COUNT_BAD)
    SST_IMAGE   = (FLOAT(SST_IMAGE) * FLOAT(SST.SCALE_FACTOR[0])) + FLOAT(SST.ADD_OFFSET[0]) - KELVIN_2CEL    
    SST_IMAGE[WHERE(SST_IMAGE GT 45.0,/NULL)] = MISSINGS(0.0)  ; Remove any temperature values greater than 45
    SST_IMAGE[OK_MISSINGS] = MISSINGS(0.0)
    
; READ IN ANALYSIS ERROR 
    STD_IMAGE   = STD.IMAGE
    OK_MISSINGS = WHERE(STD_IMAGE EQ STD._FILLVALUE[0] OR STD_IMAGE EQ MISSINGS(STD_IMAGE),COUNT_BAD)
    STD_IMAGE   = (FLOAT(STD_IMAGE) *  FLOAT(STD.SCALE_FACTOR[0])) + FLOAT(STD.ADD_OFFSET[0])
    STD_IMAGE[OK_MISSINGS] = MISSINGS(0.0)
    
; READ IN THE MASK     
    MASK_IMAGE = MASK.IMAGE      
    CASE SI.SENSOR OF
      'MUR': BEGIN
        MASK_CODE = [1,2,5,9,13]
        MASK_NAME = ['OPEN_SEA','LAND','OPEN_LAKE','SEA_WITH_ICE','LAKE_WITH_ICE']
        OK_MASK = WHERE(MASK_IMAGE EQ 2, COUNT_MASK)
        IF COUNT_MASK GE 1 THEN BEGIN
          SST_IMAGE[OK_MASK] = MISSINGS(SST_IMAGE)
          STD_IMAGE[OK_MASK] = MISSINGS(STD_IMAGE)
        ENDIF
      END
      'GEOPOLAR': BEGIN
        MASK_CODE = [1,2,4]
        MASK_NAME = ['OCEAN','LAND','ICE']
        OK_MASK = WHERE(MASK.IMAGE EQ 2 OR MASK.IMAGE EQ 4, COUNT_MASK)
        IF COUNT_MASK GE 1 THEN BEGIN ; Make the land and ice pixels missings
          SST_IMAGE[OK_MASK] = MISSINGS(SST_IMAGE)
          STD_IMAGE[OK_MASK] = MISSINGS(STD_IMAGE)
        ENDIF
      END
      'GEOPOLAR_INTERPOLATED': BEGIN
        MASK_CODE = [1,2,4]
        MASK_NAME = ['OCEAN','LAND','ICE']
        OK_MASK = WHERE(MASK.IMAGE EQ 2 OR MASK.IMAGE EQ 4, COUNT_MASK)
        IF COUNT_MASK GE 1 THEN BEGIN ; Make the land and ice pixels missings
          SST_IMAGE[OK_MASK] = MISSINGS(SST_IMAGE)
          STD_IMAGE[OK_MASK] = MISSINGS(STD_IMAGE)
        ENDIF
      END
    ENDCASE ; NEED TO WORK OUT G1SST MASK  
    GONE, MASK
    
     
    FOR MTH=0, N_ELEMENTS(MAPS)-1 DO BEGIN
      IF FILE_MAKE(SFILE,SAVEFILES[MTH],OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE
      AMAP = MAPS[MTH]
      SUBPOS = STRPOS(AMAP,'SUBSET')
      IF SUBPOS GE 0 THEN MUR_SUBSET = 1 ELSE MUR_SUBSET = 0
      
   ;   SST_IMG  = MAPS_REMAP(SST_IMAGE, MAP_IN=MAP_IN,MAP_OUT=AMAP,MAP_SUBSET=MAP_SUBSET,LONMIN=LONMIN,LONMAX=LONMAX,LATMIN=LATMIN,LATMAX=LATMAX)
      SST_IMG = MAPS_MUR_2BIN(SST_IMAGE, AMAP, MAP_SUBSET=MAP_SUBSET, BINS_OUT=BINS_SST, INIT=INIT)

      IF MUR_SUBSET EQ 0 THEN MASK_IMG = [] ELSE MASK_IMG = MAPS_REMAP(MASK_IMAGE,MAP_IN=MAP_IN,MAP_OUT=AMAP,MAP_SUBSET=MUR_SUBSET,LONMIN=LONMIN,LONMAX=LONMAX,LATMIN=LATMIN,LATMAX=LATMAX)
      
      IF KEYWORD_SET(ANALYSIS_ERROR) THEN BEGIN
     ;   STD_IMG  = MAPS_REMAP(STD_IMAGE, MAP_IN=MAP_IN,MAP_OUT=AMAP,MAP_SUBSET=MUR_SUBSET,LONMIN=LONMIN,LONMAX=LONMAX,LATMIN=LATMIN,LATMAX=LATMAX)
        STD_IMG = MAPS_MUR_2BIN(STD_IMAGE, AMAP, MAP_SUBSET=MAP_SUBSET, BINS_OUT=STD_BINS, INIT=INIT)

        STD_IMG[WHERE(STD_IMG EQ MISSINGS(STD_IMG),/NULL)] = 32767.0
        ERRSTR = CREATE_STRUCT('ANALYSIS_ERROR',STD.ANALYSIS_ERROR, 'SIMAGE',STD_IMG, 'BINS', STD_BINS, 'LONG_NAME',STD.LONG_NAME, 'UNITS','celsius',$
          '_FILLVALUE',32767.0, 'ADD_OFFSET',0.0, 'SCALE_FACTOR',1.0, 'VALID_MIN',0.0, 'VALID_MAX',32767.0, 'COMMENT',STD.COMMENT, 'COORDINATES',STD.COORDINATES)
      ENDIF ELSE ERRSTR = []
      
      IF KEY(DATA_ONLY) THEN RETURN_STRUCT = 1 ELSE RETURN_STRUCT = 0
      STRUCT_WRITE, SST_IMG, FILE=SAVEFILES[MTH], BINS=BINS_SST, RETURN_STRUCT=RETURN_STRUCT, GLOBAL=GLOBAL, DATA_UNITS=UNITS('SST'), NCFILES=INFILES, FILE_NAME=SAVEFILE, LOGLUN=LOG_LUN, $
        MAP=AMAP,METHOD=METHOD, SATELLITE=SATELLITE, SENSOR=SENSOR, COVERAGE=COVERAGE, MASK_IMAGE=MASK_IMG, MASK_CODE=MASK_CODE, MASK_NAME=MASK_NAME, SOURCE=SST.SOURCE,$
        COMMENT=SST.COMMENT,LONG_NAME=SST.LONG_NAME, STANDARD_NAME=SST.STANDARD_NAME, ANALYSIS_ERROR=ERRSTR, NOTES=NOTES, ROUTINE=ROUTINE_NAME, ORIGINAL_DATE_CREATED=GLOBAL.DATE_CREATED
       
      GONE, SST_IMG
      GONE, MASK_IMG
      GONE, STD_IMG   

    ENDFOR ; FOR MTH=0, N_ELEMENTS(MAPS)-1 DO BEGIN
    GONE, SST
    GONE, STD
    GONE, LAT
    GONE, LON
    GONE, SST_IMAGE
    GONE, MASK_IMAGE
    
   
  ENDFOR    

  DONE:
END




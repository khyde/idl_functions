; $ID:	WRITE_DB.PRO,	2020-07-08-15,	USER-KJWH	$
; June 2, 2003 td replace strtrim(string with strtrim if format not specific
;
PRO write_db , FILE , ARRAY, TRANSLATION , QUIET = quiet
;
;+
; NAME:
;       write_db
;
; PURPOSE:
;       Write a dBASE file from an IDL Structure Array
;
; CATEGORY:
;       Input/Output (See read_db.pro).
;
; CALLING SEQUENCE:
;       WRITE_DB, file,  array, translation
;
; INPUT PARAMETERS:
;       File:   Name of the output dBASE.dbf to write.
;      Array:   Name of the IDL Array Structure to be written into a dBASE file.
;
; OUTPUTS:
;      dBASE Binary database file (Version IV, V)
;
;
; OPTIONAL PARAMETERS:
;       Translation:  Name (Scalar string) for the output string array
;                     which describes the translation of IDL Structure (tags)
;                     into dbase fields.
;
; KEYWORDS
;       QUIET  (Prevents printing of information generated by program)
;
; SIDE EFFECTS:
;       dBASE IV,V can store numeric and float data with with a maximum size of
;       20 digits and a precision of 19 digits, whereas IDL Double
;       has a precision of approximately 16 digits (14 decimal places).
;       To avoid loss of information, IDL Double fields exceeding 12 digits
;       are converted into dBase character fields.
;
;  The following is the translation strategy used by this program:
;
; =============================================================================>
; IDL >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TO  >>>>>>>>>>>>>>>>>>>>> dBASE
; IDL   IDL                    Decimal     Missing       | dBASE     dBASE   Decimal  Missing
; CODE  TYPE                   Places      Code          |  TYPE     LENGTH  Places   Code
; =======================================================|===============================>
; 0     Undefined                                           Ignored
; 1     Byte                                                Ignored
; 2     Integer                                     32767   Numeric    1-6     0      Blank
; 3     Longword integer                       2147483647   Numeric    1-11    0      Blank
; 4     Floating point         LE 12   !VALUES.F_INFINITY   Numeric    14      1-12   Blank
; 4     Floating Point         GT 12   !VALUES.F_INFINITY   Character  Varies  0      Blank
; 5     Double-precision float LE 12   !VALUES.D_INFINITY   Numeric    14      1-12   Blank
; 5     Double-precision float GT 12   !VALUES.D_INFINITY   Character  Varies  0      Blank
; 6     Complex floating                                    Ignored
; 7     String                           '' (empty string)  Character  Varies  0      Blank
; 8     Structure                                           Ignored
; 9     Double-precision complex                            Ignored

;
; RESTRICTIONS:
;       Writes dBASE files used by dBASE IV and V.
;       (Dbase III and earlier formats are not supported.
;
;       The fields (tags) in IDL array structure must be one dimensional.
;       IF they are more than one dimension or if the field is a structure
;       then this program will skip over the IDL tag(field).
;
; EXAMPLE:
;       To write an array structure called dataset1
;       to a dBASE file named "TEST.DBF" into the current
;       directory, enter:
;                         write_db, 'TEST.DBF', DATASET1
;       If you also want to generate a string_array describing the
;       IDL/dBASE translation enter:
;                         write_db, 'TEST.DBF', DATASET1, LIST
;
; MODIFICATION HISTORY:
;
;       December 3,1995, Written by J.E.O'Reilly
;   NOAA, NMFS Narragansett Laboratory, 28 Tarzwell Drive, Narragansett, RI 02882-1199
;   oreilly@fish1.gso.uri.edu
;
;       Jan 11,1996 Changed program to convert integer and float to dBASE numerics
;       Jul 03,1996 Fixed error in program (each output dBase record now begins with a 32b)
;-

; ====================>
; SOME NOTES ABOUT dBASE 4, dBASE 5 FILES:
;       dBASE files *.DBF are binary
;       Stored in the first 32 bytes is:

;       Information on Last Update, y,m,d (bytes 1,2,3)
;       Number of Records                 (bytes 4,5,6)
;       Length of Header (bytes)          (bytes 8,9)
;       Record length (bytes)             (bytes 10,11)
;       Index information                 (bytes up to 32nd ?)
;
;       Thereafter, information about each data field (variable)
;       in the database is stored in 32 bytes segments
;       (32 bytes *number of data fields)
;       This is followed by a '13b',
;       Then followed by the actual data bytes:
;       (record length in bytes * number of records)
;       (Note that each dBASE record begins with a 32b)
;       The last byte in the file is a 26b to terminate the file
;
; END OF PROGRAM DOCUMENTATION


; ====================>
; Check Parameters and Keywords
;
;  See if dBASE input File Name and the name for the output array structure
;  was supplied by user
  IF n_params() lt 2 THEN BEGIN
    MESSAGE, 'You Must Enter a name for the dBASE File and the Name of the IDL Array to write i.e. write_db, ''test.dbf'', dataset1'
    RETURN
  ENDIF ELSE BEGIN
    OPENW, lun, file, /GET_LUN   ; Open dBASE file: 'file'
  ENDELSE

; ====================>
; Make sure the Array is a Structure
  s = SIZE(ARRAY[0])
  s = s(2)
  IF s NE 8 THEN MESSAGE, 'ERROR:The ARRAY you provided is not an array structure, Can not write to a dbase file'

; ====================>
; Determine number of elements (records) and number of fields in array structure
  n_records = LONG(N_ELEMENTS(array))
  n_fields  = N_TAGS(array)

; ====================>
; Dimension the variables needed by the program
 ; IDL MISSING CODES:
    idlmissing={Undefined:0,$
                Byte:0,$
                Integer:32767,$
                Long:2147483647L,$
                Float:!VALUES.F_INFINITY,$
                Double:!VALUES.D_INFINITY,$
                Complex_floating:0,$
                String:"''",$
                Structure:0,$
                Double_complex:0}

; ====================>
; Get the names of the idl types
  idl_type    = TAG_NAMES(IDLMISSING)



  dbtypes = ['None','None','Numeric','Numeric','Numeric',$
             'Numeric','None','Character','None','None']

; idlcodes = [0,    1,   2,   3,   4,   5,   6,   7,   8,  9,]
  dbcodes  = [0b, 78b, 78b, 78b, 78b, 78b,  0b, 67b,  0b,  0b]
  dbok     = [0,    1,   1,   1,   1,   1,   0,   1,   0,  0]
  dblength = [1,    1,   1,   1,   1,   1,   1,   1,   1,  1]
  dbdec    = [0,    0,   0,   0,   0,   0,   0,   0,   0,  0]
  dbfmt =    ['','(A1)','(I1)','(I1)','(D14.2)','(D14.2)','','(A1)', '', '']

  nth_field = n_fields -1

  idl_field = TAG_NAMES(ARRAY)  ; IDL   Field Names

; ====================>
; The names of the dBASE fields will be the first 10 characters from the IDL Tags
; (dBASE permits names up to 10 characters)
  db_field  = STRMID(idl_field,0,10)   ; dBASE Field Names (Variables)

; ====================>
; Now check for redundant db_field names, and add a unique suffix if necessary
; (dBASE does not allow two fields to have same name, and the truncation to 10 characters
; performed above may have created redundant db_field names)
  trim = 0
  WHILE N_ELEMENTS(UNIQ(db_field(SORT(db_field)))) NE N_ELEMENTS(db_field)  DO BEGIN
    trim = trim+1
    word_end = MAX(STRLEN(db_field))-TRIM -1
    FOR _field = 0, N_ELEMENTS(db_field)-1 DO BEGIN
      redundant = WHERE(db_field EQ db_field(_field),COUNT)
      IF COUNT GT 1 THEN  BEGIN
       db_field(redundant) =   STRMID(db_field(redundant),0,word_end) + STRTRIM(STRING(INDGEN(N_ELEMENTS(redundant))+1),2)
      ENDIF
    ENDFOR
  ENDWHILE

  db_type   = STRARR(n_fields)
  idl_code  = INTARR(n_fields)
  db_width  = REPLICATE(1,n_fields)
  db_dec    = REPLICATE(0,n_fields)
  db_ok     = REPLICATE(1,n_fields)
  db_codes  = REPLICATE(78b,n_fields)
  db_fmt    = REPLICATE('',n_fields)

; dBase Data Types
; Type Code  Data Type
;     66b    Binary
;     67b    Character
;     68b    Date
;     70b    Float
;     71b    Ole
;     76b    Logical
;     77b    Memo
;     78b    Numeric
;

; ====================>
; Create a string array to hold translation_table information
  translation_table = STRARR(n_fields + 15) ; Extra lines are for translation table heading

; ====================>
; Determine size (and idl variable type) for each of the tags in ARRAY
  FOR _field = 0, (nth_field) DO BEGIN
    sz = SIZE(ARRAY[0].(_field))
    dimensions = sz[0]
    s = sz[1]
    IF dimensions NE 0 THEN s = sz(2)  ; If the type is not scalar
    idl_code(_field)  = s

    db_type(_field)   = dbtypes(s)
    db_codes(_field)  = dbcodes(s)
    db_ok(_field)     = dbok(s)

    db_width(_field) = dblength(s)
    db_dec(_field)    = dbdec(s)
    db_fmt(_field)    = dbfmt(s)

    IF s  EQ  1  THEN BEGIN                    ; BYTE
      ok = WHERE(ARRAY(*).(_field) GT -1, COUNT) ;NE idlmissing(0).(s), count)
      IF count GE 1 THEN BEGIN
        max_value = MAX(ARRAY(ok).(_field))
        min_value = MIN(array(ok).(_field))
        db_width(_field)=STRLEN(STRTRIM(STRING(max_value,FORMAT='(I12)'),2)) > $
                          STRLEN(STRTRIM(STRING(min_value,FORMAT='(I12)'),2)) > 1 ; At least 1
        db_fmt(_field) = '(I' +  STRTRIM(db_width(_field),2) + ')'
       ENDIF
    ENDIF  ;IF s  EQ 1 THEN BEGIN

    IF s  EQ  2 OR s EQ 3 THEN BEGIN                    ; INTEGER OR LONG
      ok = WHERE(ARRAY(*).(_field) NE idlmissing[0].(s), count)
      IF count GE 1 THEN BEGIN
        max_value = MAX(ARRAY(ok).(_field))
        min_value = MIN(array(ok).(_field))
        db_width(_field)=STRLEN(STRTRIM(STRING(max_value,FORMAT='(I12)'),2)) > $
                          STRLEN(STRTRIM(STRING(min_value,FORMAT='(I12)'),2)) > 1 ; At least 1
        db_fmt(_field) = '(I' +  STRTRIM(db_width(_field),2) + ')'
       ENDIF
    ENDIF  ;IF s  EQ  2 OR s EQ 3 THEN BEGIN

    IF s  EQ 4 or s EQ 5 THEN BEGIN           ; FLOAT AND DOUBLE
      ok = WHERE(ARRAY(*).(_field) NE idlmissing[0].(s), count)
      IF count GE 1 THEN BEGIN
        max_value   = MAX(ARRAY(ok).(_field))
        min_value   = MIN(array(ok).(_field))
        strnum_min  = STRTRIM(STRING(min_value,FORMAT='(D36.0)'),2)
        strnum_max  = STRTRIM(STRING(max_value,FORMAT='(D36.0)'),2)
        txt_min     = STR_SEP(strnum_min,'.')
        txt_max     = STR_SEP(strnum_max,'.')
        n_digits    = STRLEN(txt_min[0]) > STRLEN(txt_max[0]) > 1

        db_width(_field) = 14
        db_dec(_field)    = (13L - n_digits)
        db_fmt(_field)    = '(D14.' + STRTRIM(db_dec(_field),2) + ')'

        IF n_digits GT 12 THEN BEGIN            ; TOO LARGE, TURN INTO A STRING
          db_width(_field) = n_digits + 2
          db_dec(_field) = 1
          db_fmt(_field) = '(D' + STRTRIM(db_width(_field),2) + '.1)'
          db_type(_field)   = dbtypes(7)         ; Change type to string
          db_codes(_field)  = dbcodes(7)         ; Change code to string
          db_ok(_field)     = dbok(7)            ; Change ok to string
        ENDIF ;IF n_digits GT 12 THEN BEGIN
      ENDIF   ;IF count GE 1 THEN BEGIN
    ENDIF     ;IF s  EQ 4 or s EQ 5 THEN BEGIN

    IF s EQ 7 THEN BEGIN                      ; STRING
      db_width(_field) = MAX(STRLEN(ARRAY(*).(_field))) > 1
      db_fmt(_field)    = '(A' + STRTRIM(db_width(_field),2) + ')'
    ENDIF

;   Add to the translation_table for each of the IDL/dBASE data fields
    translation_table(_field+15) = STRING((_field+1),db_field(_field),$
                                 db_type(_field),db_width(_field),$
                                 db_dec(_field),$
                                 'Blank',$
                                 idl_field(_field),$
                                 idl_type(idl_code(_field)),$
                                 STRING(idlmissing.(idl_code(_field))),$
                                 FORMAT = '(i4,1X,a10,a10,i5,i4,a7,a15,a8,a16)')

 ENDFOR   ;FOR _field = 0, (nth_field) DO BEGIN

; ====================>
; Determine number of fields which can be converted from idl to dBase
  ok_convert = WHERE(db_ok EQ 1,n_convert)

  IF n_convert EQ 0 THEN BEGIN
    MESSAGE,'ERROR: Can not convert any of the idl fields to dBASE, see Documentation for write_db'
  ENDIF

; ====================>
; Each dBASE file begins with a 32byte header
; Create variable to store header info for dBASE file
  inbytes = BYTARR(32)
  inbytes[0]=3b  ; First header byte in dbase files is 3b

; ====================>
; Get creation date for dbase file (yr,mon,day)
  txt = SYSTIME()
  inbytes[1]=BYTE(FIX(STRMID(txt,22,2)))              ; yr
  mon = ['','Jan','Feb','Mar','Apr','May','Jun',$
            'Jul','Aug','Sep','Oct','Nov','Dec']
  _mon = WHERE (STRUPCASE(STRMID(txt,4,3)) EQ STRUPCASE(mon))
  inbytes(2) = BYTE(_mon)                             ; mon
  inbytes(3) = BYTE(FIX(STRMID(txt,8,2)))             ; day

; ====================>
; Encode number of records (elements) in array
  inbytes(6) = BYTE(n_records / 65536L)
  inbytes(5) = BYTE((n_records - (inbytes(6)*65536L) )/256L)
  inbytes(4) = BYTE((n_records - (inbytes(6)*65536L) - inbytes(5)*256L) )

; ====================>
; Compute and encode length of header bytes
  header_bytes = n_convert*32L+32L+1L
  inbytes(9) = BYTE(header_bytes/256L)
  inbytes(8) = BYTE(header_bytes - inbytes(9)*256L)
  inbytes(7) = 0b   ;??? I am not sure about inbytes(7)

; ====================>
; Determine record length
; (excluding complex and other untranslatable fields)
  rec_len = TOTAL(LONG(db_width(ok_convert))) + 1L  ; Each record begins with a 32b
  inbytes(11) = BYTE(rec_len / 256L)
  inbytes(10) = BYTE(rec_len - inbytes(11)*256L)

; ====================>
; Compute file size
  file_size = header_bytes + (n_records * rec_len) +1L ; Each file ends with a 26b

; ====================>
; Write header in dBase file
  WRITEU,lun,inbytes

; ====================>
; Fill the first part of the translation table now that the dbase file statistics are known
  translation_table[0]= 'TRANSLATION TABLE:   IDL to DBASE'
  translation_table[1]= ' '
  translation_table(2)= 'Information for dBASE file    : ' + STRTRIM(file,2)
  translation_table(3)= 'Date (yy/mm/dd)of last update : ' + STRING(inbytes(1,0),inbytes(2,0),inbytes(3,0))
  translation_table(4)= 'Size of dBASE file in Bytes   : ' + STRING(file_size)
  translation_table(5)= 'Record Length in Bytes        : ' + STRING(rec_len)
  translation_table(6)= 'Number of Fields/Variables    : ' + STRING(n_fields)
  translation_table(7)= 'Number of Records             : ' + STRING(n_records)
  translation_table(8)= ' '
  translation_table(9)= STRING(REPLICATE(61B,80))
  translation_table(10) = ' dBASE file: ' + file + ' made from IDL Structure'
  translation_table(11) = 'Number of Data Records =        ' + STRING(n_records)
  translation_table(12) = ' '
  translation_table(13) ='  DBASE <<<<<<<<<<<<<<<<<<<<<<<<<<< FROM <<<<<< IDL                    '
  translation_table(14) ='Field   DB_Name      Type Width Dec Missing     IDL_Name    Type        Missing  '

; ====================>
; Now write out a 32 byte segement describing each dBASE Field
    FOR _field = 0, (n_convert-1) DO BEGIN
     inbytes = REPLICATE(0B,32)
     good_field = ok_convert(_field)
     inbytes(0:STRLEN(db_field(good_field))-1)= BYTE(db_field(good_field))  ; Name of dBASE field
     inbytes(11)= db_codes(good_field)
     inbytes(16) = BYTE(db_width(good_field)) ; Length of dBASE Field
     inbytes(17) = db_dec(good_field)    ; Number of Decimal Places
     WRITEU,lun,inbytes
   ENDFOR   ; (FOR I = 0, (n_convert-1) DO BEGIN)
; ====================> <<<
; ====================> <<<


;  ====================>
;  Write a 13b to delimit the end of the header bytes
   WRITEU,lun,13b

; ====================>
; For each element of the array structure write each idl variable to dBASE file

  FOR _record = 0L, (n_records -1) DO BEGIN
    WRITEU,lun,32b  ; Each record begins with a 32b
    FOR _field = 0, (n_convert-1) DO BEGIN

      good_field = ok_convert(_field)
      data_type = idl_code(good_field)

;     Write blanks (32b = dBASE missing code) if the IDL datum matches
;     the IDL missing code for the IDL data type

      IF array(_record).(good_field) EQ idlmissing[0].(data_type) THEN $
        WRITEU,lun, REPLICATE(32b,db_width(good_field)) ELSE $
        WRITEU,lun, BYTE(STRING(array(_record).(good_field),FORMAT=db_fmt(good_field)))

    ENDFOR      ; FOR _field = 0, (n_convert-1) DO BEGIN
  ENDFOR        ; FOR _record = 0L, (n_records -1) DO BEGIN

; ====================<<

; ====================>
; Write a 26b at the end of the file and close file
  WRITEU,lun,26b
  CLOSE,lun
  FREE_LUN,lun

; ====================>
; Reformat translation table so each line occupies 80 characters
  translation_table = STRING(translation_table,FORMAT='(A80)')
  IF KEYWORD_SET(QUIET) EQ 0 THEN PRINT, translation_table

; ====================>
; Place contents of string array: translation_table into parameter translation
  IF N_PARAMS(translation) NE 0 THEN translation = translation_table

; ====================>
; Print out JOB message if user did not supply keyword QUIET
  IF KEYWORD_SET(QUIET) EQ 0 THEN BEGIN
    PRINT, ' '
    PRINT, ' '
    PRINT, ' write_db is Finished Writing File: ',file
    PRINT, STRCOMPRESS(STRING(n_records)),  ' Data Records are Stored in An Array Structure'
    PRINT, ' Whose Name You Provided in Parameter ''array'' '
    IF N_PARAMS() EQ 3 THEN BEGIN
      PRINT, ' '
      PRINT, ' A Description of dBASE and IDL Fields'
      PRINT, ' is Stored in a String Array '
      PRINT, ' Whose Name You Provided in Parameter ''translation'' '
    ENDIF
  ENDIF

  END
; ====================> END OF PROGRAM








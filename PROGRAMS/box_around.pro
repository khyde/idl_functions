; $ID:	BOX_AROUND.PRO,	2020-07-29-14,	USER-KJWH	$
;############################################################
	FUNCTION BOX_AROUND,IMG, PIXEL, SUBS=SUBS, AROUND=AROUND

;+
; NAME:
;		AROUND
;
; PURPOSE:
;		THIS FUNCTION FINDS THE VALUES AND SUBSCRIPTS OF THE PIXELS AROUND AND A GIVEN PIXEL 
;
; CATEGORY:
;		
;
; CALLING SEQUENCE:
;   DATA = BOX_AROUND(IMAGE,PIXEL,SUBS=SUBS)
;   
; ROUTINE_NAME: BOX_AROUND
;
; INPUTS:
;		IMAGE:  THE DATA ARRAY TO FIND THE SUBSCRIPTS IN
;		PIXEL:	THE SUBSCRIPT OF THE INPUT PIXEL
;		        IF PIXEL IS AN ARRAY OF 2 THEN PIXEL REPRESENTS [XP,YP]
;
; OPTIONAL INPUTS:
;		SUBS:	THE SUBSCRIPTS OF THE OUTPUT PIXEL
;		AROUND: ALLOWS PIXELS IN A BOX AROUND THE CENTER PIXEL TO BE EXTRACTED FROM THE INPUT IMAGE ARRAY
;           AROUND = 0 JUST GET THE VALUE FROM THE IMAGE ARRAY THAT IS CLOSEST TO THE INPUT LON,LAT
;           AROUND = 1 GET 9 VALUES IN A 3X3 BOX AROUND THE CENTRAL PIXEL CLOSEST TO THE INPUT LON, LAT
;           AROUND = 2 GET 25 VALUES IN A 5X5 BOX AROUND THE CENTRAL PIXEL CLOSEST TO THE INPUT LON, LAT
;
;
; OUTPUTS:
;		THIS FUNCTION RETURNS THE 3X3 VALUES SURROUNDING THE INPUT PIXEL
;
;	NOTES:
;
;
; MODIFICATION HISTORY:
;			WRITTEN NOV 5, 2010 BY K.J.W.HYDE, 28 TARZWELL DRIVE, NMFS, NOAA 02882 (KIMBERLY.HYDE@NOAA.GOV)
;			JUN,1,2013,JOR MADE PIXEL BE XP,YP [IF NOT A SUBSCRIPT], 
;			               FORMATTING,REMOVED ERROR-NOT BEING USED, REMOVED COMMENTED STUFF
;			JUN 11,2014,JOR FIXED LOGIC BUG WHEN AROUND = 0
;			               CHANGED TO: IF N_ELEMENTS(AROUND) EQ 1 THEN BEGIN
;			               ADDED IF NONE(AROUND) THEN AROUND = 0
;     APR 18,2015,JOR USING TWO2ONE TO CONVERT THE 2-D LOCATIONS INTO 1-D SUBSCRIPTS
;     
;-
;***************************
ROUTINE_NAME = 'BOX_AROUND'
;***************************
; 
 IF NONE(AROUND) THEN AROUND = 0
  S   = SIZE(IMG)
  PX  = S[1]
  PY  = S(2)
  TYPE = IDLTYPE(IMG,/CODE)
; ===> GET THE LAST SUBSCRIPTS FOR THE IMAGE WIDTH AND HEIGHT
  LAST_PX = PX-1L
  LAST_PY = PY-1L

; ====> CALCULATE THE BOX SIZE
  IF N_ELEMENTS(AROUND) EQ 1 THEN BEGIN
  
  IF AROUND[0] GE 1 AND AROUND[0] LT PX/2 THEN BOX = AROUND ELSE BOX = 0
  
 ENDIF;IF KEYWORD_SET(AROUND) THEN BEGIN
; ===> DETERMINE NUMBER OF ELEMENTS IN BOX EXTRACTED FROM THE IMAGE
  WIDTH = (BOX*2+1)
  SQUARE = WIDTH^2
  
IF N_ELEMENTS(PIXEL) EQ 2 THEN BEGIN
  INX = PIXEL[0]
  INY = PIXEL[1]
  VALUE = REPLICATE(MISSINGS(IMG),1,SQUARE)
  IF TYPE EQ 1 THEN VALUE = REPLICATE(MISSINGS(0),1,SQUARE) ; MAKE BYTES INTEGERS
ENDIF ELSE BEGIN
  ONE2TWO,PIXEL,IMG,INX,INY  
 ; ===>CREATE AN OUTPUT ARRAY AND SET ALL OUTPUT VALUES TO MISSING OF TYPE IMAGE
  VALUE = REPLICATE(MISSINGS(IMG),N_ELEMENTS(PIXEL),SQUARE)
  IF TYPE EQ 1 THEN VALUE = REPLICATE(MISSINGS(0),N_ELEMENTS(PIXEL),SQUARE) ; MAKE BYTES INTEGERS
ENDELSE;IF N_ELEMENTS(PIXEL) EQ 2 THEN BEGIN

XX= -1L
YY= -1L

; ===>DEFINE BOXL,BOXR,BOXB,BOXT IMAGE SUBSCRIPTS
BOXL =  - BOX
BOXR =  + BOX
BOXB =   - BOX
BOXT =   + BOX
COUNTER = -1L ; A COUNTER FOR THE EXTRACTED BOX

FOR _Y = BOXB,BOXT DO BEGIN
  FOR _X = BOXL,BOXR DO BEGIN
    XX = [XX,_X]
    YY = [YY,_Y]
  ENDFOR;FOR _X = BOXL,BOXR DO BEGIN
ENDFOR;FOR _Y = BOXB,BOXT DO BEGIN

XX=XX(1:*)
YY=YY(1:*)
  
XP = TRANSPOSE(REPLICATE(INX,SQUARE) + XX)
YP = TRANSPOSE(REPLICATE(INY,SQUARE) + YY)
  
; ===> CREATE SUBS TO HOLD SUBSCRIPTS
SUBS = LONG(XX) & SUBS(*) = -1L

;===>  TWO2ONE
OK=WHERE(XP GE 0 AND XP LE LAST_PX AND YP GE 0 AND YP LE LAST_PY,COUNT)
IF COUNT GE 1 THEN BEGIN
  VALUE[OK] = IMG(XP[OK],YP[OK])
  ;   ===> CONVERT THE 2-D LOCATIONS INTO 1-D SUBSCRIPTS
  INDEX = TWO2ONE(XP, YP, IMG)
  SUBS[OK]  = INDEX[OK]
ENDIF

; ===> CLEAN UP ANY X,Y'S THAT ARE OUTSIDE THE MAP AREA
  BAD=WHERE(INX LT 0 OR INX GT LAST_PX OR INY LT 0 OR INY GT LAST_PY,COUNT_BAD)
  IF COUNT_BAD GE 1 THEN BEGIN
    INX(BAD) = -1L
    INY(BAD) = -1L
  ENDIF
  
  RETURN, VALUE

END; #####################  END OF ROUTINE ################################

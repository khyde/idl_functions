; $ID:	MAPS_REMAP_DEMO.PRO,	2021-04-15-17,	USER-KJWH	$
;##############################################################################################
  PRO MAPS_REMAP_DEMO,  GLOBAL_ARRAY, MAP=MAP, PX_OUT = PX_OUT, PY_OUT = PY_OUT, ERROR=error
;+
; NAME:
;       MAPS_REMAP_DEMO
;
; PURPOSE:
;       DEMO for MAPS_REMAP
;
; MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, OCTOBER 18, 2005
;       MODIFIED 
;         FEB 23, 2015 - KJWH: ADDED EXAMPLES OF MAPPING ISSUES 
;         SEP 24, 2015 - KJWH: Changed name to MAPS_REMAP_DEMO for the updated MAPS_REMAP
;                              Added several example blocks for mapping different types of data
;         OCT 28, 2015 - KJWH: Updated the DO_MAP_L2, DO_TOPO_ERROR, and DO_L2_FLAGS blocks.  There are still several examples that need to be updated or added.
;         OCT 29, 2015 - KJWH: Added the AVHRR_2L3B example
;         OCT 30, 2015 - KJWH: Changed the default sample file directory to !S.FILES
;         DEC 02, 2015 - JEOR: Removed X=X,Y=Y from call to MAPS_LONLAT_GRID
;         MAR 17, 2016 - KJWH: Removed unused/old examples
;                              Updated DO_AVHRR, DO_MUR and DO_MAP_L2 examples
;         MAR 21, 2016 - JEOR: SKIP OVER UNTESTED DO_STEPS TO END OF DEMO [GOTO,DONE]
;                              REVISED DO_MAP_2MAP,UPDATED STEP DO_MAKE_GEQ
;                              DIR_OUT = !S.DEMO + ROUTINE_NAME + SL [TO AVOID CONFUSION]
;                              REMOVED KEY REFRESH TO CALLS TO MAPS_REMAP
;                              ADDED READ_MATFILE.PRO [WAS MISSING FROM PROGRAMS-CAUSED MAPS_REMAP TO STOP-NENA]
;                              REPLACED MAP_REMAP WITH MAPS_REMAP THROUGHOUT
;         MAR 30, 2016 - KJWH: Added DO_AVHRR_2GEQ block
;                              Added DO_HIRES_2LOWRES block  
;         APR 05, 2016 - JEOR: DO_HIRES_2LOWRES BLOCK:SST = FINDGEN(NOF(SST))
;         APR 28, 2016 - JEOR: FIXED XOUT,YOUT FOR GRIDDATA IN STEP DO_GRIDDATA_CHECK 
;                              ADDED ARR_TYPE = '1111' VS '1234'
;         MAY 02, 2016 - KJWH: Added MUR_SUBSET step
;         JUN 22, 2016 - KJWH: Updated DO_GRIDDATA_CHECK step
;                              Added DO_L2_2MAP_ERROR
;         JUN 28, 2016 - KJWH: Added DO_L3B_2MAP step   
;         JUN 30, 2016 - KJWH: Updated the DO_L3B_2MAP and changed the input file.   
;                              Added titles and polygons to highlight the ERROR areas to the L2_2MAP_ERROR images and place holder text for the GEQ_PART map            
;         JUL 15, 2016 - KJWH: Updated the DO_L3B_2MAP block
;         JUL 22, 2016 - KJWH: Removed the OLD (MAP_REMAP) method from the DO_L3B_2MAP block
;                              Added the DO_L3B_2GL block
;         AUG 19, 2016 - KJWH: Changed !S.MASTER to !S.MAPINFO  
;         AUG 23, 2016 - KJWH: Updated the !S.MAPINFO file names    
;         OCT 03, 2016 - KJWH: Added L3B Mean step               
;
;##############################################################################################
;-
;*******************************
ROUTINE_NAME = 'MAPS_REMAP_DEMO'
;*******************************

; ===> DEFAULTS
  SL = PATH_SEP()
  DIR = !S.FILES & DIR_TEST,DIR
  DIR_OUT = !S.DEMO + ROUTINE_NAME + SL

; ===> GEQ_SAV IS USED IN SEVERAL STEPS [ SO DEFINE HERE, ONCE]
  GEQ_SAV=DIR_OUT+ROUTINE_NAME+'-GEQ'+'-PXY_'+STRTRIM(4096,2)+'_'+STRTRIM(2048,2)+'.SAV'


  DO_MAKE_GEQ         = '' ; Makes a large GEQ image to use in other demo steps 
  DO_AVHRR            = '' ; Map the AVHRR (8640x4320) files to the standard L3B4 and L3B9 maps
  DO_AVHRR_2GEQ       = '' ; Map the AVHRR file to the standard GEQ
  DO_MUR              = '' ; Map the MUR () files to the standard L3B4 and L3B9 maps
  DO_AVHRR_SUBSET     = '' ; Subset the AVHRR files based on standard maps or input coordinates
  DO_MUR_SUBSET       = '' ; Subset the MUR files based on standard maps or input coordinates
  DO_L2_2MAP_ERROR    = '' ; Map/Subset the L2 files into GEQ_PART maps 
  DO_L3B_2MAP         = '' ; Map the 1km L3B1 files
  DO_L3B_STAT         = 'Y' ; Map a L3B stat file (with no BINS in the file)
  DO_L3B_2GL          = '' ; Map the L3B files to the new GL (GLOBAL) map projections ***** TO BE DEVELOPED *****
  DO_GRIDDATA_CHECK   = '' ; Check to see how GRIDDATA changes the input data
  DO_HIRES_2LOWRES    = '' ; MAP A HIGH RESOLUTION IMAGE (I.E. 1 KM MUR) TO A LOWER RESOLUTION MAP (I.E. EC)
  DO_MAP_L2           = '' ; MAP L2 FILES FROM SEADAS TO STANDARD MAP AND OUTPUT THE MAPPING INFORMATION IN A STRUCTURE FOR FUTURE USE
  DO_MAP_2MAP         = '' ; Remapping images that have previously been mapped to one of our MAPS_SET projections (e.g. NEC to GOM or GEQ to NEC )
  DO_L2_FLAGS         = '' ; Map the L2 flags from SeaDAS to standard map
  
  DO_GEQ_2MAP         = '' ; Create maps from GEQ
  DO_NENA_2_MAP       = '' ; Map NENA data to a map
  ;DO_L3B9_2MAP        = '' ; Map L3B9 (9km binned data) to a MAPS_SET projection
;  DO_MAP_WITHIN_A_MAP = '' ;
;  DO_L2_2NENA         = '' ; Map image with full arrays of LON and LAT coordinates to the NENA model grid
;  DO_MAP_2NENA        = '' ; Remap previously mapped image to the NENA model grid
	
	
; *****************************
  IF KEY(DO_MAKE_GEQ) THEN BEGIN
; *****************************
    SWITCHES,DO_MAKE_GEQ,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF STOPP THEN STOP
    MESSAGE,/INFORM,'THIS STEP MAKES A LARGE GEQ IMAGE TO USE IN OTHER DEMO STEPS'
    MAPP = 'GEQ'
    IF FILE_TEST(GEQ_SAV) EQ 0 OR OVERWRITE EQ 1 THEN BEGIN  
      MAPS_SET,MAPP,BKG_COLOR = 255  
      MAP_CONTINENTS,COLOR=34,/HIRES,/FILL
      MAP_CONTINENTS,COLOR=21,/HIRES,/COAST
      IMG=TVRD()
      ZWIN
      SAVE,FILENAME=GEQ_SAV,IMG,/COMPRESS,/VERBOSE
    ENDIF;  IF FILE_TEST(GEQ_SAV) EQ 0 OR OVERWRITE EQ 1 THEN BEGIN  

  ENDIF;IF KEY(DO_MAKE_GEQ) THEN BEGIN


; ***************************
  IF KEY(DO_AVHRR) THEN BEGIN
; ***************************
    SWITCH_NAME = 'DO_AVHRR'
    SWITCHES,DO_AVHRR,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME
    IF STOPP THEN STOP  		
  	F = FILE_SEARCH(!S.FILES + '*AVHRR*night*.nc')    
    SD = READ_NC(F[0],PRODS=['SEA_SURFACE_TEMPERATURE','PATHFINDER_QUALITY_LEVEL','L2P_FLAGS'])
    SST    = SD.SD.SEA_SURFACE_TEMPERATURE
    MASK   = SD.SD.PATHFINDER_QUALITY_LEVEL
    FLAGS  = SD.SD.L2P_FLAGS
    
    QUALITY_LEVEL = 3
    SIMG = SST.IMAGE
    MIMG = MASK.IMAGE
    FIMG = FLAGS.IMAGE
    
    OK_MISSINGS = WHERE(SIMG GT SST.VALID_MAX OR SIMG LT SST.VALID_MIN OR SIMG EQ MISSINGS(SIMG) OR SIMG EQ SST._FILLVALUE[0],COMPLEMENT=COMPLEMENT); Find any MISSING values or temperatures that are out of range
    SIMG = SIMG * FLOAT(SST.SCALE_FACTOR[0])
    SIMG(OK_MISSINGS) = MISSINGS(0.0)
    
    OK_MASK = WHERE(MIMG LT 0 OR MIMG GT 7, COUNT_MASK)               ; Valid quality values are from 0 (worst) to 7 (best)
    IF COUNT_MASK GE 1 THEN MIMG(OK_MASK) = 0                         ; Change any 255 values to 0
    
    OK_LAND = WHERE(BITS(FIMG,1) EQ 1, COUNT_LAND)                    ; Find the land pixels (BIT 1)
    IF COUNT_LAND GE 1 THEN MIMG(OK_LAND) = -1
    
    OK_QUAL = WHERE(MIMG LE QUALITY_LEVEL,COUNT_QUAL)                 ; Find the mask values that are less than or equal to the QUALITY_LEVEL
    SIMG(OK_QUAL) = MISSINGS(0.0) 

    L3B9 = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='L3B9')           ; Make a L3B9 image from the AVHRR grid
    NEC  = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='NEC',INIT=1) 
    EC   = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='EC')         
    IMGR, NEC, PROD='SST', MAP='NEC'
    IMGR, EC,  PROD='SST', MAP='EC'
  
	ENDIF ; DO_AVHRR
	
; ***************************
	IF KEY(DO_AVHRR_2GEQ) THEN BEGIN
; ***************************
	  SWITCH_NAME = 'DO_AVHRR_2GEQ'
	  SWITCHES,DO_AVHRR_2GEQ,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN , SWITCH_NAME
	  IF STOPP THEN STOP
	  F = FILE_SEARCH(!S.FILES + '*AVHRR*night*.nc')
	  SD = READ_NC(F[0],PRODS=['SEA_SURFACE_TEMPERATURE','PATHFINDER_QUALITY_LEVEL','L2P_FLAGS'])
	  SST    = SD.SD.SEA_SURFACE_TEMPERATURE
	  MASK   = SD.SD.PATHFINDER_QUALITY_LEVEL
	  FLAGS  = SD.SD.L2P_FLAGS

	  QUALITY_LEVEL = 3
	  SIMG = SST.IMAGE
	  MIMG = MASK.IMAGE
	  FIMG = FLAGS.IMAGE

	  OK_MISSINGS = WHERE(SIMG GT SST.VALID_MAX OR SIMG LT SST.VALID_MIN OR SIMG EQ MISSINGS(SIMG) OR SIMG EQ SST._FILLVALUE[0],COMPLEMENT=COMPLEMENT); Find any MISSING values or temperatures that are out of range
	  SIMG = SIMG * FLOAT(SST.SCALE_FACTOR[0])
	  SIMG(OK_MISSINGS) = MISSINGS(0.0)

	  OK_MASK = WHERE(MIMG LT 0 OR MIMG GT 7, COUNT_MASK)               ; Valid quality values are from 0 (worst) to 7 (best)
	  IF COUNT_MASK GE 1 THEN MIMG(OK_MASK) = 0                         ; Change any 255 values to 0

	  OK_LAND = WHERE(BITS(FIMG,1) EQ 1, COUNT_LAND)                    ; Find the land pixels (BIT 1)
	  IF COUNT_LAND GE 1 THEN MIMG(OK_LAND) = -1

	  OK_QUAL = WHERE(MIMG LE QUALITY_LEVEL,COUNT_QUAL)                 ; Find the mask values that are less than or equal to the QUALITY_LEVEL
	  SIMG(OK_QUAL) = MISSINGS(0.0)


    ; ???? HOW SHOULD WE CREATE A GEQ MAP FROM AN EQUIDSTANCE MAP (I.E. AVHRR OR MUR) WITH KNOWN LON/LATS????
    ;      USING MAPS_LONLAT_GRID IS VERRRRRRRRYYYYYYYY SLOW



	  GEQ  = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='GEQ') ; & IMGR, GEQ, PROD='SST', MAP='GEQ'         ; Remap to GEQ and plot
	  IMGR, NEC, PROD='SST', MAP='GEQ'
	  

	ENDIF ; DO_AVHRR_2GEQ
	
; ********************************
	IF KEY(DO_MUR) THEN BEGIN
; ********************************
	  IF GET_COMPUTER() EQ 'OOLONG' THEN GOTO, SKIP_DO_MUR ; ===> SKIP THIS STEP BECAUSE IT CRASHES JAY'S COMPUTER
	  SWITCH_NAME = 'DO_MUR'
	  SWITCHES,DO_MUR,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN , SWITCH_NAME
	  IF STOPP THEN STOP
	
	  DIR = !S.DEMO + ROUTINE_NAME + SL
	  F = FILE_SEARCH(!S.FILES + '*MUR*.nc')
	  SD = READ_NC(F[0],PRODS=['ANALYSED_SST'])	  
	  SST  = SD.SD.ANALYSED_SST
	  SIMG = SST.IMAGE

	  OK_MISSINGS = WHERE(SIMG GT SST.VALID_MAX OR SIMG LT SST.VALID_MIN OR SIMG EQ MISSINGS(SIMG) OR SIMG EQ SST._FILLVALUE[0],COMPLEMENT=COMPLEMENT); Find any MISSING values or temperatures that are out of range
	  SIMG = SIMG * FLOAT(SST.SCALE_FACTOR[0]) + FLOAT(SST.ADD_OFFSET) - 273.15
	  SIMG(OK_MISSINGS) = MISSINGS(0.0)
	  SIMG(WHERE(SIMG GT 45)) = MISSINGS(0.0)
    
    ; L3B9 = MAPS_MUR_2BIN(SIMG, 'L3B9')                            ; Get the subscripts to convert grids to L3B9(4) bins
    L3B9 = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='L3B9')           ; Make a L3B9 image from the MUR grid

	  TIC 
	  NEC  = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='NEC',INIT=1)
	  EC   = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='EC')
	  ;  VERY SLOW!!!!!  GEQ  = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='GEQ') ; & IMGR, GEQ, PROD='SST', MAP='GEQ'         ; Remap to GEQ and plot
	  TOC

	  TIC
	  NEC  = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='NEC')
	  EC   = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='EC')
	  TOC

	  IMGR, NEC, PROD='SST', MAP='NEC'
	  IMGR, EC,  PROD='SST', MAP='EC'

STOP
    SKIP_DO_MUR:
	ENDIF ; DO_MUR

; ********************************
	IF KEY(DO_AVHRR_SUBSET) THEN BEGIN
; ********************************

	  SWITCH_NAME = 'DO_AVHRR_SUBSET'
	  SWITCHES,DO_AVHRR_SUBSET,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN , SWITCH_NAME
	  IF STOPP THEN STOP

	  DIR = !S.DEMO + ROUTINE_NAME + SL

	  LIMG = IDL_RESTORE(!S.MAPINFO + 'AVHRR-PXY_8640_4320-LAT.SAV')
	  LLAT = MAPS_REMAP(LIMG, MAP_IN='AVHRR', MAP_OUT='SUBSET', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, MAP_SUBSET=1, INIT=1)
	  HELP, LLAT
	  PMM, LLAT

	  LIMG = IDL_RESTORE(!S.MAPINFO + 'AVHRR-PXY_8640_4320-LON.SAV')
	  LLON = MAPS_REMAP(LIMG, MAP_IN='AVHRR', MAP_OUT='SUBSET', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, MAP_SUBSET=1, INIT=1)
	  HELP, LLON
	  PMM, LLON

	  SIMG = IDL_RESTORE(!S.FILES + 'AVHRR_SST_EXAMPLE.SAV')
	  LL   = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='SUBSET', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, INIT=1)
	  IMGR, LL, PROD='SST'

	  NEC  = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='NEC',MAP_SUBSET=1,INIT=1)
	  IMGR, NEC, PROD='SST'

	  EC   = MAPS_REMAP(SIMG, MAP_IN='AVHRR', MAP_OUT='EC', MAP_SUBSET=1)
	  IMGR, EC, PROD='SST'

	  STOP
	ENDIF ; DO_AVHRR_SUBSET

; ********************************
	IF KEY(DO_MUR_SUBSET) THEN BEGIN
; ********************************

	  SWITCH_NAME = 'DO_MUR_SUBSET'
	  SWITCHES,DO_MUR_SUBSET,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN , SWITCH_NAME
	  IF STOPP THEN STOP

	  DIR = !S.DEMO + ROUTINE_NAME + SL
	 
;	  LIMG = IDL_RESTORE(!S.MAPINFO + 'MUR-PXY_36000_17999-LAT.SAV') 
;	  LLAT = MAPS_REMAP(LIMG, MAP_IN='MUR', MAP_OUT='SUBSET', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, MAP_SUBSET=1, INIT=1)
;	  HELP, LLAT
;	  PMM, LLAT
;	  
;	  LIMG = IDL_RESTORE(!S.MAPINFO + 'MUR-PXY_36000_17999-LON.SAV')
;	  LLON = MAPS_REMAP(LIMG, MAP_IN='MUR', MAP_OUT='SUBSET', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, MAP_SUBSET=1, INIT=1)
;	  HELP, LLON
;	  PMM, LLON
	  
	  SIMG = IDL_RESTORE(!S.FILES + 'MUR_SST_EXAMPLE.SAV')
	  LL   = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='SUBSET', LONMIN=-83, LONMAX=-50, LATMIN=24, LATMAX=47, INIT=1)
	  IMGR, LL, PROD='SST',/no_close
	  
	  NEC  = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='NEC',MAP_SUBSET=1,INIT=1)
	  IMGR, NEC, PROD='SST'
	  
	  EC   = MAPS_REMAP(SIMG, MAP_IN='MUR', MAP_OUT='EC', MAP_SUBSET=1)
	  IMGR, EC, PROD='SST'
	  
    STOP
  ENDIF ; DO_MUR_SUBSET
  
; ********************************
  IF KEY(DO_L2_2MAP_ERROR) THEN BEGIN
; ********************************

    SWITCH_NAME = 'DO_L2_2MAP_ERROR'
    SWITCHES,DO_L2_2MAP_ERROR,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME
    IF STOPP THEN STOP

    DIR = !S.DEMO + ROUTINE_NAME + SL
    SAVEFILE = DIR + SWITCH_NAME + '.PNG'

    FILE = FLS(!S.FILES + 'A2006089175500.L2_LAC_SUB_OC')
    SD = READ_NC(FILE,PROD=['longitude','latitude','chlor_a','l2_flags'])
    LONS   = SD.SD.LONGITUDE.IMAGE
    LATS   = SD.SD.LATITUDE.IMAGE
   
    CHL = SD.SD.CHLOR_A.IMAGE  & OK = WHERE(CHL EQ SD.SD.CHLOR_A._FILLVALUE._DATA[0], COUNT) & IF COUNT GE 1 THEN CHL[OK] = MISSINGS(0.0)
    MASK_FLAG = SD_FLAGS_COMBO(SD.SD.L2_FLAGS.IMAGE,[0,1,2,3,4,5,8,9,12,14,15,16,25])
    OK_MASK = WHERE(MASK_FLAG GT 0, COUNT_MASK)
    IF COUNT_MASK GT 0 THEN CHL(OK_MASK) = MISSINGS(0.0)
    
    LANDMASK = ROTATE(SD_FLAGS_COMBO(SD.SD.L2_FLAGS.IMAGE,1),5)
    LAND  = WHERE(LANDMASK EQ 1)
    
    W = WINDOW(DIMENSIONS=[1024,1024])
    PROD = 'CHLOR_A'
    BARRAY = PRODS_2BYTE(ROTATE(CHL,5),PROD=PROD)
    BARRAY(LAND) = 252
    IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[2,2,1],MARGIN=MARGIN,TITLE='Unmapped Original Data')
    
    NEC  = MAPS_REMAP(CHL, MAP_IN='LONLAT', MAP_OUT='NEC',CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=INIT)
    BARRAY = PRODS_2BYTE(NEC,PROD=PROD)
    BARRAY(LAND) = 252
    IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[2,2,2],MARGIN=MARGIN,TITLE='NEC')
    S = POLYGON([660,960,960,660,660],[860,860,980,980,860],THICK=5,/DEVICE,FILL_BACKGROUND=0)

    EC   = MAPS_REMAP(CHL, MAP_IN='LONLAT', MAP_OUT='EC', CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=INIT)
    BARRAY = PRODS_2BYTE(EC,PROD=PROD)
    BARRAY(LAND) = 252
    IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[2,2,3],MARGIN=MARGIN,TITLE='EC')
    S = POLYGON([220,380,380,220,220],[400,400,470,470,400],THICK=5,/DEVICE,FILL_BACKGROUND=0)

; Currently not able to remap to a GEQ_PART map
;    GEP = MAPS_REMAP(CHL, MAP_IN='LONLAT', MAP_OUT='GEQ_PART', LONMIN=-80, LONMAX=-64, LATMIN=35, LATMAX=45, CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=1)
;    BARRAY = PRODS_2BYTE(GEP,PROD=PROD)
;    BARRAY(LAND) = 252
;    IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[2,2,4],MARGIN=MARGIN)
     TXT = TEXT(768,256,'PLACE HOLDER !CFOR A GEQ_PART MAP !C !CCURRENTLY UNABLE TO REMAP TO GEQ_PART', ALIGNMENT=0.5,/DEVICE,FONT_STYLE='BOLD')

    IF STOPP THEN STOP
    W.SAVE, SAVEFILE
    W.CLOSE
  ENDIF ; DO_L2_2MAP_ERROR
  
; ********************************
  IF KEY(DO_L3B_2MAP) THEN BEGIN
; ********************************

    SWITCH_NAME = 'DO_L3B_2MAP'
    SWITCHES,DO_L3B_2MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME

    DIR = !S.DEMO + ROUTINE_NAME + SL
    
    INIT = 0
    MAPS_OUT = ['NEC','EC','GEQ']    
    FILES = !S.FILES + ['S2006089.L3B1_DAY_CHL.nc','S2006089.L3B2_DAY_CHL.nc','A2006089.L3B1_DAY_CHL.nc','A2006089.L3B2_DAY_CHL.nc']
    MAPS_IN =          ['L3B1',               'L3B2',                         'L3B1',                    'L3B2']
    TITLES =           ['SeaWiFS 1KM',        'SeaWiFS 2KM',                  'MODIS 1KM',               'MODIS 2KM']

    FOR I=0, N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
      MAP_OUT = MAPS_OUT(I)
      PNGFILE = DIR + SWITCH_NAME + '-' + MAP_OUT + '.PNG'
      MASK = READ_LANDMASK(MAP_OUT,/STRUCT)
      LAND = MASK.LAND
      W = WINDOW(DIMENSIONS=[600,600])
      FOR N=0, N_ELEMENTS(FILES)-1 DO BEGIN
        D = READ_NC(FILES(N),PROD=['chlor_a'])
        CHL = D.SD.CHLOR_A.DATA
        BINS = D.SD.CHLOR_A.BINS             
        NEW = MAPS_REMAP(CHL,BINS=BINS,MAP_IN=MAPS_IN(N),MAP_OUT=MAP_OUT,INIT=INIT)  ; Uses the latest verion MAPS_REMAP (with an S)  
        BARRAY = PRODS_2BYTE(NEW,PROD='CHLOR_A')
        BARRAY(LAND) = 252
        TITLE = TITLES(N) 
        IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[2,2,(N+1)],MARGIN=MARGIN,TITLE=TITLE)  
      ENDFOR
      IF STOPP THEN STOP
      W.SAVE, PNGFILE
      W.CLOSE
    ENDFOR  
  ENDIF ; DO_L3B_2MAP
  
  
; ********************************
  IF KEY(DO_L3B_STAT) THEN BEGIN
; ********************************

    SWITCH_NAME = 'DO_L3B_STAT'
    SWITCHES,DO_L3B_STAT,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME

    DIR = !S.DEMO + ROUTINE_NAME + SL

    INIT = 0
    MAPS_OUT = ['NEC','EC','GEQ']
    FILES = !S.FILES + 'ANNUAL_2002_2016-MODISA-R2015-L3B4-CHLOR_A-OCI-STATS.SAV'

    FOR I=0, N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
      MAP_OUT = MAPS_OUT(I)
      PNGFILE = DIR + SWITCH_NAME + '-' + MAP_OUT + '.PNG'
      D = STRUCT_READ(FILES,STRUCT=STRUCT)
      NEW = MAPS_REMAP(D,BINS=BINS,MAP_IN='L3B4',MAP_OUT=MAP_OUT)  ; Uses the latest verion MAPS_REMAP (with an S)
      IMGR, NEW, PROD='CHLOR_A',MAP=MAP_OUT,PNG=PNGFILE
      IF STOPP THEN STOP
    ENDFOR
  ENDIF ; DO_L3B_2MAP
  
; ********************************
  IF KEY(DO_L3B_2GL) THEN BEGIN
; ********************************

    SWITCH_NAME = 'DO_L3B_2GL'
    SWITCHES,DO_L3B_2GL,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME

    DIR = !S.DEMO + ROUTINE_NAME + SL

    INIT = 0
    MAPS_OUT = ['GL1','GL2','GL4','GL8']
    METHODS = ['OLD','NEW']
    FILES = !S.FILES + ['S2006089.L3b_DAY_OC','S2006089.L3b_DAY_CHL.nc','A2006089.L3b_DAY_OC','A2006089.L3b_DAY_CHL.nc']
    MAPS_IN =          ['L3B1',               'L3B9',                   'L3B1',               'L3B4']
    TITLES =           ['SeaWiFS 1KM',        'SeaWiFS 9KM',            'MODIS 1KM',          'MODIS 4KM']

    FOR I=0, N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
      MAP_OUT = MAPS_OUT(I)
      PNGFILE = DIR + SWITCH_NAME + '-' + MAP_OUT + '.PNG'
      MASK = READ_LANDMASK(MAP_OUT,/STRUCT)
      LAND = MASK.LAND
      W = WINDOW(DIMENSIONS=[1200,600])
      FOR N=0, N_ELEMENTS(FILES)-1 DO BEGIN
        D = READ_NC(FILES(N),PROD=['chlor_a','GLOBAL'])
        CHL = D.SD.CHLOR_A.DATA
        BINS = D.SD.CHLOR_A.BINS
        FOR M=0, N_ELEMENTS(METHODS)-1 DO BEGIN
          IF METHODS(M) EQ 'OLD' THEN BEGIN
            MS = MAPS_SIZE(MAPS_IN(N))
            ARR = REPLICATE(MISSINGS(0.0),[MS.PX, MS.PY])
            ARR(BINS) = CHL
            NEW = MAP_REMAP(ARR,MAP_IN=MAPS_IN(N),MAP_OUT=MAP_OUT,REFRESH=INIT)                        ; Uses an old version of MAP_REMAP (no S)
          ENDIF
          IF METHODS(M) EQ 'NEW' THEN NEW = MAPS_REMAP(CHL,BINS=BINS,MAP_IN=MAPS_IN(N),MAP_OUT=MAP_OUT,INIT=INIT)  ; Uses the latest verion MAPS_REMAP (with an S)
          BARRAY = PRODS_2BYTE(NEW,PROD='CHLOR_A')
          BARRAY(LAND) = 252
          IF METHODS(M) EQ 'NEW' THEN TITLE = TITLES(N) + ' NEW' ELSE TITLE = TITLES(N) + ' ORG'
          IM = IMAGE(BARRAY,RGB_TABLE=CPAL_READ('PAL_BR'),/CURRENT,LAYOUT=[4,2,(N+1)+(M*4)],MARGIN=MARGIN,TITLE=TITLE)
        ENDFOR
      ENDFOR
      IF STOPP THEN STOP
      W.SAVE, PNGFILE
      W.CLOSE
    ENDFOR
  ENDIF ; DO_L3B_2GL
  
  
; ********************************
	IF KEY(DO_GRIDDATA_CHECK) THEN BEGIN
; ********************************

    SWITCH_NAME = 'DO_GRIDDATA_CHECK'
    SWITCHES,DO_GRIDDATA_CHECK,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME
    IF STOPP THEN STOP
    METHODS = ['NEARESTNEIGHBOR','NATURALNEIGHBOR','INVERSEDISTANCE']
    TITLES = ['Nearest Neighbor', 'Natural Neighbor', 'Inverse Distance']
    ARR_TYPE = ['1111','1234']
    
    FOR MTH=0, N_ELEMENTS(METHODS)-1 DO BEGIN
      W = WINDOW(DIMENSIONS=[1450,250*N_ELEMENTS(ARR_TYPE)])
      T = TEXT(725,(250*N_ELEMENTS(ARR_TYPE))/2,TITLES(MTH),ALIGNMENT=0.5,FONT_STYLE='BOLD',FONT_SIZE=16,/DEVICE)
      
      FOR ATH=0, N_ELEMENTS(ARR_TYPE)-1 DO BEGIN
      
; ===> DATA FOR THE INPUT 10 X 8 ARRAY
        IF ARR_TYPE(ATH) EQ '1111' THEN BEGIN      
      	  ARR = FLTARR(10,8)
      	  ARR(0:1,0:1) = 1  & ARR(2:3,0:1) = 2  & ARR(4:5,0:1) = 3  & ARR(6:7,0:1) = 4  & ARR(8:9,0:1) = 5
      	  ARR(0:1,2:3) = 6  & ARR(2:3,2:3) = 7  & ARR(4:5,2:3) = 8  & ARR(6:7,2:3) = 9  & ARR(8:9,2:3) = 10
      	  ARR(0:1,4:5) = 11 & ARR(2:3,4:5) = 12 & ARR(4:5,4:5) = 13 & ARR(6:7,4:5) = 14 & ARR(8:9,4:5) = 15
      	  ARR(0:1,6:7) = 16 & ARR(2:3,6:7) = 17 & ARR(4:5,6:7) = 18 & ARR(6:7,6:7) = 19 & ARR(8:9,6:7) = 20
        ENDIF ; IF ARR_TYPE EQ 'ONE_ONE' THEN BEGIN
        
         IF ARR_TYPE(ATH) EQ '1234' THEN BEGIN
          A = [1,2,1,2,1,2,1,2,1,2] 
          B = [3,4,3,4,3,4,3,4,3,4]
          ARR = [A,B,A,B,A,B,A,B] 
          ARR = REFORM(ARR,10,8)
        ENDIF ; IF ARR_TYPE EQ 'ONE_ONE' THEN BEGIN 
        
        X = FINDGEN(20) & Y = FINDGEN(20)
      	PRINT, ARR
        RGB = 33
        X = 6 & Y = N_ELEMENTS(ARR_TYPE)
        I1 = IMAGE(ARR, TITLE="'"+ARR_TYPE(ATH)+"'"+' INPUT ARRAY', RGB_TABLE=RGB, LAYOUT=[X,Y,ATH*X+1],/CURRENT,MARGIN=0.1)
        XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=11, MINOR=0, COLOR='WHITE', TICKLEN=8, TARGET=I1)
        YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=9,  MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I1)

  ; ===> DUMMY COORDINATES FOR THE INPUT 10 X 8 ARRAY
        LON = ARR & LAT = ARR
        FOR L=0, 9 DO LON(L,*) = L+1
        FOR L=0, 7 DO LAT(*,L) = L+1
        I2 = IMAGE(LON, MIN_VALUE=0, MAX_VALUE=10,TITLE='LONGITUDE',RGB_TABLE=RGB,LAYOUT=[X,Y,ATH*X+2],/CURRENT,MARGIN=0.1)
        XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=11, MINOR=0, COLOR='WHITE', TICKLEN=8,  TARGET=I2)
        YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=9,  MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I2)
        
        I3 = IMAGE(LAT, MIN_VALUE=0, MAX_VALUE=10,TITLE='LATITUDE', RGB_TABLE=RGB,LAYOUT=[X,Y,ATH*6+3],/CURRENT,MARGIN=0.1)
        XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=11, MINOR=0, COLOR='WHITE', TICKLEN=8,  TARGET=I3)
        YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=9,  MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I3)

; ===> DESIRED RESULT FROM GRIDDATA FOR A 5 X 4 ARRAY
        IF ARR_TYPE(ATH) EQ '1111' THEN OUT = FINDGEN(5,4)+1 ELSE OUT = FLTARR(5,4)+MEAN([1,2,3,4])
        I4 = IMAGE(OUT,MIN_VALUE=0,MAX_VALUE=20, TITLE='DESIRED MAPPED ARRAY', RGB_TABLE=RGB, LAYOUT=[X,Y,ATH*X+4],/CURRENT,MARGIN=0.1)
        POS = I4.POSITION
        XPOS = (POS(2)-POS[0])/5.
        YPOS = (POS(3)-POS[1])/4.
        FOR D=0, N_ELEMENTS(OUT)-1 DO BEGIN
          IF D EQ 0 THEN YY = POS[1] + YPOS/2 ELSE IF D MOD 5 EQ 0 THEN YY = YY + YPOS
          IF D MOD 5 EQ 0 THEN XX = POS[0] + XPOS/2 ELSE XX = XX + XPOS
          COLOR = 'WHITE'
          TDIF = TEXT(XX,YY,ROUNDS(OUT(D),1),COLOR=COLOR,FONT_STYLE='BOLD',ALIGNMENT=0.5,VERTICAL_ALIGNMENT=0.5)
        ENDFOR
        XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=6, MINOR=0, COLOR='WHITE', TICKLEN=8,  TARGET=I4)
        YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=5, MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I4)
  
        XOUT = [1.5,3.5,5.5,7.5,9.5]
        YOUT = [1.5,3.5,5.5,7.5]
    	  TRIANGULATE, LON, LAT, TRIANGLES, B, TOLERANCE=SMALLNUM(0.D), CONNECTIVITY=C
    	  G = GRIDDATA(LON, LAT, ARR, METHOD=METHODS(MTH), TRIANGLES=TRIANGLES, /GRID, XOUT=XOUT, YOUT=YOUT)
	  
; ===> OUTPUT FROM GRIDDATA FOR A 5 X 4 ARRAY
    	  I5 = IMAGE(G,MIN_VALUE=0,MAX_VALUE=20, TITLE='ACTUAL MAPPED ARRAY', RGB_TABLE=RGB, LAYOUT=[X,Y,ATH*X+5],/CURRENT,MARGIN=0.1)
    	  POS = I5.POSITION
    	  XPOS = (POS(2)-POS[0])/5.
    	  YPOS = (POS(3)-POS[1])/4.
    	  FOR D=0, N_ELEMENTS(G)-1 DO BEGIN
    	    IF D EQ 0 THEN YY = POS[1] + YPOS/2 ELSE IF D MOD 5 EQ 0 THEN YY = YY + YPOS
    	    IF D MOD 5 EQ 0 THEN XX = POS[0] + XPOS/2 ELSE XX = XX + XPOS
    	    COLOR = 'WHITE'
    	    TDIF = TEXT(XX,YY,ROUNDS(G(D),1),COLOR=COLOR,FONT_STYLE='BOLD',ALIGNMENT=0.5,VERTICAL_ALIGNMENT=0.5)
    	  ENDFOR
    	  XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=6, MINOR=0, COLOR='WHITE', TICKLEN=8,  TARGET=I5)
    	  YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=5, MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I5)
  	  
; ===> DIFFERENCE BETWEEN THE DESIRED AND GRIDDATA OUTPUT FOR A 5 X 4 ARRAY
    	  DIF = OUT - G
    	  I6 = IMAGE(DIF,MIN_VALUE=-2,MAX_VALUE=2, TITLE='DESIRED - ACTUAL (DIF)', RGB_TABLE=RGB, LAYOUT=[X,Y,ATH*X+6],/CURRENT,MARGIN=0.1)
    	  POS = I6.POSITION
    	  XPOS = (POS(2)-POS[0])/5.
    	  YPOS = (POS(3)-POS[1])/4.
    	  FOR D=0, N_ELEMENTS(DIF)-1 DO BEGIN
    	    IF D EQ 0 THEN YY = POS[1] + YPOS/2 ELSE IF D MOD 5 EQ 0 THEN YY = YY + YPOS
    	    IF D MOD 5 EQ 0 THEN XX = POS[0] + XPOS/2 ELSE XX = XX + XPOS
    	    IF DIF(D) LT 0 THEN COLOR = 'WHITE' ELSE COLOR = 'BLACK'
    	    TDIF = TEXT(XX,YY,ROUNDS(DIF(D),1),COLOR=COLOR,FONT_STYLE='BOLD',ALIGNMENT=0.5,VERTICAL_ALIGNMENT=0.5)
    	  ENDFOR
    	  XAX = AXIS('X', LOCATION='BOTTOM', TICKDIR=0, MAJOR=6, MINOR=0, COLOR='WHITE', TICKLEN=8,  TARGET=I6)
    	  YAX = AXIS('Y', LOCATION='LEFT',   TICKDIR=0, MAJOR=5, MINOR=0, COLOR='WHITE', TICKLEN=10, TARGET=I6)  	
  	        
  	  ENDFOR ; FOR A=0, N_ELEMENTS(ARR_TYPE)-1 DO BEGIN
  	  IF STOPP THEN STOP ELSE WAIT, 15
  	  W.CLOSE
  	ENDFOR ; FOR M=0, N_ELEMENTS(METHODS)-1 DO BEGIN

  ENDIF ; DO_GRIDDATA_CHECK

	
;	********************************
	IF KEY(DO_HIRES_2LOWRES) THEN BEGIN
; ********************************
	 
	  SWITCH_NAME = 'DO_HIRES_2LOWRES'
	  SWITCHES,DO_HIRES_2LOWRES,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN , SWITCH_NAME
	  IF STOPP THEN STOP

    DIR = !S.DEMO + ROUTINE_NAME + SL
    F = !S.FILES + 'D_20050225-MUR-1KM-SST-SUBSET.SAV'
    DAT = STRUCT_READ(F,STRUCT=SD)
    
    SST  = SD.DATA
    LON  = SD.LON
    LAT  = SD.LAT
	  
	  MAP_OUT = 'EC'
	  DO_MASK = 0
	  ST, MAPS_INFO(MAP_OUT) 
	  
	  ; EC PIXELS ARE ~2.25 X 2.25, WHICH MEANS THERE SHOULD BE MULTIPLE (4-5) 1KM MUR PIXELS THAT WOULD FIT INSIDE A SINGLE EC PIXEL
	  ; ??? HOW ARE THE MULTIPLE MUR PIXELS COMBINED TO CREATE A SINGLE EC PIXEL???
	  ; ??? WHAT HAPPENS WHEN ONE OR MORE OF INPUT HIGH RES PIXELS ARE MISSING, ARE THEY NOT FACTORED INTO THE MERGE???
	  ; 
	  ;===> TO DETERMINE WHICH PIXELS IN THE INPUT BECOME EC OUTPUT PIXELS 
	  ;     REWRITE THE SST ARRAY WITH FLOATING POINT SUBSCRIPTS
	  SST = FINDGEN(NOF(SST))
	  EC = MAPS_REMAP(SST,MAP_IN = 'LONLAT',MAP_OUT = 'EC',CONTROL_LON=LON, CONTROL_LATS=LAT, DO_MASK=DO_MASK)
	  IMGR,EC,MAP = 'EC',/LOG,CB_FONT_SIZE = 8;,PNGFILE=DIR + 'D_20050225-MUR-1KM-SST-SUBSET.PNG'
	  IF STOPP THEN STOP
	  ;===> KIM MAYBE BOX_AROUND CAN SHED LIGHT ON THE INTERPOLATION OF SST/DATA BY GRIDDATA ?
	  OK = WHERE(FINITE(EC),COUNT) 
	  P,BOX_AROUND(EC,OK(3333),AROUND=2)

  ENDIF ; DO_HIRES_2LOWRES	
	
;************************
  IF KEY(DO_MAP_L2) THEN BEGIN
;************************
    SWITCH_NAME = 'DO_MAP_L2'
    SWITCHES,DO_MAP_L2,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME
    IF STOPP THEN STOP
    
    FILE = FLS(!S.FILES + 'S_2009*MODISA-1KM*L2.nc')
    SD = READ_NC(FILE,PROD=['longitude','latitude','chlor_a','par'])
    CHL = SD.SD.CHLOR_A.IMAGE  & OK = WHERE(CHL EQ SD.SD.CHLOR_A._FILLVALUE._DATA[0], COUNT) & IF COUNT GE 1 THEN CHL[OK] = MISSINGS(0.0)
    PAR = SD.SD.PAR.IMAGE      & OK = WHERE(PAR EQ SD.SD.PAR._FILLVALUE._DATA[0],COUNT,COMPLEMENT=COMP)  & IF COUNT GE 1 THEN PAR[OK] = MISSINGS(0.0) & PAR(COMP) = PAR(COMP)*SD.SD.PAR.SCALE_FACTOR._DATA[0] + SD.SD.PAR.ADD_OFFSET._DATA[0]    
    LONS   = SD.SD.LONGITUDE.IMAGE
    LATS   = SD.SD.LATITUDE.IMAGE
    
    TRIANGLES = []
    X = []
    Y = []
    IMGR, CHL, PROD='CHLOR_A', DELAY=4  ; DISPLAY THE ORIGINAL (UNMAPPED) CHL DATA
    IMGR, PAR, PROD='PAR', DELAY=4      ; DISPLAY THE ORIGINAL (UNMAPPED) PAR DATA
    
    ; REMAP THE CHL DATA
    ;CH = MAPS_LONLAT_GRID(CHL, MAP_OUT='NEC', LON=LONS, LAT=LATS, TRIANGLES=TRIANGLES, /INIT)
  TIC
    CH = MAPS_REMAP(CHL, MAP_IN='LONLAT', MAP_OUT='NEC', CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=1, LONLAT_STRUCT=LLSTRUCT)
  TOC
    
    ; REUSE THE STRUCTURE FROM MAPS_LONLAT_GRID TO MAP CHL
  TIC
    CH = MAPS_REMAP(CHL, MAP_IN='LONLAT', MAP_OUT='NEC', CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=0, LONLAT_STRUCT=LLSTRUCT)
  TOC
    IMGR, CH, MAP='NEC', PROD='CHLOR_A', DELAY=4 ; Display the mapped CHL data

    ; REUSE THE STRUCTURE FROM MAPS_LONLAT_GRID TO MAP PAR
  TIC
    PR = MAPS_REMAP(PAR, MAP_IN='LONLAT', MAP_OUT='NEC', CONTROL_LONS=LONS, CONTROL_LATS=LATS, INIT=0, LONLAT_STRUCT=LLSTRUCT)
  TOC
    IMGR, PR, MAP='NEC', PROD='PAR', DELAY=4 ; Display the mapped CHL data
    
  STOP   
    IF VERBOSE THEN ,SNAME
  ENDIF;IF KEY(DO_L2) THEN BEGIN
  ; ||||||||||||||||||||||||||||||||||

  ;*****************************
  IF KEY(DO_MAP_2MAP) THEN BEGIN
    ;*****************************
    SWITCHES,DO_MAP_2MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    MESSAGE,/INFORM,'THIS STEP MAKES AN NEC TILEMAP FROM THE MASTER SMI TILEMAP'
    MESSAGE,/INFORM,'THEN MAKES AN SMI TILEMAP FROM THE NEC TILEMAP'
    IF STOPP THEN STOP
    DIR_TEST,DIR
    ;===> GET THE SMI TILE_MAP
    IMG_IN = READ_PNG(!S.MASTER +'TOPO_TILE_MAP.PNG',R,G,B)
    IMG_OUT = MAPS_REMAP(IMG_IN,MAP_IN = 'SMI',MAP_OUT = 'NEC')
    PNG = DIR + 'DO_MAP_2MAP-SMI2NEC.PNG'
    WRITE_PNG,PNG,IMG_OUT,R,G,B
    PFILE,PNG
    IF STOPP THEN STOP
    ;===> GET THE SMI TILE_MAP
    IMG_IN = READ_PNG(PNG,R,G,B)
    IMG_OUT = MAPS_REMAP(IMG_IN,MAP_IN = 'NEC',MAP_OUT = 'SMI')
    PNG = DIR + 'DO_MAP_2MAP-NEC2SMI.PNG'
    WRITE_PNG,PNG,IMG_OUT,R,G,B
    PFILE,PNG
  ENDIF;IF KEY(DO_MAP_2MAP) THEN BEGIN
  ;|||||||||||||||||||||||||||||||||||
  
;******************************
IF KEY(DO_GEQ_2MAP) THEN BEGIN
;******************************

    SWITCH_NAME = 'DO_GEQ_2MAP'
    SWITCHES,DO_GEQ_2MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN ,SWITCH_NAME
    IF STOPP THEN STOP
    ;   === READ THE GEQ SAVE
    GEQ = IDL_RESTORE(GEQ_SAV)
    MAP_IN = 'GEQ'
    MAPS_OUT = ['NEC','EC','NENA','MED_SEA','BERING_SEA','NECNFL','NWA','EQ_NATL','GOESWH']

    ;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    FOR _MAP = 0,N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
      MAP_OUT = MAPS_OUT(_MAP)
      M=MAPS_READ(MAP_OUT)
      IF VERBOSE THEN PFILE, MAP_OUT
      PNGFILE = DIR_OUT + ROUTINE_NAME +'-' + SWITCH_NAME + '-' + MAP_IN+'_2_'+MAP_OUT+'-PXY_'+STRTRIM(M.PX,2)+'_'+STRTRIM(M.PY,2)+'.PNG'

      IM= MAPS_REMAP(GEQ,MAP_IN=MAP_IN,MAP_OUT=MAP_OUT)  ; Need to change to MAPS_REMAP
      IF M.INIT EQ 'MAP_SET' THEN BEGIN
      
        MAPS_SET,MAP_OUT
        TV,IM
        MAP_CONTINENTS,/HIRES,/COASTS,COLOR=0
        COPY = TVRD()
        COPY=BYTSCL(COPY,TOP=MAX(COPY))
        ZWIN
      ENDIF ELSE COPY=IM
      PAL_36,R,G,B
      WRITE_PNG,PNGFILE,COPY,R,G,B
      IF VERBOSE THEN PFILE,PNGFILE
    ENDFOR;FOR _MAP = 0,N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
    ;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
  ENDIF ; DO_GEQ_2MAP
  ; |||||
  
  ; *******************************
  IF KEY(DO_NENA_2_MAP)THEN BEGIN
    ; *******************************
    SWITCHES,DO_NENA_2_MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS,R_MAPS=R_MAPS,R_PRODS=R_PRODS,DATERANGE=DATERANGE
    IF STOPP THEN STOP
    MAP_IN='NENA'
    NAME = ['GEQ_NENA']
    MAPS_OUT = ['NWA','GOESWH','NEC','EC']
    NENA = READ_PNG(DIR_OUT+'MAPS_REMAP_DEMO-DO_GEQ_2MAP-GEQ_2_NENA-PXY_386_130.PNG')
    OK=WHERE(NENA EQ 255)
    NENA[OK]=34

    ;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    FOR _MAP = 0,N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
      INIT = 1 

      MAP_OUT = MAPS_OUT(_MAP)
      PNGFILE = DIR_OUT+ROUTINE_NAME+'-'+NAME+'_'+MAP_OUT+'.PNG'
   ;   IF FILE_TEST(PNGFILE) EQ 1  THEN BEGIN
        TIC
        IM= MAPS_REMAP(NENA,MAP_IN=MAP_IN,MAP_OUT=MAP_OUT)
        TOC
        PAL_36,R,G,B
        WRITE_PNG,PNGFILE,IM,R,G,B
        IF VERBOSE THEN PFILE,PNGFILE
  ;    ENDIF
    ENDFOR

  ENDIF;IF KEY(DO_NENA_2_MAP)THEN BEGIN
  ;||||||||||||||||||||||||||||||||||||
 

GOTO,DONE
; EXAMPLES BELOW HERE STILL NEED TO BE UPDATED - KHYDE MAR 17, 2016

 ; *******************************
IF KEY(DO_L3B9_2MAP) THEN BEGIN
  ; *****************************
  SWITCHES,DO_L3B9_2MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS,R_MAPS=R_MAPS,R_PRODS=R_PRODS,DATERANGE=DATERANGE
  IF STOPP THEN STOP
  FILE = DIR+'O1997128.L3b_DAY_CHL.nc'
  L3B9 = READ_NC(FILE)

  MAP_IN='L3B9'
  MAPS_OUT = ['NEC','EC','NENA','MED_SEA','BERING_SEA','NECNFL','NWA','EQ_NATL','GOESWH']

  ;   LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  FOR _MAP = 0,N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
    IF _MAP EQ 0 THEN INIT = 1 ELSE INIT=0
    MAP_OUT = MAPS_OUT(_MAP)
    PNGFILE = DIR_OUT+ROUTINE_NAME+'-'+MAP_IN+'_'+MAP_OUT+'.PNG'
    IF FILE_TEST(PNGFILE) EQ 0 OR DO_L3B9_2MAP GE 2 THEN BEGIN
      timer
      IM= MAPS_REMAP(L3B9,MAP_IN=MAP_IN,MAP_OUT=MAP_OUT)
      timer,/stop
      IF MAP_OUT NE 'NENA' THEN BEGIN
        ZWIN,IM
        MAPS_SET,MAP_OUT
        TV,IM
        MAP_CONTINENTS,/HIRES,/COASTS,COLOR=33
        COPY = TVRD()
        COPY=BYTSCL(COPY,MIN=0,TOP=MAX(COPY))
        ZWIN
      ENDIF ELSE COPY=IM
      PAL_36,R,G,B
      WRITE_PNG,PNGFILE,COPY,R,G,B
    ENDIF
  ENDFOR

  GONE, L3B9
ENDIF ; IF KEY(DO_L3B9_2MAP) THEN BEGIN
;||||||||||||||||||||||||||||||||||||||

;***************************************
IF KEY(DO_MAP_WITHIN_A_MAP) THEN BEGIN
  ;***************************************
  SWITCHES,DO_MAP_WITHIN_A_MAP,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS,R_MAPS=R_MAPS,R_PRODS=R_PRODS,DATERANGE=DATERANGE
  IF STOPP THEN STOP
  MAP_IN='EC'
  NAME = ['GEQ_EC']

  MAPS_OUT = ['EC','NEC','NENA','NECNFL','NWA','GOESWH']
  EC = READALL(DIR_OUT+ 'MAPS_REMAP_DEMO-GEQ_EC-PXY_1024_1024.PNG')


  ;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
  FOR _MAP = 0,N_ELEMENTS(MAPS_OUT)-1 DO BEGIN
    IF _MAP EQ 0 THEN INIT = 1 ELSE INIT=0
    MAP_OUT = MAPS_OUT(_MAP)
    PNGFILE = DIR_OUT+ROUTINE_NAME+'-'+NAME+'_'+MAP_OUT+'.PNG'
    IF FILE_TEST(PNGFILE) EQ 0 OR DO_MAP_WITHIN_A_MAP GE 2 THEN BEGIN
      TIC
      IM= MAPS_REMAP(EC,MAP_IN=MAP_IN,MAP_OUT=MAP_OUT)
      TOC
      IF MAP_OUT NE 'NENA' THEN BEGIN
        ZWIN,IM
        MAPS_SET,MAP_OUT
        TV,IM
        MAP_CONTINENTS,/HIRES,/COASTS,COLOR=11
        COPY = TVRD()
        COPY=BYTSCL(COPY,MIN=0,TOP=MAX(COPY))
        ZWIN
      ENDIF ELSE COPY=IM
      PAL_36,R,G,B
      WRITE_PNG,PNGFILE,COPY,R,G,B
    ENDIF
  ENDFOR
  EC=''
ENDIF ;  IF KEY(DO_MAP_WITHIN_A_MAP) THEN BEGIN
;||||||||||||||||||||||||||||||||||||||||||||||




  ;*****************************
  IF KEY(DO_L2_FLAGS) THEN BEGIN
    ;***************************
    SWITCH_NAME = 'DO_L2_FLAGS'
    SWITCHES,DO_L2_FLAGS,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
    IF VERBOSE THEN , SWITCH_NAME
    
    FILE = FLS(!S.FILES + 'S_2009*MODISA-1KM*L2.nc')
    SD = READ_NC(FILE,PROD=['longitude','latitude','l2_flags'],/DATA)

    LAND = SD_FLAGS_COMBO(SD.SD.L2_FLAGS.IMAGE,1) ; LAND FLAG
    OK = WHERE(LAND EQ 1, COUNT_LAND)
    LAND[OK] = 22 ; MAKE RED TO STAND OUT
    LON   = SD.SD.LONGITUDE.IMAGE
    LAT   = SD.SD.LATITUDE.IMAGE
    NEC =  MAPS_LONLAT_GRID(LAND,MAP_OUT='NEC',LON=LON,LAT=LAT,/INIT)
    OK = WHERE(NEC EQ 22)
    MASK = READ_LANDMASK(MAP='NEC',/STRUCT)
    LD = MASK.LANDMASK & LD(*) = 36
    LD(MASK.LAND) = 32
    LD[OK] = 22
    LD(MASK.COAST) = 18
    IM = IMAGE(LD,RGB_TABLE=CPAL_READ('PAL_36'),MARGIN=0,DIMENSIONS=[1024,1024])
    IM.SAVE, DIR + ROUTINE_NAME +'-' + SWITCH_NAME +'-' + METHOD + '.PNG'
    IM.CLOSE
     IMGR,NEC,MAP='NEC',/COAST_ONLY,PNGFILE =DIR + ROUTINE_NAME +'-' + SWITCH_NAME +'-' + METHOD + '.PNG',DELAY=8

    IF VERBOSE THEN ,SNAME
  ENDIF ; DO_L2_FLAGS
  ;|||||||||||||||||||||||||||||||||||

  



;








	; *****************************
	IF KEY(DO_L2_2NENA) THEN BEGIN
	  ; *****************************
	  PRINT, 'Running: DO_L2_2NENA'
	  SWITCH_NAME = 'DO_L2_2NENA'
	  SWITCHES,DO_L2_2NENA,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN ,SWITCH_NAME

	ENDIF ; DO_L2_2NENA

;*****************************
	IF KEY(DO_MAP_2NENA) THEN BEGIN
;*****************************
	  SWITCH_NAME = 'DO_MAP_2NENA'
	  SWITCHES,DO_MAP_2NENA,STOPP=STOPP,OVERWRITE=OVERWRITE,VERBOSE=VERBOSE,INIT=INIT,R_FILES=R_FILES,R_DATASETS=R_DATASETS
	  IF VERBOSE THEN ,SWITCH_NAME

	ENDIF ; DO_MAP_2NENA



DONE:

END; #####################  END OF ROUTINE ################################




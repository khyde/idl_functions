; $ID:	STATS_ARRAYS_XYZ.PRO,	2020-07-08-15,	USER-KJWH	$

;#######################################################################################################################################################################################################
FUNCTION XYZ_ARRAYS, XYZTYPE=XYZTYPE, XYZDATA=XYZDATA, XYZTRANSFORM=XYZTRANSFORM, XYZSTART=XYZSTART, XYZCALC=XYZCALC, XYZRANGE=XYZRANGE, XYZOPER=XYZOPER, XYZCRITERIA_TXT=XYZCRITERIA_TXT, XYZMISSING=XYZMISSING, XYZSTATS=XYZSTATS, XYZSUBS=XYZSUBS, XYZERROR=XYZERROR

; !!!!! OBSOLETE BUT CAN STILL BE CALLED USING THE "OLD_METHOD" KEYWORD !!!!!
; !!!!! NOW USING MULTIPLE CALLS TO STATS_ARRAYS !!!!!
  
; *******************
  ROUTINE='XYZ_ARRAYS' 
; *******************

  IF N_ELEMENTS(XYZTYPE) NE 1 THEN MESSAGE, 'ERROR: Must indicate if the ARR represents X, Y or Z data'
  IF XYZTYPE NE 'X' AND XYZTYPE NE 'Y' AND XYZTYPE NE 'Z' THEN MESSAGE, 'ERROR: Must indicate if the ARR represents X, Y or Z data'
      
; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  COMMON COMMON_STATS_ARRAYS, X_STATS_STRUCT, Y_STATS_STRUCT, Z_STATS_STRUCT 
; $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  
  IF KEY(XYZSTART) THEN BEGIN
    IF XYZTYPE EQ 'X' THEN X_STATS_STRUCT = []
    IF XYZTYPE EQ 'Y' THEN Y_STATS_STRUCT = []
    IF XYZTYPE EQ 'Z' THEN Z_STATS_STRUCT = []
  ENDIF
  
  CASE XYZTYPE OF
    'X': XYZ = X_STATS_STRUCT
    'Y': XYZ = Y_STATS_STRUCT
    'Z': XYZ = Z_STATS_STRUCT
  ENDCASE  
  
  ; ===> SET UP CONSTANTS
  ERROR = ''
  NEG_INF = -MISSINGS(0.0)  ;
  POS_INF =  MISSINGS(0.0)
  MAX_SIZE = 4320*2160UL ;
  STAT_TYPES = ['NUM','MIN','MAX','SPAN','NEG','WTS','SUM','SSQ','MEAN','STD','CV']  ; ALLOWABLE STAT_TYPES 

  ; ===> CHECK ON XYZSTATS [IF NONE PROVIDED THEN DO ALL STAT_TYPES]
  IF NONE(XYZSTATS) THEN BEGIN
    STATS_2DO = STAT_TYPES
    DO_STATS  = STAT_TYPES
  ENDIF ELSE BEGIN
    OK_STATS =WHERE_IN(STAT_TYPES, STRUPCASE(XYZSTATS),COUNT_STATS)
    IF COUNT_STATS GE 1 THEN BEGIN
      STATS_2DO = STAT_TYPES(OK_STATS)
      DO_STATS  = STATS_2DO
      
      ; ===> ADD STATS REQUIRED BY OTHER STATS
      IF HAS(STATS_2DO,'MEAN')   THEN STATS_2DO = [STATS_2DO,'NUM','SUM']              ; IF MEAN IS REQUESTED THEN MUST HAVE SUM AND NUM
      IF HAS(STATS_2DO,'STD')    THEN STATS_2DO = [STATS_2DO,'NUM','SUM','SSQ']        ; STD NEEDS SSQ
      IF HAS(STATS_2DO,'CV')     THEN STATS_2DO = [STATS_2DO,'NUM','SUM','SSQ','STD']  ; CV NEEDS STD
      IF HAS(STATS_2DO,'SPAN')   THEN STATS_2DO = [STATS_2DO,'MIN','MAX']              ; SPAN NEEDS MIN AND MAX
      STATS_2DO = [STATS_2DO,'NUM']                                                    ; NUM IS ALWAYS DONE

      ;  ===> RESORT STATS_2DO IN ORDER OF STAT_TYPES SO THAT THE OUTPUT STRUCTURE ALWAYS LOOKS THE SAME
      S = WHERE_IN(STAT_TYPES,STATS_2DO)
      STATS_2DO = STAT_TYPES(S)
    ENDIF ELSE BEGIN
      ERROR = 'ERROR: THE REQUESTED STATS IN XYZSTATS ARE NOT AVAILABLE'
      PRINT,ERROR
      RETURN, ERROR
    ENDELSE;IF COUNT_STATS GE 1 THEN BEGIN
  ENDELSE;IF N_ELEMENTS(XYZSTATS) EQ 0 THEN BEGIN

  IF N_ELEMENTS(TRANSFORM) NE 1 THEN TRANSFORM = ''
  IF NONE(XYZDATA) AND KEY(XYZCALC) THEN GOTO, CALCULATE_XYZ ; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  
  ; ===> MUST ALWAYS PROVIDE DATA (XYZDATA)
  IF N_ELEMENTS(XYZDATA) EQ 0 THEN BEGIN
    ERROR = 'ERROR: MUST ALWAYS PROVIDE XYZ ARRAY'
    PRINT,ERROR
    RETURN,ERROR
  ENDIF;IF N_ELEMENTS(XYZDATA) EQ 0 THEN BEGIN


; *****************************************
; ***** INITIALIZE STATISTICAL ARRAYS *****  
; *****************************************
  IF KEY(XYZSTART) THEN BEGIN
    STATS_ARRAYS_SZ = SIZE(XYZDATA,/STRUCTURE)        ; The first xyz array determines the acceptable size of arrays thereafter
    
    IF STATS_ARRAYS_SZ.N_DIMENSIONS NE 2 THEN BEGIN   ; If xyz is not 2d then RETURN error
      ERROR = 'ERROR: XYZ MUST BE A 2D ARRAY'
      PRINT,ERROR
 ;     RETURN,ERROR
    ENDIF;IF STATS_ARRAYS_SZ.N_DIMENSIONS NE 2 THEN BEGIN
  
    STATS_ARRAYS_N_SETS = 0L                                                                                     ; Initialize n_sets (number of times/calls xyz passed to this program)
    IF N_ELEMENTS(XYZOPER)  EQ 2 THEN STATS_ARRAYS_OPER  = XYZOPER  ELSE STATS_ARRAYS_OPER  = ['GE','LE']        ; If range is not provided then range will be from GE -INF TO LE +INF
    IF N_ELEMENTS(XYZRANGE) EQ 2 THEN STATS_ARRAYS_RANGE = XYZRANGE ELSE BEGIN 
      STATS_ARRAYS_RANGE = [-MISSINGS(XYZDATA),MISSINGS(XYZDATA)]
      STATS_ARRAYS_OPER  = ['GT','LT']                                                                            ; Rewrite the STATS_ARRAYS_OPER, otherwise it will include the MISSINGS XYZ
    ENDELSE

    IF N_ELEMENTS(XYZMISSING) NE 1 THEN STATS_ARRAYS_MISSING = MISSINGS(0.0) ELSE STATS_ARRAYS_MISSING = XYZMISSING ; CHECK ON MISSING VALUE IF NOT PROVIDED THEN IT WILL BE !VALUES.F_INFINITY

    IF N_ELEMENTS(XYZTRANSFORM) EQ 1 THEN BEGIN                                                                       ; CHECK ON VALIDITY OF XYZTRANSFORM
      IF STRUPCASE(XYZTRANSFORM) EQ 'ALOG' OR STRUPCASE(XYZTRANSFORM) EQ 'ALOG10' THEN STATS_ARRAYS_TRANSFORM = XYZTRANSFORM $
                                                                                  ELSE STATS_ARRAYS_TRANSFORM = ''
    ENDIF;IF N_ELEMENTS(XYZTRANSFORM) EQ 1 THEN BEGIN

    XYZ = CREATE_STRUCT('STATS_ARRAYS_SZ',STATS_ARRAYS_SZ, 'STATS_ARRAYS_TRANSFORM',STATS_ARRAYS_TRANSFORM, 'STATS_ARRAYS_MISSING',STATS_ARRAYS_MISSING,$
      'STATS_ARRAYS_RANGE',STATS_ARRAYS_RANGE, 'STATS_ARRAYS_OPER',STATS_ARRAYS_OPER, 'STATS_ARRAYS_CRITERIA','', 'STATS_ARRAYS_N_SETS', 0L)
    
    IF STATS_ARRAYS_SZ.N_DIMENSIONS EQ 1 THEN DIMS = STATS_ARRAYS_SZ.DIMENSIONS[0] ELSE DIMS = [STATS_ARRAYS_SZ.DIMENSIONS[0],STATS_ARRAYS_SZ.DIMENSIONS[1]]
      
    IF HAS(STATS_2DO,'NUM')  THEN XYZ = CREATE_STRUCT(XYZ,'NUM_MEM', FLTARR(            DIMS))
    IF HAS(STATS_2DO,'MIN')  THEN XYZ = CREATE_STRUCT(XYZ,'MIN_MEM', REPLICATE(POS_INF, DIMS))
    IF HAS(STATS_2DO,'MAX')  THEN XYZ = CREATE_STRUCT(XYZ,'MAX_MEM', REPLICATE(NEG_INF, DIMS))
    IF HAS(STATS_2DO,'SPAN') THEN XYZ = CREATE_STRUCT(XYZ,'SPAN_MEM',REPLICATE(POS_INF, DIMS))
    IF HAS(STATS_2DO,'NEG')  THEN XYZ = CREATE_STRUCT(XYZ,'NEG_MEM', FLTARR(            DIMS))
    IF HAS(STATS_2DO,'WTS')  THEN XYZ = CREATE_STRUCT(XYZ,'WTS_MEM', REPLICATE(1.0,     DIMS))
    IF HAS(STATS_2DO,'SUM')  THEN XYZ = CREATE_STRUCT(XYZ,'SUM_MEM', FLTARR(            DIMS))
    IF HAS(STATS_2DO,'SSQ')  THEN XYZ = CREATE_STRUCT(XYZ,'SSQ_MEM', FLTARR(            DIMS))
    IF HAS(STATS_2DO,'MEAN') THEN XYZ = CREATE_STRUCT(XYZ,'MEAN_MEM',FLTARR(            DIMS))
    IF HAS(STATS_2DO,'STD')  THEN XYZ = CREATE_STRUCT(XYZ,'STD_MEM', FLTARR(            DIMS))
    IF HAS(STATS_2DO,'CV')   THEN XYZ = CREATE_STRUCT(XYZ,'CV_MEM',  FLTARR(            DIMS))
      
  ENDIF ELSE BEGIN ;IF KEY(XYZSTART) THEN BEGIN    
  
  ; ===> USE COMMON INFORMATION TO SET UP THE XYZ VARIABLES
    CASE XYZTYPE OF
      'X': XYZ = X_STATS_STRUCT
      'Y': XYZ = Y_STATS_STRUCT
      'Z': XYZ = Z_STATS_STRUCT
    ENDCASE
  ENDELSE ; IF NOT /START  

; ********************************************************
; ***** ACCUMULATE N_SETS, N, SUM AND SUM OF SQUARES *****
; ********************************************************  
  IF NONE(XYZ.STATS_ARRAYS_N_SETS) THEN BEGIN                                                                         ; MAKE SURE START KEYWORD HAS BEEN PREVIOUSLY PROVIDED (INITIALIZATION OF N,SUM,SSQ ARRAYS)
    ERROR = 'ERROR: MUST USE KEYWORD START TO INITIALIZE THE STATISTICAL ARRAYS'
    PRINT,ERROR
    RETURN,ERROR
  ENDIF;IF NONE(STATS_ARRAYS_N_SETS) THEN BEGIN

  SZ_CHECK = SIZE(XYZDATA,/STRUCTURE)                                                                                 ; MAKE SURE XYZ IS SAME DIMENSIONS AS HAS BEEN PREVIOUSLY PROVIDED (DURING INITIALIZATION OF N,SUM,SSQ ARRAYS).
  IF SZ_CHECK.TYPE NE XYZ.STATS_ARRAYS_SZ.TYPE OR SZ_CHECK.N_ELEMENTS NE XYZ.STATS_ARRAYS_SZ.N_ELEMENTS OR SZ_CHECK.N_DIMENSIONS NE XYZ.STATS_ARRAYS_SZ.N_DIMENSIONS THEN BEGIN
    ERROR = 'ERROR: XYZ DIMENSIONS DO NOT AGREE WITH PREVIOUS XYZ DIMENSIONS  '
    PRINT,ERROR
    RETURN,ERROR
  ENDIF

  ; ===> FIND XYZ WITHIN RANGE
  OK = WHERE_CRITERIA(XYZDATA,OPERATORS=XYZ.STATS_ARRAYS_OPER,RANGE=XYZ.STATS_ARRAYS_RANGE,NCOMPLEMENT=NCOMPLEMENT,COMPLEMENT=COMPLEMENT,CRITERIA_TXT=XYZCRITERIA_TXT,COUNT)
  IF XYZ.STATS_ARRAYS_CRITERIA EQ '' THEN XYZ.STATS_ARRAYS_CRITERIA = XYZCRITERIA_TXT

  ; ===> REPLACE THE XYZ OUT OF RANGE WITH MISSINGS SO THAT OK_NEG WILL WORK
  IF NCOMPLEMENT GE 1 THEN XYZDATA(COMPLEMENT) = MISSINGS(XYZDATA); BAD XYZ

  ; ===> FIND XYZ WITHIN THE ALLOWABLE RANGE (IF LOG-TRANSFORMED TO BE DONE THEN XYZ MUST BE POSITIVE)
  IF XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG' OR XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG10' $
    THEN XYZSUBS = WHERE(XYZDATA NE XYZ.STATS_ARRAYS_MISSING AND FINITE(XYZDATA) EQ 1 AND XYZDATA NE MISSINGS(XYZDATA) AND XYZDATA GT 0, COUNT, NCOMPLEMENT=NCOMPLEMENT, COMPLEMENT=COMPLEMENT) $
    ELSE XYZSUBS = WHERE(XYZDATA NE XYZ.STATS_ARRAYS_MISSING AND FINITE(XYZDATA) EQ 1 AND XYZDATA NE MISSINGS(XYZDATA),                  COUNT, NCOMPLEMENT=NCOMPLEMENT, COMPLEMENT=COMPLEMENT)
  IF NCOMPLEMENT GE 1 THEN XYZDATA(COMPLEMENT) = MISSINGS(XYZDATA) ; BAD    

  ; ===> LOG-TRANSFORM
  IF XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG'   THEN XYZDATA = ALOG(XYZDATA)
  IF XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG10' THEN XYZDATA = ALOG10(XYZDATA)

  ; ===> ALWAYS ADD 1 TO SET (EVEN WHEN ALL XYZ ARE EQUAL TO MISSING CODE)
  XYZ.STATS_ARRAYS_N_SETS = XYZ.STATS_ARRAYS_N_SETS + 1L

  ; ===> IF THERE ARE ANY VALID XYZ THEN DO THE STATISTICAL SUMS 
  IF COUNT GE 1 THEN BEGIN
    IF COUNT LE MAX_SIZE THEN BEGIN
      N_ITER = 1 &  _MAX_SIZE = COUNT & _REMAINDER = 0L
    ENDIF ELSE BEGIN
      _MAX_SIZE = MAX_SIZE
      N_ITER = COUNT/_MAX_SIZE & _REMAINDER = COUNT MOD _MAX_SIZE & IF _REMAINDER NE 0 THEN N_ITER = N_ITER +1
    ENDELSE;IF COUNT LE MAX_SIZE THEN BEGIN
      
    ; ===> LOOP THROUGH THE NUMBER OF ITERATIONS
    FOR NTH=0L, N_ITER-1L DO BEGIN
      SUBS_START = NTH*_MAX_SIZE & SUBS_FIN = SUBS_START + _MAX_SIZE -1L
      IF NTH EQ N_ITER -1 AND _REMAINDER NE 0 THEN SUBS_FIN = SUBS_START + _REMAINDER -1L
      IF HAS(STATS_2DO,'NUM')  THEN XYZ.NUM_MEM(XYZSUBS(SUBS_START:SUBS_FIN)) +=   1.0                                     
      IF HAS(STATS_2DO,'MIN')  THEN XYZ.MIN_MEM(XYZSUBS(SUBS_START:SUBS_FIN)) <=  XYZDATA(XYZSUBS(SUBS_START:SUBS_FIN))    
      IF HAS(STATS_2DO,'MAX')  THEN XYZ.MAX_MEM(XYZSUBS(SUBS_START:SUBS_FIN)) >=  XYZDATA(XYZSUBS(SUBS_START:SUBS_FIN))    
      IF HAS(STATS_2DO,'SUM')  THEN XYZ.SUM_MEM(XYZSUBS(SUBS_START:SUBS_FIN)) +=  XYZDATA(XYZSUBS(SUBS_START:SUBS_FIN))    
      IF HAS(STATS_2DO,'SSQ')  THEN XYZ.SSQ_MEM(XYZSUBS(SUBS_START:SUBS_FIN)) +=  (XYZDATA(XYZSUBS(SUBS_START:SUBS_FIN)) * XYZDATA(XYZSUBS(SUBS_START:SUBS_FIN))) 
      IF HAS(STATS_2DO,'SPAN') THEN XYZ.SPAN_MEM = XYZ.MAX_MEM - XYZ.MIN_MEM
    ENDFOR;FOR NTH = 0L,N_ITER -1L DO BEGIN

    ; ===> CALCULATE THE NEG STAT 
    IF HAS(STATS_2DO,'NEG') THEN BEGIN
      IF XYZ.STATS_ARRAYS_TRANSFORM NE 'ALOG' AND XYZ.STATS_ARRAYS_TRANSFORM NE 'ALOG10' THEN BEGIN ; ONLY INCREMENT THE NEG COUNTER IF THE XYZ TRANSFORM IS NOT LOG OR LOG10
        OK_NEG = WHERE(FINITE(XYZDATA) AND XYZDATA LE 0,COUNT_NEG)                                  ; FIND THE NEGATIVE XYZ
        IF COUNT_NEG GE 1 THEN BEGIN
          IF COUNT_NEG LE MAX_SIZE THEN BEGIN
            N_ITER = 1 &  _MAX_SIZE = COUNT_NEG & _REMAINDER = 0L
          ENDIF ELSE BEGIN
            _MAX_SIZE = MAX_SIZE
            N_ITER = COUNT_NEG/_MAX_SIZE & _REMAINDER = COUNT_NEG MOD _MAX_SIZE & IF _REMAINDER NE 0 THEN N_ITER = N_ITER +1 ;
          ENDELSE ; IF COUNT_NEG LE MAX_SIZE THEN BEGIN
          
          ; ===> LOOP THROUGH THE NUMBER OF ITERATIONS
          FOR NTH = 0L,N_ITER -1L DO BEGIN
            SUBS_START = NTH*_MAX_SIZE & SUBS_FIN = SUBS_START + _MAX_SIZE -1L
            IF NTH EQ N_ITER -1 AND _REMAINDER NE 0 THEN SUBS_FIN = SUBS_START + _REMAINDER -1L
            XYZ.NEG_MEM(OK_NEG(SUBS_START:SUBS_FIN)) +=   1L
          ENDFOR;FOR NTH = 0L,N_ITER -1L DO BEGIN
        ENDIF ; IF COUNT_NEG GE 1 THEN
      ENDIF ; IF STATS_ARRAYS_TRANSFORM NE 'ALOG' AND STATS_ARRAYS_TRANSFORM NE 'ALOG10' THEN BEGIN
    ENDIF  ; IF HAS(STATS_2DO,'NEG') THEN BEGIN
  ENDIF ; IF COUNT GE 1 (DO THE STATISTICAL SUMS)

  ; ===> NULL THE COUNT, ETC FOR THE XYZ JUST PROCESSED
  GONE, COUNT & GONE, COUNT_NEG & GONE, OK_NEG & GONE, XYZDATA

  ; ===> UPDATE THE COMMON INFORMATION
  CASE XYZTYPE OF
    'X': X_STATS_STRUCT = XYZ
    'Y': Y_STATS_STRUCT = XYZ
    'Z': Z_STATS_STRUCT = XYZ
  ENDCASE
  
  ; ===> IF NOT TIME TO CALCULATE, THEN PUT XYZ VARIABLES INTO THE CORRECT COMMON 
  IF ~KEY(XYZCALC) THEN BEGIN
    N_SETS = XYZ.STATS_ARRAYS_N_SETS
    GONE, XYZ  
    RETURN, N_SETS ; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  ENDIF
  
  CALCULATE_XYZ:

  ; ===> CHECK IF STATS_ARRAYS HAS BEEN USED TO ACCUMULATE STATISTICS (BEFORE /CALC MAY BE USED)
  IF N_ELEMENTS(XYZ.STATS_ARRAYS_N_SETS) LT 1 THEN BEGIN
    ERROR = 'ERROR: THE FIRST CALL TO STATS_ARRAYS MUST USE /START TO INITIALIZE STATISTICAL ARRAYS'
    PRINT,ERROR
    RETURN,ERROR
  ENDIF
  
  ; ===> PUT COMMOM VARIABLES INTO THE XYZ VARIABLES
  CASE XYZTYPE OF
    'X': XYZ = X_STATS_STRUCT
    'Y': XYZ = Y_STATS_STRUCT
    'Z': XYZ = Z_STATS_STRUCT
  ENDCASE
  
  ; ===> FIND THE PIXELS WITH AT LEAST 1 VALUE FROM ALL THE DATA ARRAYS PASSED
  OK = WHERE(XYZ.NUM_MEM GE 1, COUNT_1, NCOMPLEMENT=NCOMPLEMENT, COMPLEMENT=COMPLEMENT)
  IF NCOMPLEMENT GE 1 THEN BEGIN ; SET ARRAY ELEMENTS WHERE NUM = 0 TO MISSINGS CODE
    IF HAS(STATS_2DO,'NUM')   THEN XYZ.NUM_MEM(COMPLEMENT)  = MISSINGS(XYZ.NUM_MEM)
    IF HAS(STATS_2DO,'MIN')   THEN XYZ.MIN_MEM(COMPLEMENT)  = MISSINGS(XYZ.MIN_MEM)
    IF HAS(STATS_2DO,'MAX')   THEN XYZ.MAX_MEM(COMPLEMENT)  = MISSINGS(XYZ.MAX_MEM)
    IF HAS(STATS_2DO,'NEG')   THEN XYZ.NEG_MEM(COMPLEMENT)  = MISSINGS(XYZ.NEG_MEM)
    IF HAS(STATS_2DO,'WTS')   THEN XYZ.WTS_MEM(COMPLEMENT)  = MISSINGS(XYZ.WTS_MEM)
    IF HAS(STATS_2DO,'SUM')   THEN XYZ.SUM_MEM(COMPLEMENT)  = MISSINGS(XYZ.SUM_MEM)
    IF HAS(STATS_2DO,'SSQ')   THEN XYZ.SSQ_MEM(COMPLEMENT)  = MISSINGS(XYZ.SSQ_MEM)
    IF HAS(STATS_2DO,'STD')   THEN XYZ.STD_MEM(COMPLEMENT)  = MISSINGS(XYZ.STD_MEM)
    IF HAS(STATS_2DO,'CV')    THEN XYZ.CV_MEM(COMPLEMENT)   = MISSINGS(XYZ.CV_MEM)
    IF HAS(STATS_2DO,'SPAN')  THEN XYZ.SPAN_MEM(COMPLEMENT) = MISSINGS(XYZ.SPAN_MEM)
  ENDIF ; IF NCOMPLEMENT GE 1 THEN BEGIN

  ; ===> CALCUATE THE STATS IF THERE IS AT LEAST 1 "GOOD" VALUE
  IF COUNT_1 GE 1 THEN BEGIN    
    ; ===> MEAN STAT
    IF HAS(STATS_2DO,'MEAN') THEN BEGIN
      XYZ.MEAN_MEM = XYZ.SUM_MEM ; THE DIMENSION OF MEAN_MEM MUST MATCH THE DIMENSIONS OF SUM_MEM AND SET ARRAYS TO MISSING
      IF COUNT_1 LE MAX_SIZE THEN BEGIN
        N_ITER = 1 &  _MAX_SIZE = COUNT_1 & _REMAINDER = 0L
      ENDIF ELSE BEGIN
        _MAX_SIZE = MAX_SIZE
        N_ITER = COUNT_1/_MAX_SIZE & _REMAINDER = COUNT_1 MOD _MAX_SIZE & IF _REMAINDER NE 0 THEN N_ITER = N_ITER +1
      ENDELSE
      FOR NTH = 0L,N_ITER -1L DO BEGIN ; ===> LOOP THROUGH ITERATIONS
        SUBS_START = NTH*_MAX_SIZE & SUBS_FIN = SUBS_START + _MAX_SIZE -1L
        IF NTH EQ N_ITER -1 AND _REMAINDER NE 0 THEN SUBS_FIN = SUBS_START + _REMAINDER -1L
        XYZ.MEAN_MEM((OK(SUBS_START:SUBS_FIN))) = XYZ.SUM_MEM(OK(SUBS_START:SUBS_FIN))/XYZ.NUM_MEM(OK(SUBS_START:SUBS_FIN))
      ENDFOR;FOR NTH = 0L,N_ITER -1L DO BEGIN
      IF NCOMPLEMENT GE 1 THEN XYZ.MEAN_MEM(COMPLEMENT) = MISSINGS(XYZ.MEAN_MEM)
      GONE, OK & GONE, COMPLEMENT ; NULL OUT THE OK AND COMPLEMENT
    ENDIF ; MEAN STAT
 
    ; ===> STD STAT
    IF HAS(STATS_2DO,'STD') OR HAS(STATS_2D,'CV') THEN BEGIN
      OK2 = WHERE(XYZ.NUM_MEM GE 2 AND XYZ.NUM_MEM NE MISSINGS(XYZ.NUM_MEM),COUNT_2,NCOMPLEMENT=NCOMPLEMENT2,COMPLEMENT=COMPLEMENT2) ; CAN NOT CALCULATE A STD FOR N = 1
      IF COUNT_2 GE 1 THEN BEGIN ; NEED 2 OR MORE XYZ.NUM_MEM TO DO STD OR CV
        IF COUNT_2 LE MAX_SIZE THEN BEGIN
          N_ITER = 1 &  _MAX_SIZE = COUNT_2 & _REMAINDER = 0L
        ENDIF ELSE BEGIN
          _MAX_SIZE = MAX_SIZE
          N_ITER = COUNT_2/_MAX_SIZE & _REMAINDER = COUNT_2 MOD _MAX_SIZE & IF _REMAINDER NE 0 THEN N_ITER = N_ITER +1
        ENDELSE;IF COUNT_2 LE MAX_SIZE THEN BEGIN
        IF HAS(STATS_2DO,'STD')  THEN BEGIN
          XYZ.STD_MEM = XYZ.SUM_MEM & XYZ.STD_MEM(*) = MISSINGS(XYZ.STD_MEM) ; THE DIMENSION OF XYZ.STD_MEM MUST MATCH THE DIMENSIONS OF XYZ.SUM_MEM AND SET ARRAYS TO MISSING
          FOR NTH = 0L,N_ITER -1L DO BEGIN ; ===> LOOP THROUGH ITERATIONS
            SUBS_START = NTH*_MAX_SIZE & SUBS_FIN = SUBS_START + _MAX_SIZE -1L
            IF NTH EQ N_ITER -1 AND _REMAINDER NE 0 THEN SUBS_FIN = SUBS_START + _REMAINDER -1L
            XYZ.STD_MEM(OK2(SUBS_START:SUBS_FIN)) = (((XYZ.SSQ_MEM((OK2(SUBS_START:SUBS_FIN)))-((XYZ.SUM_MEM((OK2(SUBS_START:SUBS_FIN)))*XYZ.SUM_MEM((OK2(SUBS_START:SUBS_FIN))))/XYZ.NUM_MEM((OK2(SUBS_START:SUBS_FIN)))))^0.5)/((XYZ.NUM_MEM((OK2(SUBS_START:SUBS_FIN)))-1)^0.5)) ;;
          ENDFOR;FOR NTH = 0L,N_ITER -1L DO BEGIN
          OK_NAN = WHERE(FINITE(XYZ.STD_MEM(OK2)) EQ 0,COUNT_NAN) ; CHECK FOR VALUES OF NAN WHICH SHOULD BE SET TO ZERO BECAUSE OF IMPRECISION AND ROUNDING ERRORS IN THE ABOVE EQUATION
          IF COUNT_NAN GE 1 THEN XYZ.STD_MEM(OK2(OK_NAN)) = 0
          IF NCOMPLEMENT2 GE 1 THEN XYZ.STD_MEM(COMPLEMENT2) = MISSINGS(XYZ.STD_MEM)
          GONE, OK & GONE, COMPLEMENT ; NULL OUT THE OK AND COMPLEMENT
        ENDIF ; STD STAT

        ; ===> CV STAT
        IF HAS(STATS_2DO,'CV')  THEN BEGIN
          XYZ.CV_MEM = XYZ.SUM_MEM & XYZ.CV_MEM(*) = MISSINGS(XYZ.CV_MEM)
          FOR NTH = 0L,N_ITER -1L DO BEGIN  ; ===> LOOP THROUGH ITERATIONS
            SUBS_START = NTH*_MAX_SIZE & SUBS_FIN = SUBS_START + _MAX_SIZE -1L
            IF NTH EQ N_ITER -1 AND _REMAINDER NE 0 THEN SUBS_FIN = SUBS_START + _REMAINDER -1L
            XYZ.CV_MEM((OK2(SUBS_START:SUBS_FIN))) = 100D*(XYZ.STD_MEM((OK2(SUBS_START:SUBS_FIN))))/(XYZ.SUM_MEM((OK2(SUBS_START:SUBS_FIN)))/XYZ.NUM_MEM((OK2(SUBS_START:SUBS_FIN))))
          ENDFOR;FOR NTH = 0L,N_ITER -1L DO BEGIN
          OK_NAN = WHERE(FINITE(XYZ.CV_MEM(OK2)) EQ 0,COUNT_NAN)
          IF COUNT_NAN GE 1 THEN XYZ.CV_MEM(OK2(OK_NAN)) = 0
          IF NCOMPLEMENT2 GE 1 THEN XYZ.CV_MEM(COMPLEMENT2) = MISSINGS(XYZ.CV_MEM)
          GONE, OK & GONE, COMPLEMENT ; NULL OUT THE OK AND COMPLEMENT
        ENDIF ; CV STAT
      ENDIF ; IF COUNT GE 2
    ENDIF ; STD OR CV STAT
  ENDIF ELSE BEGIN ; IF COUNT GE 1 THEN BEGIN
    XYZ.MEAN_MEM    = XYZ.SUM_MEM
    XYZ.MEAN_MEM(*) = MISSINGS(XYZ.MEAN_MEM)
  ENDELSE ; ||||||||||||||||||||||||||||||||

; **************************************************************
; ***** CONSTRUCT A  STRUCTURE TO HOLD STATISTICAL RESULTS *****
; **************************************************************

  STRUCT= CREATE_STRUCT('N_SETS',XYZ.STATS_ARRAYS_N_SETS, 'RANGE', XYZ.STATS_ARRAYS_RANGE, 'MISSING',XYZ.STATS_ARRAYS_MISSING, 'TRANSFORM',XYZ.STATS_ARRAYS_TRANSFORM)
  IF HAS(DO_STATS,'NUM')  AND HAS(STATS_2DO,'NUM')  THEN STRUCT = CREATE_STRUCT(STRUCT,'NUM', XYZ.NUM_MEM)
  IF HAS(DO_STATS,'MIN')  AND HAS(STATS_2DO,'MIN')  THEN STRUCT = CREATE_STRUCT(STRUCT,'MIN', XYZ.MIN_MEM)
  IF HAS(DO_STATS,'MAX')  AND HAS(STATS_2DO,'MAX')  THEN STRUCT = CREATE_STRUCT(STRUCT,'MAX', XYZ.MAX_MEM)
  IF HAS(DO_STATS,'NEG')  AND HAS(STATS_2DO,'NEG')  THEN STRUCT = CREATE_STRUCT(STRUCT,'NEG', XYZ.NEG_MEM)
  IF HAS(DO_STATS,'WTS')  AND HAS(STATS_2DO,'WTS')  THEN STRUCT = CREATE_STRUCT(STRUCT,'WTS', XYZ.WTS_MEM)
  IF HAS(DO_STATS,'SUM')  AND HAS(STATS_2DO,'SUM')  THEN STRUCT = CREATE_STRUCT(STRUCT,'SUM', XYZ.SUM_MEM)
  IF HAS(DO_STATS,'SSQ')  AND HAS(STATS_2DO,'SSQ')  THEN STRUCT = CREATE_STRUCT(STRUCT,'SSQ', XYZ.SSQ_MEM)
  IF HAS(DO_STATS,'MEAN') AND HAS(STATS_2DO,'MEAN') THEN STRUCT = CREATE_STRUCT(STRUCT,'MEAN',XYZ.MEAN_MEM)
  IF HAS(DO_STATS,'STD')  AND HAS(STATS_2DO,'STD')  THEN STRUCT = CREATE_STRUCT(STRUCT,'STD', XYZ.STD_MEM)
  IF HAS(DO_STATS,'CV')   AND HAS(STATS_2DO,'CV')   THEN STRUCT = CREATE_STRUCT(STRUCT,'CV',  XYZ.CV_MEM)
  IF HAS(DO_STATS,'SPAN') AND HAS(STATS_2DO,'SPAN') THEN STRUCT = CREATE_STRUCT(STRUCT,'SPAN',XYZ.SPAN_MEM)

  ; ===> CHANGE ANY NANS IN THE MEAN TO INF
  IF HAS(DO_STATS,'MEAN') AND HAS(STATS_2DO,'MEAN') THEN BEGIN
    OK = WHERE(FINITE(STRUCT.MEAN) EQ 0, COUNT)
    IF COUNT GE 1 THEN STRUCT.MEAN[OK] =  MISSINGS(STRUCT.MEAN)
  ENDIF;IF HAS(STATS_2DO,'MEAN')   THEN BEGIN

  ; ===> CHANGE ANY NANS IN THE NUM TO INF
  IF HAS(DO_STATS,'NUM') AND HAS(STATS_2DO, 'NUM') THEN BEGIN
    OK = WHERE(FINITE(STRUCT.NUM) EQ 0,COUNT)
    IF COUNT GE 1 THEN STRUCT.NUM[OK] =  MISSINGS(STRUCT.NUM)
  ENDIF;IF HAS(STATS_2DO,'NUM')   THEN BEGIN

; ===>  ANTILOG ANY LOG-TRANSFORMED XYZ    
  IF XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG' THEN BEGIN
    IF HAS(DO_STATS,'MIN')  AND HAS(STATS_2DO,'MIN')  THEN STRUCT.MIN   = EXP(STRUCT.MIN)
    IF HAS(DO_STATS,'MAX')  AND HAS(STATS_2DO,'MAX')  THEN STRUCT.MAX   = EXP(STRUCT.MAX)
    IF HAS(DO_STATS,'SUM')  AND HAS(STATS_2DO,'SUM')  THEN STRUCT.SUM   = EXP(STRUCT.SUM)
    IF HAS(DO_STATS,'SSQ')  AND HAS(STATS_2DO,'SSQ')  THEN STRUCT.SSQ   = EXP(STRUCT.SSQ)
    IF HAS(DO_STATS,'MEAN') AND HAS(STATS_2DO,'MEAN') THEN STRUCT.MEAN  = EXP(STRUCT.MEAN)
  ENDIF;IF STATS_ARRAYS_TRANSFORM_X EQ 'ALOG' THEN BEGIN

  IF XYZ.STATS_ARRAYS_TRANSFORM EQ 'ALOG10' THEN BEGIN
    IF HAS(DO_STATS,'MIN')  AND HAS(STATS_2DO,'MIN')  THEN STRUCT.MIN    = 10^(STRUCT.MIN)
    IF HAS(DO_STATS,'MAX')  AND HAS(STATS_2DO,'MAX')  THEN STRUCT.MAX    = 10^(STRUCT.MAX)
    IF HAS(DO_STATS,'SUM')  AND HAS(STATS_2DO,'SUM')  THEN STRUCT.SUM    = 10^(STRUCT.SUM)
    IF HAS(DO_STATS,'SSQ')  AND HAS(STATS_2DO,'SSQ')  THEN STRUCT.SSQ    = 10^(STRUCT.SSQ)
    IF HAS(DO_STATS,'MEAN') AND HAS(STATS_2DO,'MEAN') THEN STRUCT.MEAN   = 10^(STRUCT.MEAN)
  ENDIF;IF STATS_ARRAYS_TRANSFORM_X EQ 'ALOG' THEN BEGIN
  GONE, XYZ
  RETURN,STRUCT
END ; #####################  END OF XYZ_ARRAYS ################################


;#############################################################################################
;#############################################################################################
;#############################################################################################
 FUNCTION STATS_ARRAYS_XYZ,	XDATA=XDATA, YDATA=YDATA, ZDATA=ZDATA, OLD_METHOD=OLD_METHOD,$
           
           XTRANSFORM=XTRANSFORM, XSTART=XSTART, XCALC=XCALC, XRANGE=XRANGE, XOPER=XOPER, XCRITERIA_TXT=XCRITERIA_TXT,$
           XMISSING=XMISSING, XSTATS=XSTATS, XSUBS=XSUBS, XERROR=XERROR,$
           
           YTRANSFORM=YTRANSFORM, YSTART=YSTART, YCALC=YCALC, YRANGE=YRANGE, YOPER=YOPER, YCRITERIA_TXT=YCRITERIA_TXT,$
           YMISSING=YMISSING, YSTATS=YSTATS, YSUBS=YSUBS, YERROR=YERROR,$

           ZTRANSFORM=ZTRANSFORM, ZSTART=ZSTART, ZCALC=ZCALC, ZRANGE=ZRANGE, ZOPER=ZOPER, ZCRITERIA_TXT=ZCRITERIA_TXT,$
           ZMISSING=ZMISSING, ZSTATS=ZSTATS, ZSUBS=ZSUBS, ZERROR=ZERROR
    
;+
; NAME:  STATS_ARRAYS_XYZ
;
; PURPOSE:
;				COMPUTE STATISTICS (NUM,MIN,MAX,NEG,SUM,SPAN,SSQ,MEAN,STD,CV) 
;				FOR EACH PIXEL FROM A SERIES OF OF 2-D DATA ARRAYS
;
; INPUTS:

; KEYWORDS:
;       XDATA........... 2D ARRAYS [DATA MUST BE PROVIDED EVERY CALL TO STATS_ARRAYS_XYZ
;       YDATA........... 2D ARRAYS [OPTIONAL] [DATA MUST BE PROVIDED EVERY CALL TO STATS_ARRAYS_XYZ
;       ZDATA........... 2D ARRAYS [OPTIONAL] [DATA MUST BE PROVIDED EVERY CALL TO STATS_ARRAYS_XYZ
; 
;				[XYZ]TRANSFORM: 'ALOG' OR ALOG10'  MUST PROVIDE 'ALOG' OR 'ALOG10' EACH TIME START IS USED TO INITIALIZE COMMON STATS_ARRAYS_XYZ_TRANSFORM 
;				                TRANSFORM IS NOT NEEDED IN SUBSEQUENT CALLS TO STATS_ARRAYS_XYZ [ASSUMES SAME TRANSFORM APPLIES]
;
;				[XYZ]START:		  MUST PROVIDE /START OR START = 1 (AND X) IN THE FIRST CALL TO STATS_ARRAYS_XYZ TO INITIALIZE THE STATISTICS ARRAYS;
;										    SUBSEQUENT CALLS TO STATS_ARRAYS_XYZ SHOULD NOT PROVIDE START OR SHOULD SET START = 0
;										 
;				[XYZ]CALC:	    CALCULATES STATISTICS AND RETURNS THEM IN A SINGLE STRUCTURE.
;   			              NOTE THAT IF NO DATA ARE PROVIDED AND /CALC IS USED THEN STATISTICS ARE FINALIZED BASED ON ALL PREVIOUS DATA INPUTS.
;										
;				[XYZ]RANGE:     THE ALLOWABLE RANGE [GE,LE] FOR THE DATA TO BE USED IN THE STATISTICAL ARRAYS. 
;				                DEFAULT RANGE IS [-INF,+INF]
;										    NOTE: IF TRANSFORM ='ALOG' OR 'ALOG10', THEN DATA VALUES OF ZERO (0.0) WILL BE IGNORED.
;
;				[XYZ]MISSING:   VALUE TO BE IGNORED IN THE STATISTICS (E.G. -999).
;										    NOTE: THIS ROUTINE WILL ALSO IGNORE ANY DATA VALUES EQUAL TO THE OPERATIONALLY-DEFINED MISSING DATA CODES APPROPRIATE FOR THE DATA DATA TYPE (SEE MISSINGS.PRO)
;
;				[XYZ]STATS:    THE LIST OF STATS YOU WANT
;				               ALLOWED STAT_TYPES = ['NUM','MIN','MAX','SPAN','NEG','WTS','SUM','SSQ','MEAN','STD','CV']
;				             
;										   NOTE: NUM WILL ALWAYS BE DONE EVEN IF NOT REQUESTED.
;										   TO CONSERVE MEMORY MEMORY ARRAYS ARE MADE ONLY FOR THE STATS REQUESTED IN [XYZ]STATS 
;										   IF [XYZ]STATS IS NOT USED THEN [XYZ]STATS WILL BE COMPUTED FOR: ['NUM','MIN','MAX','SPAN','NEG','WTS','SUM','SSQ','MEAN','STD','CV']
;
; OUTPUTS:
;				RETURNS THE CUMULATIVE NUMBER OF CALLS (OR AN ERROR STRING IF ERROR IS ENCOUNTERED)
;				A STRUCTURE WITH STATISTICAL RESULTS IS RETURNED [WHEN /[XYZ]CALC IS SET]
;
; OPTIONAL OUTPUTS:
;	 	    ERROR: ANY ERROR MESSAGES ARE PLACED IN ERROR [AND RETURNED], IF NO ERRORS THEN ERROR = ''
;
; PROCEDURE:
;				THE FIRST CALL TO STATS_ARRAYS_XYZ SHOULD PROVIDE:
;				1) THE [XYZ]DATA AND THE [XYZ]START KEYWORD
;				3) TRANSFORM (IF 'ALOG' OR 'ALOG10') - NOTE STATS ARE ANTILOGGED IN THE OUTPUT STRUCTURE
;				4) [XYZ]RANGE (IF NEEDED) DEFAULT [XYZ]RANGE IS [-INF,+INF]
;				5) [XYZ]MISSING DATA CODE: (IF NEEDED) - DEFAULT IS TO USE CODES FROM MISSINGS.PRO;
;				6) SUBSEQUENT CALLS TO STATS_ARRAYS_XYZ ONLY REQUIRE THE DATA 
;				   ([XYZ]RANGE,[XYZ]MISSING,[XYZ]TRANSFORM	ARE IGNORED AND ASSUMED TO BE THE SAME AS IN THE INITIALLIZING CALL, (WHEN [XYZ]START IS PROVIDED)
;				7) USE /[XYZ]CALC TO RETURN ALL STATS [IN [XYZ]STATS] IN A SINGLE STRUCTURE
;				8) [XYZ]CALC MAY BE USED ANY TIME TO SEE THE RESULTS IN THE STRUCTURE ,EVEN AFTER THE FIRST CALL 
;				
;
; MODIFICATION HISTORY:
; 
;       WRITTEN:  MAR 26, 2018 - J.E.O'REILLY COPIED ELEMENTS FROM STATS_ARRAYS
;       APR 13, 2018 - JEOR: SHORTENED KEYWORDS
;       APR 14, 2018 - JEOR: ADDED CODE FOR RETURNING STATUS
;       APR 15, 2018 - JEOR: ADDED CODE FOR RETURNING STRUCTURE 
;                            IF IDLTYPE(SX) EQ 'STRUCT' AND IDLTYPE(SY) EQ 'STRUCT' AND IDLTYPE(SZ) EQ 'STRUCT' THEN BEGIN
;       APR 17, 2018 - KJWH: Consolidated the X_ARRAYS, Y_ARRAYS and Z_ARRAYS into a single function and now using different COMMON blocks to store the data - NEEDS TO BE VALIDATED - KH
;                            Replace WHERE( ) NE -1 with HAS()
;                            Added IF HAS(STATS_2DO,'MEAN') THEN MEAN_MEM_XYZ = FLTARR(STATS_ARRAYS_SZ_XYZ.DIMENSIONS[0],STATS_ARRAYS_SZ_XYZ.DIMENSIONS[1])
;                            Updated formatting    
;       APR 25, 2018 - KJWH: Consolidated then COMMON variables into a structures 
;                              COMMON COMMON_STATS_ARRAYS, X_STATS_STRUCT, Y_STATS_STRUCT, Z_STATS_STRUCT
;                            The COMMON structures are nulled out each time a new set of stats arrays are calculated (IF KEY(XYZSTART) THEN  are
;                              IF KEY(XYZSTART) THEN BEGIN
;                                IF XYZTYPE EQ 'X' THEN X_STATS_STRUCT = []
;                                IF XYZTYPE EQ 'Y' THEN Y_STATS_STRUCT = []
;                                IF XYZTYPE EQ 'Z' THEN Z_STATS_STRUCT = []
;                              ENDIF
;                            The generic structure is named XYZ and has replaced individual variables (e.g. MEAN_MEM_XYZ) that were previously defined  
;                            Fixed some bugs with the COMMON variables
;       SEP 04, 2019 - KJWH: Added OLD_METHOD to use XYZ_ARRAYS to calculate the stats, otherwise use the updated STATS_ARRAYS, which now includes both MEAN and GMEAN outputs
;                            Using COMMON X, Y and Z structures that are input to STATS_ARRAYS              
;                                    
;-
				 
;#############################################################################################

	ROUTINE='STATS_ARRAYS_XYZ' 

; ===> Common memory structures  
  COMMON COMMON_STATS_STRUCTURES, XSTATS_STRUCT, YSTATS_STRUCT, ZSTATS_STRUCT

; ===> Initialize the structures to NULL before starting the stats programs
  IF KEY(XSTART) THEN XSTATS_STRUCT = []
  IF KEY(YSTART) THEN YSTATS_STRUCT = []
  IF KEY(ZSTART) THEN ZSTATS_STRUCT = []
  
; ===> Calculate the XDATA stats 
  IF ANY(XDATA) THEN BEGIN
    XDAT = XDATA
    
    IF KEY(OLD_METHOD) THEN XX = XYZ_ARRAYS(XYZTYPE='X', XYZDATA=XDATA, XYZTRANSFORM=XTRANSFORM, XYZSTART=XSTART, XYZCALC=XCALC, XYZRANGE=XRANGE, XYZOPER=XOPER, XYZCRITERIA_TXT=XCRITERIA_TXT, XYZMISSING=XMISSING, XYZSTATS=XSTATS, XYZSUBS=XSUBS, XYZERROR=XERROR) $
                       ELSE XX = STATS_ARRAYS(XDAT, STAT_STRUCT=XSTATS_STRUCT, /RETURN_STRUCT, TRANSFORM=XTRANSFORM, START=XSTART, CALC=XCALC, RANGE=XRANGE, OPER=XOPER, CRITERIA_TXT=XCRITERIA_TXT, MISSING=XMISSING, DO_STATS=XSTATS, SUBS=XSUBS, ERROR=XERROR) 
 
    IF IDLTYPE(XX) EQ 'STRUCT' THEN BEGIN
      SX = CREATE_STRUCT('X',XX)
    ENDIF ELSE BEGIN
      IF NONE(YDATA) AND NONE(ZDATA) THEN GOTO,RETURN_INFO
    ENDELSE;IF IDLTYPE(XX) EQ 'STRUCT' THEN BEGIN
  ENDIF;IF ANY(XDATA) THEN BEGIN
;|||||||||||||||||||||||||||||

; ===> Calculate the YDATA stats 
  IF ANY(YDATA) THEN BEGIN
    YDAT = YDATA
    IF KEY(OLD_METHOD) THEN YY = XYZ_ARRAYS(XYZTYPE='Y', XYZDATA=YDATA, XYZTRANSFORM=YTRANSFORM, XYZSTART=YSTART, XYZCALC=YCALC, XYZRANGE=YRANGE, XYZOPER=YOPER, XYZCRITERIA_TXT=YCRITERIA_TXT, XYZMISSING=YMISSING, XYZSTATS=YSTATS, XYZSUBS=YSUBS, XYZERROR=YERROR) $
                       ELSE YY = STATS_ARRAYS(YDAT, STAT_STRUCT=YSTATS_STRUCT, /RETURN_STRUCT, TRANSFORM=YTRANSFORM, START=YSTART, CALC=YCALC, RANGE=YRANGE, OPER=YOPER, CRITERIA_TXT=YCRITERIA_TXT, MISSING=YMISSING, DO_STATS=YSTATS, SUBS=YSUBS, ERROR=YERROR) 
    IF IDLTYPE(YY) EQ 'STRUCT' THEN BEGIN
      SY = CREATE_STRUCT('Y',YY)
    ENDIF ELSE BEGIN
    IF NONE(XDATA) AND NONE(ZDATA) THEN GOTO,RETURN_INFO
    ENDELSE;IF IDLTYPE(XX) EQ 'STRUCT' THEN BEGIN
  ENDIF;IF ANY(YDATA) THEN BEGIN

; ===> Calculate the ZDATA stats 
  IF ANY(ZDATA) THEN BEGIN
    ZDAT = ZDATA
    IF KEY(OLD_METHOD) THEN ZZ = XYZ_ARRAYS(XYZTYPE='Z', XYZDATA=ZDATA, XYZTRANSFORM=ZTRANSFORM, XYZSTART=ZSTART, XYZCALC=ZCALC, XYZRANGE=ZRANGE, XYZOPER=ZOPER, XYZCRITERIA_TXT=ZCRITERIA_TXT, XYZMISSING=ZMISSING, XYZSTATS=ZSTATS, XYZSUBS=ZSUBS, XYZERROR=ZERROR) $
                       ELSE ZZ = STATS_ARRAYS(ZDAT, STAT_STRUCT=ZSTATS_STRUCT, /RETURN_STRUCT, TRANSFORM=ZTRANSFORM, START=ZSTART, CALC=ZCALC, RANGE=ZRANGE, OPER=ZOPER, CRITERIA_TXT=ZCRITERIA_TXT, MISSING=ZMISSING, DO_STATS=ZSTATS, SUBS=ZSUBS, ERROR=ZERROR) 
    IF IDLTYPE(ZZ) EQ 'STRUCT' THEN BEGIN
      SZ = CREATE_STRUCT('Z',ZZ)
    ENDIF ELSE BEGIN
      IF NONE(XDATA) AND NONE(YDATA) THEN GOTO,RETURN_INFO
    ENDELSE;IF IDLTYPE(XX) EQ 'STRUCT' THEN BEGIN
  ENDIF;IF ANY(ZDATA) THEN BEGIN


  RETURN_INFO:
;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  CASE [1] OF
    ;===> RETURN STRUCTURE  
    IDLTYPE(SX) EQ 'STRUCT' AND IDLTYPE(SY) EQ 'STRUCT' AND IDLTYPE(SZ) EQ 'STRUCT': RETURN, CREATE_STRUCT('X',SX.X,'Y',SY.Y,'Z',SZ.Z)
    IDLTYPE(SX) EQ 'STRUCT' AND IDLTYPE(SY) EQ 'STRUCT':                             RETURN, CREATE_STRUCT('X',SX.X,'Y',SY.Y)
    IDLTYPE(SX) EQ 'STRUCT':                                                         RETURN,SX.X
    ELSE: BEGIN
     ;===> RETURN CALLS
     CASE [1] OF 
        ANY(XX) AND ANY(YY) AND ANY(ZZ): RETURN,[XX,YY,ZZ]
        ANY(XX) AND ANY(YY):             RETURN,[XX,YY]
        ANY(XX):                         RETURN,XX
        ANY(YY):                         RETURN,YY
        ANY(ZZ):                         RETURN,ZZ
      ENDCASE;CASE (1) OF
    END
  ENDCASE;CASE (1) OF
;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 
  
    
END; #####################  END OF ROUTINE ################################

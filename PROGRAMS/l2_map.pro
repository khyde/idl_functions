; $ID:	L2_MAP.PRO,	2020-07-08-15,	USER-KJWH	$

	PRO L2_MAP, FILES, DATE_RANGE=date_range, DIR_OUT=dir_out, MAP_OUT=map_out, PX_OUT=px_out, PY_OUT=py_out, $
						  REVERSE_FILES=reverse_files, KEEP_HDF=keep_hdf, OVERWRITE=overwrite, _EXTRA=_extra, ERROR=error

;+
; NAME:
;		L2_2SAVE
;
; PURPOSE:;
;		This function generates mapping information for the L2 files in order to minimize calls to MAP_REMAP
;
; CATEGORY:
;
;
; CALLING SEQUENCE:
;		Write the calling sequence here. Include only positional parameters
;		(i.e., NO KEYWORDS). For procedures, use the form:
;
;		ROUTINE_NAME, Parameter1, Parameter2, Foobar
;
;		Note that the routine name is ALL CAPS and arguments have Initial
;		Caps.  For functions, use the form:
;
;		Result = FUNCTION_NAME(Parameter1, Parameter2, Foobar)
;
; INPUTS:
;		Parm1:	Describe the positional input parameters here. Note again that positional parameters are shown with Initial Caps.
;
; OPTIONAL INPUTS:
;		Parm2:	Describe optional inputs here. If you don't have any, just delete this section.
;
; KEYWORD PARAMETERS:
;		KEY1:	Document keyword parameters like this. Note that the keyword is shown in ALL CAPS!
;
;
; OUTPUTS:
;		This function returns the
;
; OPTIONAL OUTPUTS:  ;
; COMMON BLOCKS:
; SIDE EFFECTS:
; RESTRICTIONS:
;	PROCEDURE:
; EXAMPLE:
;			FILES = FILE_SEARCH('E:\MODIS_TEST\*SEAWIFS*.hdf') & DIR_OUT = 'E:\MODIS_TEST\SAVE\' & MAPS = 'NEC' & PRODS = 'chlor_a'
;			L2_MAP,FILES,DIR_OUT=DIR_OUT,MAP_OUT=MAP_OUT, /OVERWRITE
;
;	NOTES:
;
;
; MODIFICATION HISTORY:
;			Written March 13, 2015 by K.J.W.Hyde, 28 Tarzwell Drive, NMFS, NOAA 02882 (kimberly.hyde@noaa.gov)
;-
;	****************************************************************************************************
	ROUTINE_NAME = 'L2_MAP'

;	===> Initialize ERROR to a null string. If errors are encountered ERROR will be set to a message.
;			 The calling routine can check error (e.g.IF ERROR NE 0 then there was a problem and do this or that)
	ERR_MSG = ''
	ERROR = 0
 	DASH = '-'
 	SL = PATH_SEP()
 
  
; ***** FILE INFO *****
  IF NONE(FILES) THEN BEGIN
    ERR_MSG = 'ERROR: No files provided for L2_2SAVE'
    ERROR = 1
    PRINT, ERR_MSG
    RETURN
  ENDIF  
  
  IF N_ELEMENTS(DATE_RANGE) NE 2 THEN DATE_RANGE = ['19700101000000','21001231235959']
  FILES = DATE_SELECT(FILES,MIN(DATE_RANGE),MAX(DATE_RANGE))
  IF FILES EQ [] THEN GOTO, DONE
  IF KEY(REVERSE_FILES) THEN FILES = REVERSE(FILES)
  FP = PARSE_IT(FILES,/ALL)

; ***** MAP INFO *****    
  IF NONE(MAP_OUT)               THEN _MAP_OUT   = 'NEC' ELSE _MAP_OUT  = MAP_OUT
	IF KEY(PX_OUT) OR KEY(PY_OUT) THEN BEGIN
		IF NOT KEY(MAP_OUT) THEN STOP
		IF N_ELEMENTS(MAP_OUT) GT 1 OR N_ELEMENTS(PX_OUT) GT 1 OR N_ELEMENTS(PY_OUT) GT 1 THEN STOP
	ENDIF
	OK = WHERE(VALID_MAPS(_MAP_OUT,/VALID) EQ 1,COUNT_MAPS)
	IF COUNT_MAPS GE 1 THEN _MAP_OUT=_MAP_OUT[OK] ELSE STOP  ; ===> Verify that the output maps and products are valid
  
; ***** OUTPUT DIRECTORIES *****
  DIRS_OUT = []
  IF NONE(DIR_OUT) THEN FOR M=0, N_ELEMENTS(_MAP_OUT)-1 DO DIRS_OUT = [DIRS_OUT,     REPLACE(FP[0].DIR,FP[0].SUB,_MAP_OUT(M) + SL + 'MAP_INFO')] ELSE DIRS_OUT = DIR_OUT
  IF N_ELEMENTS(DIRS_OUT)     NE N_ELEMENTS(_MAP_OUT) THEN DIRS_OUT = REPLICATE(DIRS_OUT[0], N_ELEMENTS(_MAP_OUT))
  DIR_TEST,DIRS_OUT
    
; ***** Loop through files *****
	FOR NTH=0L, N_ELEMENTS(FILES)-1 DO BEGIN
		AFILE    = FILES[NTH]		
		
		MAPCOUNT = 0
		FOR MTH = 0L, N_ELEMENTS(_MAP_OUT)-1 DO BEGIN
			AMAP = _MAP_OUT(MTH)
			EXCLUDE_TXT = 'NO DATA WITHIN MAP (' + AMAP + ')'
      _DIR_OUT     = DIRS_OUT(MTH)
      MAPFILE = _DIR_OUT + FP[NTH].NAME  + DASH + AMAP + '.SAV'
   		IF FILE_MAKE(AFILE,MAPFILE,OVERWRITE=OVERWRITE) EQ 0 THEN CONTINUE
   		
      IF MAPCOUNT EQ 0 THEN BEGIN ; ===> Only need to unzip and read the HDF once
     		FN = FILE_PARSE(AFILE)
        IF STRUPCASE(FN.EXT) EQ 'GZ' OR STRUPCASE(FN.EXT) EQ 'BZ2' THEN BEGIN  ; ===> If file is zipped, then upzip
    			ZIP,FILES=AFILE,DIR_OUT=FN.DIR
    			AFILE = FN.DIR + FN.NAME                                             ; ===> Make the unzipped file AFILE
       	 	REMOVE_FILE = AFILE
        ENDIF
      
  ;		  ***** Read the GLOBAL info *****
        PRINT, 'Reading file (' + NUM2STR(NTH+1) + ' of ' + NUM2STR(N_ELEMENTS(FILES)) + '): ' + AFILE    
        GLOBAL = READ_HDF_2STRUCT(AFILE,PRODUCTS='GLOBAL',ERROR=ERROR,ERR_MSG=ERR_MSG) ;;;;;;;;;;;;;;;;;;;; Will need to change to READ_NC
        IF ERROR EQ 1 THEN BEGIN
          PRINT, ERR_MSG
          CONTINUE
        ENDIF
        MIN_LON = GLOBAL.GLOBAL.EASTERNMOST_LONGITUDE
        MAX_LON = GLOBAL.GLOBAL.WESTERNMOST_LONGITUDE
        MIN_LAT = GLOBAL.GLOBAL.SOUTHERNMOST_LATITUDE
        MAX_LAT = GLOBAL.GLOBAL.NORTHERNMOST_LATITUDE
      ENDIF ; IF MAPCOUNT EQ 0 THEN BEGIN
      MAPCOUNT = 1  

;     ***** See if the file has data within the map domain *****
      LL=MAPS_2LONLAT(AMAP) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CAN THIS INFO BE STORED IN A COMMON BLOCK???????????????????
      OK_WITHIN_MAP_OUT = WHERE(LL.LON GE MIN_LON AND LL.LON LE MAX_LON AND $
                                LL.LAT GE MIN_LAT AND LL.LAT LT MAX_LAT,COUNT,NCOMPLEMENT=N_OUTSIDE_MAP_OUT,COMPLEMENT=OUTSIDE_MAP_OUT)
     
      IF COUNT EQ 0 THEN BEGIN ; ===> If no data found within the map area, make EXCLUDE = 1 and continue
        STRUCT = CREATE_STRUCT('FILENAME',AFILE,'MAP',AMAP,'EXCLUDE',1L,'ERROR','NO DATA WITHIN MAP','TIME',DATE_NOW())
        SAVE,FILENAME=MAPFILE,STRUCT
        CONTINUE
      ENDIF
      
;     ***** Get LON/LAT info from HDF file and mapping parameters from MAP_REMAP *****      
      STRUCT  = READ_HDF_2STRUCT(AFILE,PRODUCTS=['LONGITUDE','LATITUDE'],ERROR=ERROR,ERR_MSG=ERR_MSG) ;;;;;;;;;;;;;;;; WILL NEED TO CHANGE TO READ_NC
      IN_LONS  = STRUCT.SD.LONGITUDE.IMAGE
      IN_LATS  = STRUCT.SD.LATITUDE.IMAGE
      CTL_LONS = STRUCT.SD.CNTL_PT_COLS.IMAGE
      CTL_LATS = STRUCT.SD.CNTL_PT_ROWS.IMAGE
      IMG      = IN_LONS & IMG(*,*) = MISSINGS(0.0)
      MAPPED_IMAGE = MAP_REMAP(IMG,MAP_IN='LONLAT',MAP_OUT=AMAP,CONTROL_LONS=IN_LONS,CONTROL_LATS=IN_LATS,CONTROL_SUBS_LON=CTL_LONS,CONTROL_SUBS_LAT=CTL_LATS,REFRESH=REFRESH,PX_OUT=_PX_OUT,PY_OUT=_PY_OUT)

;;;;; HAVE MAP_REMAP RETURN MAPPING INFORMATION FOR THE PARTICULAR MAP AND LONLAT DATA THAT CAN BE SAVED AND USED IN THE FUTURE TO SAVE TIME WHEN REMAPPING NEW OTHER FROM THE SAME HDF   
      
      STRUCT = CREATE_STRUCT('FILENAME',AFILE,'MAP',AMAP,'EXCLUDE',0L,'ERROR','','TIME',DATE_NOW()) ; ADD MAP INFO TO SAVE STRUCTURE
      SAVE,FILENAME=MAPFILE,STRUCT 
    ENDFOR ; FOR MTH = 0L, N_ELEMENTS(_MAP_OUT)-1 DO BEGIN        
STOP
    
	
;   ***** Retrieve the LATITUDE/LONGITUDE *****
    PRINT, 'Retrieving latitude, longitude and control points'
    

		LON_MIN=NUM2STR(ROUND(MIN(IN_LONS)-0.5))
		LON_MAX=NUM2STR(ROUND(MAX(IN_LONS)+0.5))
		LAT_MIN=NUM2STR(ROUND(MIN(IN_LATS)-0.5))
		LAT_MAX=NUM2STR(ROUND(MAX(IN_LATS)+0.5))

		LON_MIN=REPLACE(LON_MIN,'-','W')
		LON_MAX=REPLACE(LON_MAX,'-','W')
		LAT_MIN=REPLACE(LAT_MIN,'-','S')
		LAT_MAX=REPLACE(LAT_MAX,'-','S')

		SZ=SIZE(IN_LONS,/STRUCT)
		L2_PX=SZ.DIMENSIONS[0]
		L2_PY=SZ.DIMENSIONS[1]		

		FLAGS_IMAGE=''
		OK = WHERE(TAGS EQ 'L2_FLAGS',COUNT)
		IF COUNT EQ 1  THEN FLAGS_IMAGE = STRUCT.SD.L2_FLAGS.IMAGE

		IF QUAL NE [] THEN BEGIN
			OK_QUAL = WHERE(TAGS EQ QUAL,COUNT)
			IF COUNT EQ 1 THEN QUAL_IMAGE = STRUCT.SD.(OK_QUAL).IMAGE
		ENDIF
		GONE,STRUCT

;		***** Loop through each map *****
		FOR MTH = 0L, N_ELEMENTS(_MAP_OUT)-1 DO BEGIN
		; REFRESH COMMON MEMORY FOR MAP_REMAP OF EACH NEW MAP
			REFRESH = 1
      AMAP = _MAP_OUT(MTH)
      _DIR_OUT = DIRS_OUT(MTH)
      
			OUTPUT_LABEL = INAME + dash + COVERAGE + dash + AMAP
      IF NOT KEYWORD_SET(NO_EXCLUDE) THEN BEGIN      
        EXCLUDE_FILE=_DIR_EXCLUDE + OUTPUT_LABEL  + '.TXT'
        IF FILE_TEST(EXCLUDE_FILE) EQ 1 AND GET_MTIME(EXCLUDE_FILE) GT GET_MTIME(AFILE) THEN CONTINUE
      ENDIF

			; check if any saves need to be done for AMAP
			DO_SAVE=0
			; check for L2 save containing LATS,LONS and SUBS arrays
			IF AMAP EQ 'LONLAT' THEN BEGIN
			  LONLAT_SAVE=_DIR_OUT+OUTPUT_LABEL+dash+'LON_'+LON_MIN+'_'+LON_MAX+dash+'LAT_'+LAT_MIN+'_'+LAT_MAX+'.SAVE'				
	      IF GET_MTIME(LONLAT_SAVE) LT FI_IN.MTIME OR KEYWORD_SET(OVERWRITE) THEN DO_SAVE = DO_SAVE + 1
			ENDIF
			
			ALG_TEST  = VALID_ALG_CHECK(IN_PROD=STRUPCASE(_PRODS),OUT_PROD=OUTPRODS,SENSOR=REPLICATE(SENSOR,N_ELEMENTS(_PRODS)),ALG=ALG)
      SAVEFILES = _DIR_OUT + OUTPRODS + dash + ALG + SL + OUTPUT_LABEL + dash + OUTPRODS + dash + ALG + '.SAVE'           
      OK = WHERE(ALG EQ '',COUNT)
      IF COUNT GE 1 THEN SAVEFILES[OK] = REPLACE(SAVEFILES[OK],[dash+SL,dash+dash,dash+'.'],[SL,dash,'.'])
      OK = WHERE(FILE_TEST(SAVEFILES) EQ 0 OR GET_MTIME(SAVEFILES) LT FI_IN.MTIME,COUNT)
      IF COUNT EQ 0 AND NOT KEYWORD_SET(OVERWRITE) THEN CONTINUE
      IF NOT KEYWORD_SET(OVERWRITE) THEN BEGIN
        SAVEFILES = SAVEFILES[OK]
        _PRODS = _PRODS[OK]
        ALG  = ALG[OK]
      ENDIF  
      
;     ***** Check for output directories *****
      DIR_FP = FILE_PARSE(SAVEFILES)
      FOR DFP = 0, N_ELEMENTS(DIR_FP)-1 DO IF FILE_TEST(DIR_FP(DFP).DIR,/DIR) EQ 0 THEN FILE_MKDIR, DIR_FP(DFP).DIR 
      

			SZ = MAPS_SIZE(AMAP)
			IF N_ELEMENTS(PX_OUT) EQ 0 THEN _PX_OUT = SZ.PX ELSE _PX_OUT = PX_OUT
			IF N_ELEMENTS(PY_OUT) EQ 0 THEN _PY_OUT = SZ.PY ELSE _PY_OUT = PY_OUT

;			***** Read the standard landmask for this map *****
			STRUCT_LANDMASK = READ_LANDMASK(MAP=AMAP,/STRUCT,ERROR=ERROR)
			IF ERROR NE '' THEN BEGIN
				COUNT_LAND = 0
				COUNT_OCEAN =0
			ENDIF ELSE BEGIN
	  		OK_LAND     = STRUCT_LANDMASK.LAND
	  		COUNT_LAND  = STRUCT_LANDMASK.COUNT_LAND
				OK_OCEAN    = STRUCT_LANDMASK.OCEAN
	  		COUNT_OCEAN = STRUCT_LANDMASK.COUNT_OCEAN
	  		GONE, STRUCT_LANDMASK
			ENDELSE

;			***** Get FLAG information *****
			COUNT_L2_FLAGS=0
			IF FLAGS_IMAGE[0] NE '' THEN BEGIN
				_FLAGS_IMAGE=FLAGS_IMAGE
				_AMAP = AMAP
				IF MAP NE AMAP THEN $
			  	_FLAGS_IMAGE = MAP_REMAP(_FLAGS_IMAGE,MAP_IN=MAP,MAP_OUT=AMAP,CONTROL_LONS=IN_LONS,CONTROL_LATS=IN_LATS,CONTROL_SUBS_LON=CTL_LONS,CONTROL_SUBS_LAT=CTL_LATS,REFRESH=REFRESH,PX_OUT=_PX_OUT,PY_OUT=_PY_OUT)
        IF AMAP NE _AMAP THEN AMAP = _AMAP  
	      OUT_OF_SCAN =WHERE(_FLAGS_IMAGE EQ MISSINGS(_FLAGS_IMAGE),COUNT_OUT_OF_SCAN)
	      FLAGS_NAMES = SD_FLAGS(_FLAGS_IMAGE,SENSOR=SENSOR,/NAMES)
	  		MASK_FLAG = SD_FLAGS_COMBO(_FLAGS_IMAGE,FLAG_BITS)
	      OK_L2_FLAGS =WHERE(MASK_FLAG NE 0, COUNT_L2_FLAGS)
				IF WHERE(_PRODS EQ 'SST') GE 0 OR WHERE(_PRODS EQ 'SST4') GE 0 THEN COUNT_L2_FLAGS=0
	      GONE, _FLAGS_IMAGE
	      REFRESH = 0
	    ENDIF; IF FLAGS_IMAGE(0) NE '' THEN BEGIN

;   	*****  SST QUAL MASK *****
			IF QUAL NE [] THEN BEGIN
				_QUAL_IMAGE = QUAL_IMAGE
				_AMAP = AMAP
        IF MAP NE AMAP THEN $
          _QUAL_IMAGE = MAP_REMAP(_QUAL_IMAGE,MAP_IN='LONLAT',MAP_OUT=AMAP,CONTROL_LONS=IN_LONS,CONTROL_LATS=IN_LATS,CONTROL_SUBS_LON=CTL_LONS,CONTROL_SUBS_LAT=CTL_LATS,REFRESH=REFRESH,PX_OUT=_PX_OUT,PY_OUT=_PY_OUT)
        IF AMAP NE _AMAP THEN AMAP = _AMAP
				IF REFRESH EQ 1 THEN REFRESH=0

       	OK_QUAL_0 = WHERE(_QUAL_IMAGE EQ 0, COUNT_QUAL_0)
       	OK_QUAL_1 = WHERE(_QUAL_IMAGE EQ 1, COUNT_QUAL_1)
       	OK_QUAL_2 = WHERE(_QUAL_IMAGE EQ 2, COUNT_QUAL_2)
       	OK_QUAL_3 = WHERE(_QUAL_IMAGE EQ 3, COUNT_QUAL_3)
       	OK_QUAL_4 = WHERE(_QUAL_IMAGE EQ 4, COUNT_QUAL_4)

;    		*****  Make Mask for STRUCT_SD  *****
				MASK=BYTE(_QUAL_IMAGE) & MASK(*,*)=0B
				GONE,_QUAL_IMAGE

;    		===> NOT_MASK (good data , 0b)
    		CODE_NAME = 'NOT_MASK'
    		CODE_MASK = 0B
    		CODE_NAME_MASK=[CODE_NAME]

        CODE_NAME = 'NOT_MASK'
        ACODE = 1B
        CODE_MASK = [CODE_MASK,ACODE]
        CODE_NAME_MASK = [CODE_NAME_MASK, CODE_NAME]
        IF COUNT_QUAL_1 GE 1 THEN MASK(OK_QUAL_1) = ACODE

				CODE_NAME = 'SUSPECT_SST'
        ACODE = 2B
        CODE_MASK = [CODE_MASK,ACODE]
        CODE_NAME_MASK = [CODE_NAME_MASK, CODE_NAME]
        IF COUNT_QUAL_2 GE 1 THEN MASK(OK_QUAL_2) = ACODE
        NOTES = 'Quality code 2 masked as SUSPECT_SST'

				CODE_NAME = 'BAD_SST'
        ACODE = 3B
        CODE_MASK = [CODE_MASK,ACODE]
        CODE_NAME_MASK = [CODE_NAME_MASK, CODE_NAME]
        IF COUNT_QUAL_3 GE 1 THEN MASK(OK_QUAL_3) = ACODE

				CODE_NAME = 'SST_FAIL'
        ACODE = 4B
        CODE_MASK = [CODE_MASK,ACODE]
        CODE_NAME_MASK = [CODE_NAME_MASK, CODE_NAME]
        IF COUNT_QUAL_4 GE 1 THEN MASK(OK_QUAL_4) = ACODE

;    		===> L2_FLAGS
    		CODE_NAME = 'L2_FLAGS'
    		ACODE = 5B
    		CODE_MASK     =[CODE_MASK,ACODE]
    		CODE_NAME_MASK=[CODE_NAME_MASK,CODE_NAME]
    		IF COUNT_L2_FLAGS GE 1 THEN MASK(OK_L2_FLAGS) = ACODE

;    		===> LAND
    		CODE_NAME = 'LAND'
    		ACODE = 6B
    		CODE_MASK     =[CODE_MASK,ACODE]
    		CODE_NAME_MASK=[CODE_NAME_MASK,CODE_NAME]
    		IF COUNT_LAND GE 1 THEN MASK(OK_LAND) = ACODE

			ENDIF; IF ALG EQ '4UM' OR ALG EQ '11UM' THEN BEGIN

;			***** Loop through each product *****
			FOR PTH = 0L, N_ELEMENTS(_PRODS)-1 DO BEGIN
				APROD = STRUPCASE(_PRODS(PTH))
				AALG  = ALG(PTH) 
				OUTPROD = OUTPRODS(PTH)
				SAVEFILE = SAVEFILES(PTH)
				        
;	  		***** Check which PRODs need saves made *****				
	      IF GET_MTIME(SAVEFILE) GT FI_IN.MTIME AND NOT KEYWORD_SET(OVERWRITE) THEN CONTINUE

		    STRUCT = READ_HDF_2STRUCT(AFILE,PRODUCTS=APROD,ERROR=ERROR,ERR_MSG=ERR_MSG)
				IF ERROR EQ 1 THEN BEGIN					
					PRINT,ERR_MSG
					CONTINUE 
				ENDIF

				NAMES = STRUPCASE(TAG_NAMES(STRUCT.SD))
				OK_PROD = WHERE(STRUPCASE(NAMES) EQ APROD, COUNT_PROD)

				IF COUNT_PROD EQ 1 THEN IMG = STRUCT.SD.(OK_PROD).IMAGE ELSE CONTINUE

;       ***** Remap ARRAY to output map *****
				_AMAP = AMAP
				IF AMAP NE MAP THEN $
					IMG = MAP_REMAP(IMG,MAP_IN='LONLAT',MAP_OUT=AMAP,CONTROL_LONS=IN_LONS,CONTROL_LATS=IN_LATS,CONTROL_SUBS_LON=CTL_LONS,CONTROL_SUBS_LAT=CTL_LATS,REFRESH=REFRESH,PX_OUT=_PX_OUT,PY_OUT=_PY_OUT)
        IF AMAP NE _AMAP THEN AMAP = _AMAP  
				IF REFRESH EQ 1 THEN REFRESH=0

				LONG_NAME=''
				DATA_UNITS=''
	  		BAD_VALUE_UNSCALED=[]
	  		BAD_VALUE_SCALED=[]

				TAGNAMES= TAG_NAMES(STRUCT.SD.(OK_PROD))
				OK=WHERE(STRUPCASE(TAGNAMES) EQ 'DATA_UNITS',COUNT)
				IF COUNT EQ 1 THEN DATA_UNITS=STRUCT.SD.(OK_PROD).UNITS[0]
				OK=WHERE(STRUPCASE(TAGNAMES) EQ 'LONG_NAME',COUNT)
				IF COUNT EQ 1 THEN 	LONG_NAME=STRUCT.SD.(OK_PROD).LONG_NAME[0]
				OK=WHERE(STRUPCASE(TAGNAMES) EQ 'BAD_VALUE_UNSCALED',COUNT)
				IF COUNT EQ 1 THEN 	BAD_VALUE_UNSCALED=STRUCT.SD.(OK_PROD).BAD_VALUE_UNSCALED[0]
				OK=WHERE(STRUPCASE(TAGNAMES) EQ 'BAD_VALUE_UNSCALED',COUNT)
				IF COUNT EQ 1 THEN 	BAD_VALUE_SCALED=STRUCT.SD.(OK_PROD).BAD_VALUE_SCALED[0] ELSE BAD_VALUE_SCALED = ''
	 ; 		NOTES=['BAD_VALUE_UNSCALED:   '+NUM2STR(BAD_VALUE_UNSCALED)]

				;  REPRO 5 does not have same tags as REPRO6				
				IF STRPOS(AALG,'4UM')EQ -1 AND STRPOS(AALG,'11UM') THEN BEGIN
					IF APROD NE 'L2_FLAGS' THEN BEGIN
					; check scaled image for  BAD_VALUE_SCALED
						COUNT_BAD=0
						IF BAD_VALUE_SCALED NE [] THEN OK_BAD=WHERE(IMG EQ BAD_VALUE_SCALED,COUNT_BAD)
						IF COUNT_BAD GE 1 THEN IMG(OK_BAD) = MISSINGS(IMG)
					ENDIF
					; set flagged pixels to missings
					IF APROD NE 'L2_FLAGS' AND APROD NE 'PAR' AND APROD NE 'SENZ' AND APROD NE 'SST' AND APROD NE 'SST4' THEN BEGIN
						IF NOT KEYWORD_SET(NOFLAG) AND COUNT_L2_FLAGS GE 1 THEN IMG(OK_L2_FLAGS)=MISSINGS(IMG)
					ENDIF
				ENDIF

			;	IF COUNT_OUT_OF_SCAN GE 1 THEN IMAGE(OUT_OF_SCAN)=MISSINGS(IMAGE)
				IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
					OK_GOOD=WHERE(IMG GT -32767 AND IMG LT MISSINGS(IMG) ,COUNT_GOOD)
				ENDIF ELSE BEGIN
					OK_GOOD=WHERE(IMG NE MISSINGS(IMG),COUNT_GOOD)
				ENDELSE
			; apply slope & intercept to get data values

				IF OUTPROD NE 'L2_FLAGS' THEN BEGIN
					DATA=FLOAT(IMG)
					DATA(0:*) = MISSINGS(0.0)
					IF COUNT_GOOD GE 1 THEN DATA(OK_GOOD)=IMG(OK_GOOD) * STRUCT.SD.(OK_PROD).SLOPE[0] + STRUCT.SD.(OK_PROD).INTERCEPT[0]
					IMG=DATA
					GONE, DATA
				ENDIF

				IF APROD EQ 'CHLOR_A' OR APROD EQ 'POC' OR APROD EQ 'DOC' OR APROD EQ 'A_CDOM' THEN BEGIN
					OK=WHERE(IMG LE 0,COUNT)
					IF COUNT GE 1 THEN IMG[OK] = MISSINGS(0.0)
				ENDIF

				IF NOT KEYWORD_SET(NO_EXCLUDE) THEN BEGIN ; Check if this belongs in the exclude folder
					OK=WHERE(IMG NE MISSINGS(IMG),COUNT)
					IF COUNT LT N_EXCLUDE THEN BEGIN
						EXCLUDE_TEXT='INPUT FILE: '+AFILE+'     CONTAINED LESS THAN '+NUM2STR(N_EXCLUDE) + ' GOOD DATA PIXELS FOR MAP: ' + AMAP
					; Write text to exclude folder
					  WRITE_EXCLUDE:
            PRINT, EXCLUDE_TEXT					  
						WRITE_TXT,EXCLUDE_FILE, EXCLUDE_TEXT
						GONE,DATA
						GONE,IMG
						GONE,STRUCT
						GOTO,DONE_PRODS
					ENDIF
				ENDIF

				SCALING='linear'
				SLOPE=1.0
				INTERCEPT=0.0

				ASTAT='DATA'
				MISSING_CODES=MISSINGS(0.0)
    		IF OUTPROD EQ 'L2_FLAGS' THEN MISSING_CODES=''
    		MISSING_NAMES=[STRTRIM(MISSING_CODES,2)]
				IF N_ELEMENTS(MISSING_CODES) NE N_ELEMENTS(MISSING_NAMES) THEN MISSING_NAMES=REPLICATE('',N_ELEMENTS(MISSING_CODES))

				IF AMAP EQ 'LONLAT' THEN BEGIN
					OK=WHERE(STRUPCASE(TAG_NAMES(STRUCT)) EQ 'GLOBAL',COUNT)
					IF COUNT EQ 1 THEN BEGIN
						_GLOBAL=STRUCT.GLOBAL
						_INPUT_PARAMETERS=STRSPLIT(_GLOBAL.INPUT_PARAMETERS,BYTE(10),/EXTRACT)
						_L2_INPUT_FILES= STRSPLIT(_GLOBAL.INPUT_FILES,',',/EXTRACT)
					ENDIF
				ENDIF

       	IF KEYWORD_SET(STRUCT_RETURN) THEN BEGIN
       	; THIS WORKS FOR A SINGLE FILE,RETURN STRUCT_RETURN TO THE CALLING PROGRAM
       		IF AMAP EQ 'LONLAT' THEN BEGIN
	          	IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
	          		STRUCT_RETURN=STRUCT_SD_MAKE(IMG,FILE_NAME=SAVEFILE,PROD=APROD, ASTAT=ASTAT,GLOBAL=_GLOBAL,$
	          				 INPUT_PARAMETERS=_INPUT_PARAMETERS, 	L2_INPUT_FILES=_L2_INPUT_FILES,$
	                   MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
	                   MASK=MASK,     CODE_MASK=CODE_MASK,    CODE_NAME_MASK=CODE_NAME_MASK, $
	                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
	                   PERIOD=FN.PERIOD, ALG=AALG,$
	                   SENSOR=SENSOR,    SATELLITE=SATELLITE, SAT_EXTRA=SAT_EXTRA,$
	                   METHOD=METHOD,   SUITE=SUITE,          MAP=_MAP, $
	                   INFILE=FN.FULLNAME,$
	                   NOTES=NOTES, ERROR=ERROR, $
	                   LONS=IN_LONS, LATS=IN_LATS,CTL_LONS=CTL_LONS,CTL_LATS=CTL_LATS)
							ENDIF ELSE BEGIN
	          		STRUCT_RETURN=STRUCT_SD_MAKE(IMG,FILE_NAME=SAVEFILE,PROD=APROD, ASTAT=ASTAT,GLOBAL=_GLOBAL,$
	          				 INPUT_PARAMETERS=_INPUT_PARAMETERS, 	L2_INPUT_FILES=_L2_INPUT_FILES,$
	                   MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
	                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
	                   PERIOD=FN.PERIOD, ALG=AALG,$
	                   SENSOR=SENSOR,    SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
	                   METHOD=METHOD,   SUITE=SUITE,          MAP=AMAP, $
	                   INFILE=FN.FULLNAME,$
	                   NOTES=NOTES, ERROR=ERROR, $
	                   LONS=IN_LONS, LATS=IN_LATS,CTL_LONS=CTL_LONS,CTL_LATS=CTL_LATS)
							ENDELSE;IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
					ENDIF ELSE BEGIN;	IF AMAP EQ 'LONLAT' THEN BEGIN
						IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
          		STRUCT_RETURN=STRUCT_SD_MAKE(IMG,FILE_NAME=SAVEFILE,PROD=APROD, ASTAT=ASTAT,$
                   MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
                   MASK=MASK,     CODE_MASK=CODE_MASK,    CODE_NAME_MASK=CODE_NAME_MASK, $
                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
                   PERIOD=FN.PERIOD, ALG=AALG,$
                   SENSOR=SENSOR,    SATELLITE=SATELLITE, SAT_EXTRA=SAT_EXTRA,$
                   METHOD=METHOD,   SUITE=SUITE,          MAP=_MAP, $
                   INFILE=FN.FULLNAME,$
                   NOTES=NOTES, ERROR=ERROR)
						ENDIF ELSE BEGIN
							STRUCT_RETURN=STRUCT_SD_MAKE(IMG,FILE_NAME=SAVEFILE,PROD=OUTPROD, ASTAT=ASTAT,$
				   					MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
                   PERIOD=FN.PERIOD,   SENSOR=SENSOR,       SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
                   METHOD=METHOD,   ALG=AALG,  MAP=AMAP, $
                   INFILE=FN.FULLNAME,$
                   NOTES=NOTES,ERROR=ERROR)
						ENDELSE;IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
					ENDELSE;IF AMAP EQ 'LONLAT' THEN BEGIN
					IF N_ELEMENTS(FILES) EQ 1 AND KEYWORD_SET(STRUCT_RETURN) THEN BEGIN
						IF NOT KEYWORD_SET(KEEP_HDF) AND REMOVE_FILE NE '' THEN FILE_DELETE,REMOVE_FILE
					ENDIF
					GOTO,DONE
       	ENDIF ELSE BEGIN;IF KEYWORD_SET(STRUCT_RETURN) THEN BEGIN
		      IF AMAP EQ 'LONLAT' THEN BEGIN ; WRITE OUT LONLAT save with LONS & LATS if it does not exist						       		 	
	      		IF GET_MTIME(LONLAT_SAVE) LT FI_IN.MTIME OR KEYWORD_SET(OVERWRITE) THEN BEGIN
	      			DUMMY=''
	      			STRUCT_LONLAT=STRUCT_SD_MAKE(DUMMY,FILE_NAME=LONLAT_SAVE,PROD='LONLAT',GLOBAL=_GLOBAL,$
          				 INPUT_PARAMETERS=_INPUT_PARAMETERS, 	L2_INPUT_FILES=_L2_INPUT_FILES,$
                   PERIOD=FN.PERIOD,$
                   SENSOR=SENSOR,    SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
                   METHOD=METHOD,   SUITE=SUITE, MAP=AMAP, $
                   INFILE=FN.FULLNAME,$
                   NOTES=NOTES, ERROR=ERROR, $
                   LONS=IN_LONS, LATS=IN_LATS,CTL_LONS=CTL_LONS,CTL_LATS=CTL_LATS)
							SAVE,FILENAME=LONLAT_SAVE,STRUCT_LONLAT,/COMPRESS
	      		ENDIF
						IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
							STRUCT_SD_WRITE,SAVEFILE,PROD=APROD, ASTAT=ASTAT,$
		                   IMAGE=IMG,     MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
		                   MASK=MASK,     CODE_MASK=CODE_MASK,    CODE_NAME_MASK=CODE_NAME_MASK, $
		                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
		                   PERIOD=FN.PERIOD,   SENSOR=SENSOR,       SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
		                   METHOD=METHOD,   ALG=AALG,  MAP=AMAP, $
		                   INFILE=FN.FULLNAME,LONLAT_FILE=LONLAT_SAVE,$
		                   NOTES=NOTES,ERROR=ERROR
						ENDIF ELSE BEGIN
		        	STRUCT_SD_WRITE,SAVEFILE,PROD=APROD, ASTAT=ASTAT,$
		                   IMAGE=IMG,     MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
		                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
		                   PERIOD=FN.PERIOD,   SENSOR=SENSOR,       SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
		                   METHOD=METHOD,   ALG=AALG,  MAP=AMAP, $
		                   INFILE=FN.FULLNAME,LONLAT_FILE=LONLAT_SAVE,$
		                   NOTES=NOTES,ERROR=ERROR
		      	ENDELSE
		      ENDIF ELSE BEGIN;IF AMAP EQ 'LONLAT' THEN BEGIN
		      	IF APROD EQ 'SST' OR APROD EQ 'SST4' THEN BEGIN
							STRUCT_SD_WRITE,SAVEFILE,PROD=OUTPROD, ASTAT=ASTAT,$
		                   IMAGE=IMG,     MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
		                   MASK=MASK,     CODE_MASK=CODE_MASK,    CODE_NAME_MASK=CODE_NAME_MASK, $
		                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
		                   PERIOD=FN.PERIOD,   SENSOR=SENSOR,       SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
		                   METHOD=METHOD,   ALG=ALG,  MAP=AMAP, $
		                   INFILE=FN.FULLNAME,$
		                   NOTES=NOTES,ERROR=ERROR
		      	ENDIF ELSE BEGIN
		      		STRUCT_SD_WRITE,SAVEFILE,PROD=OUTPROD, ASTAT=ASTAT,$
		                   IMAGE=IMG,     MISSING_CODE=missing_codes,MISSING_NAME=missing_names, $
		                   SCALING=SCALING, INTERCEPT=INTERCEPT,    SLOPE=SLOPE,       DATA_UNITS=DATA_UNITS,$
		                   PERIOD=FN.PERIOD,   SENSOR=SENSOR,       SATELLITE=FN.SATELLITE, SAT_EXTRA=SAT_EXTRA,$
		                   METHOD=METHOD,   ALG=AALG,  MAP=AMAP, $
		                   INFILE=FN.FULLNAME,$
		                   NOTES=NOTES,ERROR=ERROR
		      	ENDELSE
		      ENDELSE;IF AMAP EQ 'LONLAT' THEN BEGIN
	      ENDELSE
				GONE, IMG
			ENDFOR 		; End PROD loop
      DONE_PRODS:
  	ENDFOR	; End MAP loop


		IF NOT KEYWORD_SET(KEEP_HDF) AND REMOVE_FILE NE '' THEN FILE_DELETE,REMOVE_FILE,/QUIET
		GONE, STRUCT
		GONE, IN_LONS
    GONE, IN_LATS
    GONE, CTL_LONS
    GONE, CTL_LATS
	ENDFOR			; End FILE loop
	DONE:
END; #####################  End of Routine ################################

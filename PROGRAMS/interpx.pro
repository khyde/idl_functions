; $ID:	INTERPX.PRO,	2020-06-30-17,	USER-KJWH	$
;-------------------------------------------------------------
;+
; NAME:
;       INTERPX
; PURPOSE:
;       INTERPOLATE DATA WITH POSSIBLE GAPS AND MISSING (BAD) VALUES.
; CATEGORY:
; CALLING SEQUENCE:
;       YY = INTERPX(X,Y,XX)
; INPUTS:
;       X,Y = INPUT POINTS.            IN
;         X IS ASSUMED MONOTONICALLY INCREASING.
;       XX = DESIRED X VALUES.         IN
;         XX NEED NOT BE MONOTONICALLY INCREASING.
; KEYWORD PARAMETERS:
;       KEYWORDS:
;         BAD=B  VALUES GREATER THAN B ARE CONSIDERED MISSING.
;         GAP=G  GAPS IN X GREATER THAN OR EQUAL TO THIS
;           ARE BROKEN BY SETTING THE OUTPUT CURVE POINTS
;           IN THE GAPS TO A FLAG VALUE OF 32000 OR BAD IF GIVEN.
;         /FIXBAD  MEANS INTERPOLATE ACROSS BAD DATA BETWEEN
;           CLOSEST GOOD POINTS ON EACH SIDE.  OTHERWISE THE
;           BAD POINTS ARE FLAGGED WITH THE VALUE SPECIFIED
;           FOR BAD.
; OUTPUTS:
;       YY = INTERPOLATED Y VALUES.    OUT
; COMMON BLOCKS:
; NOTES:
;       NOTES: FLAGGED VALUES MAY BE USED TO BREAK A PLOTTED
;          CURVE USING MAX_VALUE IN THE PLOT OR OPLOT COMMAND:
;          PLOT,X,Y,MAX_VALUE=999
;          SLOW FOR MORE THAN A FEW THOUSAND POINTS.
; MODIFICATION HISTORY:
;       R. STERNER, 12 AUG, 1993
;       SEP 13, 2019 - KJWH: Changed DATATYPE(Y,2) to IDLTYPE(Y,/CODE) to remove the obsolete DATATYPE code
;
; COPYRIGHT (C) 1993, JOHNS HOPKINS UNIVERSITY/APPLIED PHYSICS LABORATORY
; THIS SOFTWARE MAY BE USED, COPIED, OR REDISTRIBUTED AS LONG AS IT IS NOT
; SOLD AND THIS COPYRIGHT NOTICE IS REPRODUCED ON EACH COPY MADE.  THIS
; ROUTINE IS PROVIDED AS IS WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES
; WHATSOEVER.  OTHER LIMITATIONS APPLY AS DESCRIBED IN THE FILE DISCLAIMER.TXT.
;-
;-------------------------------------------------------------

	FUNCTION INTERPX, X,Y,XX, HELP=HLP, BAD=BAD,GAP=GAP, FIXBAD=XBAD

	IF KEYWORD_SET(HLP) THEN BEGIN
	  PRINT,' INTERPOLATE DATA WITH POSSIBLE GAPS AND MISSING (BAD) VALUES.'
	  PRINT,' YY = INTERPX(X,Y,XX)'
	  PRINT,'   X,Y = INPUT POINTS.            IN'
	  PRINT,'     X IS ASSUMED MONOTONICALLY INCREASING.'
	  PRINT,'   XX = DESIRED X VALUES.         IN'
	  PRINT,'     XX NEED NOT BE MONOTONICALLY INCREASING.'
	  PRINT,'   YY = INTERPOLATED Y VALUES.    OUT'
	  PRINT,' KEYWORDS:'
	  PRINT,'   BAD=B  VALUES GREATER THAN B ARE CONSIDERED MISSING.'
	  PRINT,'   GAP=G  GAPS IN X GREATER THAN OR EQUAL TO THIS'
	  PRINT,'     ARE BROKEN BY SETTING THE OUTPUT CURVE POINTS'
	  PRINT,'     IN THE GAPS TO A FLAG VALUE OF 32000 OR BAD IF GIVEN.'
	  PRINT,'   /FIXBAD  MEANS INTERPOLATE ACROSS BAD DATA BETWEEN'
	  PRINT,'     CLOSEST GOOD POINTS ON EACH SIDE.  OTHERWISE THE'
	  PRINT,'     BAD POINTS ARE FLAGGED WITH THE VALUE SPECIFIED'
	  PRINT,'     FOR BAD.'
	  PRINT,' NOTES: FLAGGED VALUES MAY BE USED TO BREAK A PLOTTED'
	  PRINT,'    CURVE USING MAX_VALUE IN THE PLOT OR OPLOT COMMAND:'
	  PRINT,'    PLOT,X,Y,MAX_VALUE=999'
	  PRINT,'    SLOW FOR MORE THAN A FEW THOUSAND POINTS.'
	  RETURN,-1
	ENDIF


	;--------  FIND ANY DATA GAPS  ------------------------------
	;  DATA GAPS ARE WHERE THE X COORDINATE JUMPS BY MORE THAN A
	;  SPECIFIED AMOUNT.  SAVE THE INDEX OF THE POINT JUST BEFORE
	;  THE GAP IN GLO AND THE INDEX OF THE POINT JUST ABOVE THE
	;  GAP IN GHI (= NEXT POINT).
	;------------------------------------------------------------
	CNTG = 0				; ASSUME NO GAPS.
	IF N_ELEMENTS(GAP) NE 0 THEN BEGIN	; GAP VALUE GIVEN.
	  GLO = WHERE(X(1:*)-X GT GAP, CNTG)	; INDEX OF 1ST PT BELOW GAP.
	  GHI = GLO + 1				; INDEX OF 1ST PT ABOVE GAP.
	ENDIF

	;--------  FIND ANY BAD POINTS  -----------------------------------
	;  IT IS ASSUMED THAT BAD POINTS HAVE BEEN TAGGED WITH A FLAG VALUE
	;  BEFORE CALLING THIS ROUTINE.  ANY POINTS WITH A VALUE LESS THAN
	;  OR EQUAL TO THE FLAG VALUE ARE ASSUMED TO BE GOOD.  THE INDICES
	;  OF THE GOOD POINTS ON EITHER SIDE ARE SAVED IN LO AND HI.
	;-----------------------------------------------------------------
	CNTB = 0				; ASSUME NO BAD POINTS.
	IF N_ELEMENTS(BAD) NE 0 THEN BEGIN	; BAD TAG VALUE GIVEN.
	  W = WHERE(Y LE BAD, CNT)		; INDICES OF GOOD VALUES.
	  IF CNT GT 0 THEN BEGIN		; FOUND SOME GOOD POINTS.
	    WB = WHERE(W(1:*)-W GT 1, CNTB)	; LOOK FOR INDEX JUMPS > 1.
	  ENDIF
	ENDIF
	IF CNTB GT 0 THEN BEGIN	; FOUND SOME BAD POINT GROUPS.
	  LO = W(WB)		; INDEX OF IGNORE WINDOW BOTTOM.
	  HI = W(WB+1)		; INDEX OF IGNORE WINDOW TOP.
	ENDIF

	;--------  SETUP OUTPUT Y ARRAY AND FLAG VALUE  -------
	YY = MAKE_ARRAY(N_ELEMENTS(XX),TYPE=IDLTYPE(Y,/CODE))
	FLAG = 32000.
	IF N_ELEMENTS(BAD) NE 0 THEN FLAG = BAD

	;-----  HANDLE BAD POINTS  -------------------------------
	;  FLAG WHICH POINTS IN THE OUTPUT ARRAYS TO IGNORE DUE TO BAD PTS.
	;---------------------------------------------------------
	IF NOT KEYWORD_SET(XBAD) THEN BEGIN
	  IF CNTB GT 0 THEN BEGIN
	    FOR I = 0, N_ELEMENTS(LO)-1 DO BEGIN  ; LOOP THRU BAD POINT GAPS.
	      W = WHERE((XX GT X(LO(I))) AND (XX LT X(HI(I))), CNT) ; IN GAP.
	      IF CNT GT 0 THEN YY(W) = FLAG	  ; FLAG THOSE IN BAD PT GAP.
	    ENDFOR
	  ENDIF
	ENDIF

	;-----  HANDLE DATA GAPS  ---------------------------------
	;  FLAG WHICH POINTS IN THE OUTPUT ARRAYS TO IGNORE DUE TO DATA GAPS.
	;----------------------------------------------------------
	IF CNTG GT 0 THEN BEGIN
	  FOR I = 0, N_ELEMENTS(GLO)-1 DO BEGIN	; LOOP THRU GAPS.
	    W = WHERE((XX GT X(GLO(I))) AND (XX LT X(GHI(I))), CNT)
	    IF CNT GT 0 THEN YY(W) = FLAG		; FLAG THOSE IN GAP.
	  ENDFOR
	ENDIF

	;-----  LINEARLY INTERPOLATE INTO X,Y AT XX TO GET YY --------
	;  DROP ANY BAD POINTS FROM INPUT CURVE BEFORE INTERPOLATING.
	;  THEN FIND INPUT AND OUTPUT CURVE SIZES.
	;  FINALLY INTERPOLATE NEEDED POINTS.
	;-------------------------------------------------------------
	CNT = 0
	IF N_ELEMENTS(BAD) NE 0 THEN BEGIN
	  W = WHERE(Y LT BAD, CNT)			; DROP BAD POINTS
	ENDIF
	IF CNT EQ 0 THEN W = LINDGEN(N_ELEMENTS(X))	; BEFORE INTERPOLATION.
	X2 = X(W)
	Y2 = Y(W)

	LSTXX = N_ELEMENTS(XX) - 1		; NUMBER OF OUTPUT POINTS.
	LSTX = N_ELEMENTS(X2) - 1		; NUMBER OF GOOD INPUT POINTS.

	FOR I = 0L, LSTXX DO BEGIN		; LOOP THROUGH OUTPUT POINTS.
	  IF YY(I) EQ FLAG THEN GOTO, SKIP	; IGNORE FLAGGED POINTS.
	  J = (WHERE(X2 GE XX(I)))[0]
	  CASE 1 OF
J EQ -1:    YY(I) = Y2(LSTX)			; AFTER LAST INPUT X.
J EQ  0:    YY(I) = Y2[0]			; BEFORE FIRST INPUT X.
   ELSE:    BEGIN				; MUST INTERPOLATE.
	      M = (Y2(J) - Y2(J-1))/(X2(J) - X2(J-1))	; SLOPE.
	      YY(I) = M*(XX(I) - X2(J-1)) + Y2(J-1)	; Y = M*X + B.
	    END
	  ENDCASE
SKIP:
	ENDFOR

	RETURN, YY
	END

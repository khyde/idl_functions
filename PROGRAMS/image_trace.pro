; $ID:	IMAGE_TRACE.PRO,	2020-07-08-15,	USER-KJWH	$
;########################################################################################
 FUNCTION IMAGE_TRACE, IMAGE, VALUES,   MASK=MASK, ERROR=ERROR
;+
; NAME:
; 	IMAGE_TRACE
;
; PURPOSE:
;		THIS FUNCTION TRACES TARGET VALUES WITHIN AN IMAGE AND 
;		              RETURNS A STRUCTURE WITH THE X,Y POSITIONS OF THE TARGET VALUES
;
; CATEGORY:
;		IMAGE
;
; CALLING SEQUENCE:
;		RESULT = IMAGE_TRACE(IMAGE, 1 )
;
; INPUTS:
;		IMAGE:	A 2-D ARRAY, USUALLY BINARY OR INTEGER AND NOT FLOATING-POINT
;		VALUES: THE TARGET VALUE(S) TO FIND
;
; OPTIONAL INPUTS:
;		NONE
;
; KEYWORD PARAMETERS:
;		MASK: AN ARRAY THAT IS THE SAME SIZE AS THE INPUT IMAGE, WITH 1'S AT PIXELS WHICH SHOULD BE IGNORED AND NOT TRACED.
;		ERROR: ERROR CODE, 1=ERROR, 0=OK.
;
; OUTPUTS:
;		A STRUCTURE WITH THE TARGET VALUE AND THE TRACED X,Y POSITIONS WHERE THIS TARGET VALUE WAS FOUND
;
;	PROCEDURE:
; EXAMPLE:
;
;	NOTES:
;
;
; MODIFICATION HISTORY:
;			WRITTEN NOV 21, 2006 BY J.O'REILLY, 28 TARZWELL DRIVE, NMFS, NOAA 02882 (JAY.O'REILLY@NOAA.GOV)
;-
;########################################################################################
;	****************************************************************************************************
ROUTINE_NAME='IMAGE_TRACE'
ERROR = 0

SZ=SIZE(IMAGE,/STRUCT)
IF SZ.N_DIMENSIONS NE 2 THEN BEGIN
	PRINT, 'ERROR: IMAGE MUST BE 2 DIMENSIONS'
 	ERROR = 1 & RETURN, -1
ENDIF

PX=SZ.DIMENSIONS[0]
PY=SZ.DIMENSIONS[1]
LAST_PX = PX - 1
LAST_PY = PY -1


;	===> IF A MASK IS NOT PROVIDED THEN MAKE ONE AND INITIALIZE TO 0 (NOT MASKED)
IF N_ELEMENTS(MASK) NE N_ELEMENTS(IMAGE) THEN BEGIN
	MASK = BYTE(IMAGE)
	MASK(*) = 0
ENDIF

;	===> ENSURE IMAGE IS NUMERIC
IF NUMERIC(IMAGE) NE 1 THEN BEGIN
	PRINT, 'ERROR: IMAGE MUST BE NUMERIC'
	ERROR = 1 & RETURN, -1
ENDIF

IF N_ELEMENTS(VALUES) NE 1 THEN BEGIN
	PRINT, 'ERROR: MUST PROVIDE A TARGET VALUE'
	ERROR = 1 & RETURN, -1
ENDIF

;	===> MAKE AN IMAGE INDEX ARRAY
PXPY = IMAGE_PXPY(IMAGE)

;	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
FOR _VALUE = 0L,N_ELEMENTS(VALUES)-1L DO BEGIN
	AVALUE = VALUES(_VALUE)

;===> FIND TARGET PIXELS
OK_VALUE=WHERE(IMAGE EQ AVALUE,COUNT_VALUE)
IF COUNT_VALUE EQ 0 THEN BEGIN
	PRINT, 'ERROR: VALUE NOT FOUND IN THE IMAGE'
	ERROR = 1 & RETURN, -1
ENDIF

;		===> CREATE A STRUCTURE TO HOLD THE OUTPUT POSITIONS
STRUCT=REPLICATE(CREATE_STRUCT('VALUE',AVALUE,'X',0L,'Y',0L),COUNT_VALUE)


;===> INITIALIZE AROUND TO 1 (A 3 BY 3 SEARCH BOX)
AROUND_X = 1
AROUND_Y = 1

;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FOR NTH = 0L,COUNT_VALUE-1L DO BEGIN

	IF NTH EQ 0 THEN BEGIN
		SUB =  OK_VALUE[NTH]
		XY = ARRAY_INDICES(IMAGE, SUB)
		X=XY[0]
		Y=XY[1]
		STRUCT[NTH].X = X
		STRUCT[NTH].Y = Y
		STRUCT[NTH].VALUE = AVALUE
		MASK[NTH] = 1
		CONTINUE ; >>>>>>>>>>>>>>>>>>>>>>>
	ENDIF

;===> MASK THE CURRENT POINT
  MASK(SUB) = 1

;===> GET X,Y COORDINATES FOR THIS SUBSCRIPT
	XY = ARRAY_INDICES(IMAGE, SUB)
	X=XY[0]
	Y=XY[1]

	AGAIN: ; IF NONE FOUND COME BACK TO AGAIN AND SEARCH AGAIN USING A LARGER SEARCH BOX

;===> GET PIXELS SURROUNDING SUB WITHIN THE DIMENSIONS OF THE BOX AND WITHIN THE IMAGE DIMENSIONS
  BOXL = (X - AROUND_X) > 0
  BOXR = (X + AROUND_X) < LAST_PX
  BOXB = (Y - AROUND_Y) > 0
  BOXT = (Y + AROUND_Y) < LAST_PY

	SUBS_X		= PXPY.X(BOXL:BOXR, BOXB:BOXT)
	SUBS_Y		= PXPY.Y(BOXL:BOXR, BOXB:BOXT)

	BOX_SET 	= IMAGE(BOXL:BOXR, BOXB:BOXT)
	BOX_MASK 	= MASK( BOXL:BOXR, BOXB:BOXT)

;===> FIND THE VALUE IN THE BOX BUT DO NOT FIND ANY ALREADY FOUND (MASKED =1)
  OK_BOX_SET = WHERE(BOX_SET EQ AVALUE AND BOX_MASK EQ 0,COUNT_BOX_SET)

;===> IF COUNT_BOX_SET THEN
	IF COUNT_BOX_SET GE 1 THEN BEGIN
 		BOX_SET=BOX_SET(OK_BOX_SET)
 		SUBS_X = SUBS_X(OK_BOX_SET)
 		SUBS_Y = SUBS_Y(OK_BOX_SET)

		X_MID = X
		Y_MID = Y

;===> COMPUTE DISTANCE FROM CENTER OF SUB TO EACH OF THE VALID NEIGHBORS IN BOX_SET
		DIST = (SUBS_X-X_MID)^2 + (SUBS_Y-Y_MID)^2 ;

;===> SORT DIST AND TAKE THE CLOSEST
		S=SORT(DIST)

;===> FILL STRUCTURE	WITH X,Y COORDINATES AND THE VAL
		STRUCT[NTH].VALUE = FIRST(BOX_SET(S))
		STRUCT[NTH].X = FIRST(SUBS_X(S))
		STRUCT[NTH].Y = FIRST(SUBS_Y(S))


;===> DETERMINE THE SUBSCRIPT INDEX (SUB) FROM THE X,Y POSITION
		TWO2ONE, (STRUCT[NTH].X), (STRUCT[NTH].Y), IMAGE, SUB

   ENDIF ELSE BEGIN

;===> IF LAST POINT THEN DONE
   IF NTH EQ COUNT_VALUE-1L THEN RETURN, STRUCT

;===> MAKE THE BOX LARGER TO ATTEMPT TO CAPTURE THE NEXT ADJACENT POINT ON THE LINE
		AROUND_X=AROUND_X + 1
		AROUND_Y=AROUND_Y + 1

		IF AROUND_X LT LAST_PX-1 AND AROUND_Y LT LAST_PY-1 THEN GOTO, AGAIN ; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>..

	ENDELSE

	ENDFOR ; 	FOR NTH = 0L,COUNT_VALUE-1L DO BEGIN

;	===> CONCATENATE THE CURRENT STRUCT TO ENCOMPASS ALL VALUES
	IF N_ELEMENTS(ALL) EQ 0 THEN ALL = STRUCT ELSE ALL = [TEMPORARY(ALL),STRUCT]
ENDFOR;

RETURN,ALL


END; #####################  END OF ROUTINE ################################




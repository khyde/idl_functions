; $ID:	WHERE_SETS.PRO,	2020-06-30-17,	USER-KJWH	$
;#########################################################################################################
  FUNCTION WHERE_SETS, DATA0,DATA1,DATA2,DATA3,DATA4,DATA5,DATA6,DATA7,DATA8,DATA9,$
  										 DELIM=DELIM, $
  										 NESTED=NESTED, $
  										 ORDER=ORDER, $
  										 REVERSE=REVERSE,$
  										 ALL_SUBS=ALL_SUBS, $
  										 JOIN=JOIN,PAD=PAD,$
  										 ERROR=ERROR
;+
; NAME:
;       WHERE_SETS
;
; PURPOSE:
;       IDENTIFY UNIQUE SETS AND THEIR SUBSCRIPTS (ARRAY ELEMENTS HAVING IDENTICAL VALUES)
;
; EXAMPLES:
;   S=WHERE_SETS([2,2,3,1,3,5,4,4,3,4,5,4,5,5,5]) & SPREAD,S
; 	S=WHERE_SETS(REVERSE([2,2,3,1,3,5,4,4,3,4,5,4,5,5,5])) & SPREAD,S
;  	S=WHERE_SETS([2,2,3,1,3,5,4,4,3,4,5,4,5,5,5],/ORDER) & SPREAD,S
;   S=WHERE_SETS(REVERSE([2,2,3,1,3,5,4,4,3,4,5,4,5,5,5]),/ORDER) & SPREAD,S

;
; INPUTS:
;       DATA (ARRAY)
;				DATA1,DATA2,DATA3 (IF THE ARRAYS ARE PASSED SEPARATELY IN DATA, DATA1,ETC THEN THE RESULTING STRUCTURE WILL
;				INDICATE THE GROUP TO WHICH THE VALUE BELONGS
;
; KEYWORD PARAMETERS:
;				DELIM: 	THE DELIMITER TO USE WHEN JOINING ALL SUBSCRIPTS FOR A SET (DEFAULT IS ; )
;       NESTED: OUTPUT STRUCTURE WILL BE A NESTED TYPE
;       JOIN - SETS ARE BASED ON JOINING SEVERAL INPUT DATA INTO A STRING SEPARATED BY DELIM
;				ERROR:  ERROR CODE
; OUTPUTS:
;       STRUCTURE WITH:
;								 	THE SET VALUE,
;									THE NUMBER OF REPEATS, AND
;									THE SUBSCRIPTS WHERE THE VALUE OCCURS
;
; MODIFICATION HISTORY:
;   WRITTEN BY:  J.E.O'REILLY, JAN 27,2002
;		CREDIT FOR THE DOUBLE HISTOGRAM APPROACH TO: J.D. SMITH AS REPORTED BY D.FANNING
;		MAR 15, 2004 - JOR:  STREAMLINED, NOW NOT USING WHERE
;   AUG 12, 2013 - JOR:  FORMATTING
;   JUN 22, 2014 - JOR:  USING NONE
;   NOV 13, 2014 - JOR:  REPLACED RETURN, -1 WITH RETURN,[]
;                        ERROR IS NOW AN INFORMATIVE ERROR MESSAGE INSTEAD OF 1
;   JAN 21, 2015 - KJWH: ADDED REVERSE KEYWORD BACK INTO PROGRAM     
;   MAY 29, 2020 - KJWH: Added IF KEYWORD_SET(ALL_SUBS) THEN to only run the WHERE_SETS_SUBS step when ALL_SUBS is requested          
;#########################################################################################################
;-

ROUTINE_NAME='WHERE_SETS'
ERROR=''

N_DATA=N_ELEMENTS(DATA0)
IF N_DATA EQ 0 THEN BEGIN
	ERROR='NO DATA'
	RETURN, []
ENDIF;IF N_DATA EQ 0 THEN BEGIN


IF NONE(DELIM) THEN DELIM = ';'

;	===> IF MORE THAN 2 DATA ARRAYS WERE PROVIDED
N_DATA = N_PARAMS()


IF KEYWORD_SET(JOIN) OR KEYWORD_SET(PAD) THEN BEGIN
	DATA = STR_JOIN(DATA0,DATA1,DATA2,DATA3,DATA4,DATA5,DATA6,DATA7,DATA8,DATA9,DELIM=DELIM,PAD=PAD)
	N_DATA = 1
	GROUPS = 	REPLICATE(0,N_ELEMENTS(DATA))
ENDIF ELSE BEGIN

;LLLLLLLLLLLLLLLLLLLLLLLLLLLL
	FOR N = 0,N_DATA-1L DO BEGIN
		IF N EQ 0 THEN BEGIN & GROUPS = 				REPLICATE(N,N_ELEMENTS(DATA0)) 	& DATA = DATA0 				& ENDIF
		IF N EQ 1 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA1))] & DATA = [DATA,DATA1] & ENDIF
	  IF N EQ 2 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA2))] & DATA = [DATA,DATA2] & ENDIF
	  IF N EQ 3 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA3))] & DATA = [DATA,DATA3] & ENDIF
	  IF N EQ 4 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA4))] & DATA = [DATA,DATA4] & ENDIF
	  IF N EQ 5 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA5))] & DATA = [DATA,DATA5] & ENDIF
	  IF N EQ 6 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA6))] & DATA = [DATA,DATA6] & ENDIF
	  IF N EQ 7 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA7))] & DATA = [DATA,DATA7] & ENDIF
	  IF N EQ 8 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA8))] & DATA = [DATA,DATA8] & ENDIF
	  IF N EQ 9 THEN BEGIN & GROUPS = [GROUPS,REPLICATE(N,N_ELEMENTS(DATA9))] & DATA = [DATA,DATA9] & ENDIF
	ENDFOR;FOR N = 0,N_DATA-1L DO BEGIN
ENDELSE;IF KEYWORD_SET(JOIN) OR KEYWORD_SET(PAD) THEN BEGIN



; ===> SORT DATA AND DETERMINE UNIQUE ELEMENTS
SRT=SORT(DATA)
U = UNIQ(DATA(SRT))
N_SETS=N_ELEMENTS(U)


;	///////////////////////////////////////////////////////////////////////
;	///// STRUCTURE WILL BE SPREADSHEET TYPE OUTPUT STRUCTURE /////
;	///////////////////////////////////////////////////////////////////////

  SETS_UNIQ=DATA(SRT(U))
  ; *****
  INDS=[WHERE_MATCH(SETS_UNIQ,DATA,VALID=VALID,COUNT)]
  IF COUNT GE 1 THEN INDS=INDS(VALID) ELSE BEGIN
  	ERROR = 'ERROR: NO VALID SETS'
  	PRINT, 'ERROR: NO VALID SETS'
  	RETURN, []
  ENDELSE

	H1=HISTOGRAM(INDS,REVERSE_INDICES=RI1,OMIN=OMIN,MIN=0L) ;MIN=0 JOR
	OK_H1=WHERE(H1 NE 0,COUNT_H1)

  H2=HISTOGRAM(H1,REVERSE_INDICES=RI2,MIN=1L)
  OK_H2=WHERE(H1 NE 0,COUNT_H2)
	SUBS=STRARR(MAX(INDS)+1)
	GRPS=STRARR(MAX(INDS)+1)

	STRUCT = REPLICATE(CREATE_STRUCT('VALUE',DATA[0],'N',0L,'SUBS','','FIRST',-1L,'GROUPS',''),COUNT_H2)

	STRUCT.VALUE = SETS_UNIQ
	STRUCT.N = H1(OK_H2)

;	===> OUTPUT THE SUBSCRIPTS
	LINDEX= STRTRIM(LINDGEN(N_ELEMENTS(DATA)),2)+DELIM
	GINDEX= STRTRIM(GROUPS,2)+DELIM

;	===> SINGLE VALUES WITHOUT DUPLICATION
  IF RI2[1] GT RI2[0] THEN BEGIN
  	VEC_INDS=RI2[RI2[0]:RI2[1]-1]
  	SUBS[OMIN+VEC_INDS]=LINDEX[RI1[RI1[VEC_INDS]]]
  	GRPS[OMIN+VEC_INDS]=GINDEX[RI1[RI1[VEC_INDS]]]
  ENDIF

;	===> DUPLICATES
;	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  FOR J=1L,N_ELEMENTS(H2)-1L DO BEGIN
  	IF RI2[J+1] EQ RI2[J] THEN CONTINUE ;NONE WITH THAT MANY DUPLICATES
  	VEC_INDS=RI2[RI2[J]:RI2[J+1]-1] ;INDICES INTO H1
  	VINDS=OMIN+VEC_INDS
  	VEC_INDS=REBIN(RI1[VEC_INDS],H2[J],J+1,/SAMPLE)+ $
   	     		 REBIN(TRANSPOSE(LINDGEN(J+1)),H2[J],J+1,/SAMPLE)
  	SUBS[VINDS]=SUBS[VINDS]+STRJOIN(TRANSPOSE(LINDEX[RI1[VEC_INDS]]))
  	GRPS[VINDS]=GRPS[VINDS]+STRJOIN(TRANSPOSE(GINDEX[RI1[VEC_INDS]]))
  ENDFOR

	STRUCT.SUBS=SUBS(OK_H2+OMIN)
	STRUCT.GROUPS=GRPS(OK_H2+OMIN)



;	===> GET FIRST SUBSCRIPTS
	START = REPLICATE(0L,1,N_SETS)
	WIDTH = START
 	WIDTH(0,*) 		= STRPOS(STRUCT.SUBS,DELIM )
  STRUCT.FIRST 	= STRMID(STRUCT.SUBS,START,WIDTH)


;	===> ORDER THE OUTPUT STRUCTURE BY FIRST SUBSCRIPT
  IF KEYWORD_SET(ORDER) THEN BEGIN
  	S=SORT(STRUCT.FIRST) & STRUCT=STRUCT(S)
	ENDIF

; ===> Sort the output structure by first subscript
	IF KEYWORD_SET(REVERSE) THEN BEGIN
	  S = REVERSE(SORT(STRUCT.VALUE))
	  STRUCT=STRUCT(S)
	ENDIF

;	===> ALL SUBSCRIPTS AS A SINGLE ARRAY
 	IF KEYWORD_SET(ALL_SUBS) THEN ALL_SUBS=WHERE_SETS_SUBS(STRUCT)


;	///////////////////////////////////////////////////////////////////
	IF KEYWORD_SET(NESTED) THEN BEGIN
;	///// STRUCTURE WILL BE A N E S T E D   TYPE OUTPUT STRUCTURE /////
;	///////////////////////////////////////////////////////////////////
; 	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  	FOR NTH = 0L, N_ELEMENTS(STRUCT)-1L DO BEGIN
    	SUBSCRIPTS = LONARR(STRUCT[NTH].N)
    	SUBS = STRSPLIT(STRUCT[NTH].SUBS,';',/EXTRACT)
    	READS,SUBS, SUBSCRIPTS
    	DS = CREATE_STRUCT(STRUCT[NTH],'SUB',SUBSCRIPTS)
    	IF NTH EQ 0 THEN BEGIN
      	STRUCT_NESTED = CREATE_STRUCT('_'+STRTRIM(NTH,2),DS)
    	ENDIF ELSE BEGIN
      	STRUCT_NESTED = CREATE_STRUCT(TEMPORARY(STRUCT_NESTED), '_'+STRTRIM(NTH,2),DS)
    	ENDELSE
  	ENDFOR
  	RETURN, STRUCT_NESTED
	ENDIF ; IF  KEYWORD_SET(NESTED)


	RETURN,STRUCT
	DONE:

  END; #####################  END OF ROUTINE ################################

; $ID:	MAPS_AVHRR_SUBSET.PRO,	2020-06-26-15,	USER-KJWH	$
; #########################################################################; 
FUNCTION MAPS_AVHRR_SUBSET,ARRAY, MAP_OUT=MAP_OUT, INIT=INIT, LONMIN=LONMIN, LONMAX=LONMAX, LATMIN=LATMIN, LATMAX=LATMAX
;+
; PURPOSE:  RETURN AN EXTRACTED ARRAY FROM THE INPUT AVHRR ARRAY WHICH COVERS THE DOMAIN OF THE MAP_OUT
;
; CATEGORY: MAPS;
;
;
; INPUTS:  ARRAY [AVHRR DATA ARRAY]
;          PROGRAM ASSUMES THAT THE MAP_IN = AVHRR
;          PROGRAM GETS LON AND LAT FROM AVHRR_LON.SAV & AVHRR_LAT.SAV IN MASTER
;
; KEYWORDS:  
;          MAP_OUT.... NAME OF OUTPUT MAP
;          LONMIN..... MIN LONGITUDE (optional)
;          LONMAX..... MAX LONGITUDE (optional)
;          LATMIN..... MIN LATITUDE (optional)
;          LATMAX..... MAX LATITUDE (optional)
;         

; OUTPUTS: A SUBSET OF THE LARGE AVHRR ARRAY COVERING THE DOMAIN OF THE MAP_OUT
;    8640 LON and 4320 
;; EXAMPLES: SIMULATE THE AVHRR ARRAY WITH BYTES [FOR SPEED]>
;          HELP, MAPS_AVHRR_SUBSET(INDGEN([8640,4320]),MAP_OUT ='NEC')
;          HELP, MAPS_AVHRR_SUBSET(INDGEN([8640,4320]),MAP_OUT ='EC')
;          HELP, MAPS_AVHRR_SUBSET(INDGEN([8640,4320]),MAP_OUT ='NEC_ECO')
;          HELP, MAPS_AVHRR_SUBSET(INDGEN([8640,4320], LONMIN=-80, LONMAX=-60, LATMIN=35, LATMAX=45)
;
;
; MODIFICATION HISTORY:
;     APR 28, 2016  WRITTEN BY: K.J.W.HYDE & J.E.O'REILLY
;     APR 29, 2016 - KJWH: Updated with correct LON and LAT files
;                          Added LON and LAT common
;     MAY 02, 2016 - KJWH: Added STRUCT_MAPS_SUBSET common
;                          Added optional coorindate inputs
;     MAY 03, 2016 - JEOR: Documented new keywords
;                          Edited examples with correct array sizes & changed to INDGEN
;     MAY 04, 2016 - KJWH: Created from MAPS_MUR_SUBSET    
;     MAY 11, 2016 - KJWH: Fixed RETURN, ARRAY subscript error     
;                          Note, LATS are in order of 90 to -90 so the subscripts are SUB_LATMAX:SUB_LATMIN
;                          Updated documenation and added coordinate example     
;     AUG 19, 2016 - KJWH: Changed !S.MASTER to !S.MAPINFO         
;     AUG 23, 2016 - KJWH: Updated the AVHRR input files     
;     AUG 09, 2019 - KJWH: Changed DATATYPE() to IDLTYPE()                
;                                               
; #########################################################################
;-

;*******************************
ROUTINE_NAME  = 'MAPS_AVHRR_SUBSET'
;*******************************
;===> ENSURE ARRAY AND MAP_OUT ARE PROVIDED
  IF NONE(ARRAY)   THEN MESSAGE,'ERROR: ARRAY IS REQUIRED'
  IF NONE(MAP_OUT) AND NONE(LONMIN) THEN MESSAGE,'ERROR: EITHER MAP_OUT OR LON/LAT MIN/MAX ARE REQUIRED'

;===> GET AVHRR GLOBAL LAT & LON ARRAYS FROM MASTER

  COMMON MAPS_AVHRR_SUBSET_, LON, LAT, STRUCT_MAPS_SUBSET
  
  IF KEY(INIT) THEN BEGIN
    LON = []
    LAT = []
    STRUCT_MAPS_SUBSET = []
  ENDIF
  
  SZ = SIZEXYZ(ARRAY)
  IF SZ.PX NE 8640 AND SZ.PY NE 4320 THEN RETURN, 'ERROR: input array deminsions must be 8640 x 4320'
  
  IF NONE(LON) THEN LON = IDL_RESTORE(!S.MAPINFO + 'AVHRR-PX_8640-LON.SAV')
  IF NONE(LAT) THEN LAT = IDL_RESTORE(!S.MAPINFO + 'AVHRR-PY_4320-LAT.SAV')
  
  IF IDLTYPE(LONS) EQ 'STRING' OR IDLTYPE(LATS) EQ 'STRING' THEN BEGIN
    LON = []
    LAT = []
    RETURN, 'ERROR: Unable to read the MASTER LON/LAT files'
  ENDIF

  IF NONE(MAP_OUT) THEN MAP_OUT = 'LONLAT_' + ROUNDS(LONMIN) + '_' + ROUNDS(LONMAX) + '_' + ROUNDS(LATMIN) + '_' + ROUNDS(LATMAX) 
  MAP_OUT = REPLACE(MAP_OUT,'-','N') ; REPLACE DASHES ('-') WITH N (FOR NEGATIVE) BECAUSE DASHES ARE NOT ALLOWED IN IDL TAGNAMES
  
; ===> Look for the MAP_OUT tag in STRUCT_MAPS_SUBSET if it is not already present
  IF NONE(STRUCT_MAPS_SUBSET) OR KEY(INIT) THEN STRUCT_MAPS_SUBSET=CREATE_STRUCT('_','')
  OK_TAG = WHERE(TAG_NAMES(STRUCT_MAPS_SUBSET) EQ MAP_OUT,COUNT_MAP)  
  IF COUNT_MAP EQ 0 THEN BEGIN

;===> DETERMINE LON/LAT CORNERS OF MAP_OUT
    IF VALIDS('MAPS',MAP_OUT) EQ STRUPCASE(MAP_OUT) THEN BEGIN
      MAPS_SET,MAP_OUT     
      S=MAPS_LL_BOX() 
      ZWIN
      LONMIN = S.LONMIN
      LONMAX = S.LONMAX
      LATMIN = S.LATMIN
      LATMAX = S.LATMAX
    ENDIF ; IF VALIDS('MAPS',MAP_OUT) EQ MAP_OUT THEN BEGIN

;===> GET NEAREST SUBS FOR LONMIN,LONMAX
    OK = WHERE_NEAREST(LON, LONMIN,NEAR = 0.1,COUNT_LONMIN)
    IF COUNT_LONMIN GE 1 THEN SUB_LONMIN = FIRST[OK]
    OK = WHERE_NEAREST(LON, LONMAX,NEAR = 0.1,COUNT_LONMAX)
    IF COUNT_LONMAX GE 1 THEN SUB_LONMAX = FIRST[OK]

;===> GET NEAREST SUBS FOR LATMIN,LATMAX 
    OK = WHERE_NEAREST(LAT, LATMIN,NEAR = 0.1,COUNT_LATMIN) 
    IF COUNT_LATMIN GE 1 THEN SUB_LATMIN = FIRST[OK]
    OK = WHERE_NEAREST(LAT, LATMAX,NEAR = 0.1,COUNT_LATMAX)
    IF COUNT_LATMAX GE 1 THEN SUB_LATMAX = FIRST[OK]
  
; ===> ADD ANOTHER MAP_OUT-PX_OUT LAYER (TAG) TO THE STRUCT_MAPS_SUBSET STRUCTURE
  STRUCT_MAPS_SUBSET=CREATE_STRUCT(TEMPORARY(STRUCT_MAPS_SUBSET),MAP_OUT,$
    CREATE_STRUCT('MAP_OUT',MAP_OUT,'LONMIN', LONMIN, 'SUB_LONMIN', SUB_LONMIN, $
                                    'LONMAX', LONMAX, 'SUB_LONMAX', SUB_LONMAX, $
                                    'LATMIN', LATMIN, 'SUB_LATMIN', SUB_LATMIN, $
                                    'LATMAX', LATMAX, 'SUB_LATMAX', SUB_LATMAX ))  
  
  ENDIF
 
; ===> LOOK FOR THE MAP_OUT TAG IN STRUCT_MAPS_SUBSET IF IT IS NOT ALREADY PRESENT
  OK_TAG = WHERE(TAG_NAMES(STRUCT_MAPS_SUBSET) EQ MAP_OUT,COUNT_MAP)
  SUB_LONMIN = STRUCT_MAPS_SUBSET.(OK_TAG).SUB_LONMIN
  SUB_LONMAX = STRUCT_MAPS_SUBSET.(OK_TAG).SUB_LONMAX
  SUB_LATMIN = STRUCT_MAPS_SUBSET.(OK_TAG).SUB_LATMIN
  SUB_LATMAX = STRUCT_MAPS_SUBSET.(OK_TAG).SUB_LATMAX

  RETURN,ARRAY(SUB_LONMIN:SUB_LONMAX,SUB_LATMAX:SUB_LATMIN) ; Note, LATS are in order of 90 to -90 so the subscripts are SUB_LATMAX:SUB_LATMIN


END; #####################  END OF ROUTINE ################################

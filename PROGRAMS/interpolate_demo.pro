; $ID:	INTERPOLATE_DEMO.PRO,	2020-07-08-15,	USER-KJWH	$

 PRO INTERPOLATE_DEMO
;+
; NAME:
;       INTERPOLATE_DEMO
;
; PURPOSE:
;       DEMONSTRATE THE USE OF IDL INTRINSIC FUNCTION INTERPOLATE
;
; CATEGORY:
;
;
; CALLING SEQUENCE:
;       RESULT = INTERPOLATE_DEMO(A)
;
; INPUTS:
;
;
; KEYWORD PARAMETERS:
;
; OUTPUTS:
;
; SIDE EFFECTS:
;       NONE.
;
; RESTRICTIONS:
;       NONE.
;
; PROCEDURE:
;       STRAIGHTFORWARD.
;
; MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, JANUARY 6,2000.
;       JUL 18,2014,JOR FORMATTING ADDED STEP DO_D3
;-
;********************************
ROUTINE_NAME = 'INTERPOLATE_DEMO'
;********************************
DO_IDL_EXAMPLE  = 1
DO_LINEAR       = 0
DO_2D           = 0
DO_2D_MISS      = 0
DO_D3           = 0
DO_REPLACE_NANS = 0
;*****************************
IF DO_IDL_EXAMPLE GE 1 THEN BEGIN
;*****************************
  PRINT,'EXAMPLE FROM HELP'
  PRINT,' THE EXAMPLE BELOW COMPUTES BILINEAR INTERPOLATES WITH THE KEYWORD GRID SET:'

P = FINDGEN(4,4)

PRINT, INTERPOLATE(P, [.5, 1.5, 2.5], [.5, 1.5, 2.5], /GRID)

;AND PRINTS THE 3 BY 3 ARRAY:
;
;   2.50000   3.50000   4.50000
;
;   6.50000   7.50000   8.50000
;
;   10.5000   11.5000   12.5000
;
;CORRESPONDING TO THE LOCATIONS:
;
;(.5,.5), (1.5, .5), (2.5, .5), 
;
;(.5,1.5), (1.5, 1.5), (2.5, 1.5),
;
;(.5,2.5), (1.5, 2.5), (2.5, 2.5)
STOP
PRINT,'ANOTHER EXAMPLE COMPUTES INTERPOLATES, 
PRINT,'WITH GRID NOT SET AND A PARAMETER OUTSIDE THE BOUNDS OF P:'

PRINT, INTERPOLATE(P, [.5, 1.5, 2.5, 3.1], [.5, 1.5, 2.5, 2])
STOP
;AND PRINTS THE RESULT:
;
;  2.50000   7.50000   12.5000   11.0000
;
;CORRESPONDING TO THE LOCATIONS 
;(.5,.5), (1.5, 1.5), (2.5, 2.5) AND (3.1, 2.0). 
;NOTE THAT THE LAST LOCATION IS OUTSIDE THE BOUNDS OF P AND 
;IS SET FROM THE VALUE OF THE LAST COLUMN. 
;THE FOLLOWING COMMAND USES THE MISSING KEYWORD TO SET SUCH VALUES TO -1:

PRINT, INTERPOLATE(P, [.5, 1.5, 2.5, 3.1], [.5, 1.5, 2.5, 2], $

   MISSING = -1)

;AND GIVES THE RESULT:
;
;   2.50000   7.50000   12.5000   -1.00000


  STOP
ENDIF;ENDIF;IF DO_IDL_EXAMPLE GE 1 THEN BEGIN
;||||||||||||||||||||||||||||||||||||||||||||
;
;*****************************
IF DO_LINEAR GE 1 THEN BEGIN
  ;*****************************
  PRINT,'EXAMPLE OF LINEAR INTERPOLATION'
  PP=FINDGEN(8,8)
  PRINT, INTERPOLATE(PP, [.5, 1.5, 2.5, 2.5,4.5,5.5,6.5], [.5, 1.5, 2.5,3.5,4.5,5.5,6.5], /GRID)
  PP(3:4,3:4) = MISSINGS(PP);!VALUES.F_NAN
  PRINT, INTERPOLATE(PP, [.5, 1.5, 2.5, 2.5,4.5,5.5,6.5], [.5, 1.5, 2.5,3.5,4.5,5.5,6.5], /GRID)
  STOP
ENDIF;ENDIF;IF DO_LINEAR GE 1 THEN BEGIN
;|||||||||||||||||||||||||||||||||||||||
;
;***********************
IF DO_2D GE 1 THEN BEGIN
;***********************

  PRINT,'EXAMPLE OF 2-D INTERPOLATION
  SUB = 4
  PX = 256
  PY = PX
  Z = DIST(PX)
  Z = BYTSCL(Z,MIN=0,MAX=MAX(Z))
  X = FINDGEN(PX/SUB)
  X = X * SUB
  Y = X

  NEW = INTERPOLATE(Z,X,Y,/GRID)
  NEW = CONGRID(NEW,PX,PY)
  IMAGE = [Z,NEW]

  X = SUBSAMPLE(X,SUB)
  Y = SUBSAMPLE(Y,SUB)
  NEW = INTERPOLATE(Z,X,Y,/GRID)
  NEW = CONGRID(NEW,PX,PY)
  IMAGE = [IMAGE, NEW ]
  SLIDEW,IMAGE
  STOP
ENDIF;IF DO_2D GE 1 THEN BEGIN
;|||||||||||||||||||||||||||||

;*****************************
IF DO_2D_MISS GE 1 THEN BEGIN
;*****************************	
  PRINT,'EXAMPLE OF 2-D INTERPOLATION WITH MISSING DATA'
	PRINT,'A 256 X 256 BINARY IMAGE'
	PX = 256
  PY = PX
  Z = DIST(PX)
  Z = BYTSCL(Z,MIN=0,MAX=MAX(Z))
  SZ=SIZE(Z,/STRUCT)
  X = SZ.DIMENSIONS[0]
  Y = SZ.DIMENSIONS[1]

; =====> MAKE 2-D ARRAYS FOR X AND Y EQUAL TO Z DIMENSIONS
  XX = LINDGEN(X) # REPLICATE(1,X)
  YY = REPLICATE(1,Y) # LINDGEN(Y)

; =====> NOW ASSUME THAT GOOD DATA ARE LE 100 AND GE 104, 
;  AND DATA BETWEEN ARE MISSING
  OK = WHERE(Z LT 100 OR Z GE 104,COUNT)
; =====> NOW GET THE 2-D LOCATIONS OF MISSING DATA
  ONE2TWO, OK, Z,IX,IY
   ZZ =Z[OK]
	GRID = GRIDDATA(IX,IY,ZZ)


STOP
ENDIF;IF DO_2D_MISS GE 1 THEN BEGIN
;||||||||||||||||||||||||||||||||||

;***********************
IF DO_D3 GE 1 THEN BEGIN
;***********************
IF DO_D3 EQ 3 THEN STOP
PX = 9
PY = 7
PZ = 5
D3 = D3_STRUCT(N = PZ,PX = PX,PY = PY,/FILL)
ARR = D3.DATA
ARR(3,3,*) = MISSINGS(ARR)
P,ARR
GOOD = WHERE(ARR NE MISSINGS(ARR),COUNT,COMPLEMENT = BAD,NCOMPLEMENT = NBAD) & P,COUNT
XYZ = ARRAY_INDICES(ARR,BAD)
X = REFORM(XYZ(0,*))
Y = REFORM(XYZ(1,*))
Z = REFORM(XYZ(2,*))


NEW = INTERPOLATE(ARR,X,Y,Z) & HELP,NEW
;NEW = GRID3(X,Y,Z,ARR,/GRID)& HELP,NEW

PLINES
P,NEW
STOP



ENDIF;IF DO_D3 GE 1 THEN BEGIN
;**********************************
IF DO_REPLACE_NANS GE 1 THEN BEGIN
;**********************************
IF DO_REPLACE_NANS EQ 3 THEN STOP
;I WOULD DO SOMETHING LIKE THIS, IF I HAD AN ARRAY OF LOCATIONS X AND A
;DATA ARRAY DATA:

; SAMPLE DATA
X = [1., 2., 3., 5., 7., 7.5, 9., 12., 12.1]
DATA = [0., !VALUES.F_NAN, 10., 15., !VALUES.F_NAN, !VALUES.F_NAN, 5.,4., 5.]
OLD = DATA
; FIGURE OUT WHERE THERE ARE NANS AND WHERE THE USEFUL DATA ARE
GOODDATA = WHERE(DATA EQ DATA, NGOODDATA, $
  COMP=BADDATA, NCOMP=NBADDATA)
  
; INTERPOLATE AT THE LOCATIONS OF THE BAD DATA USING THE GOOD DATA
IF NBADDATA GT 0 THEN BEGIN
  DATA[BADDATA] = INTERPOL(DATA[GOODDATA], X[GOODDATA], X[BADDATA])
ENDIF
PL,OLD,DATA
ENDIF;IF DO_REPLACE_NANS GE 1 THEN BEGIN

END; #####################  END OF ROUTINE ################################

; $ID:	NICE_RANGE.PRO,	2020-07-08-15,	USER-KJWH	$
;##########################################################################################
FUNCTION NICE_RANGE, VALUES,EXPAND=EXPAND

;+
; NAME:
;		NICE_RANGE;
; PURPOSE:
;		THIS FUNCTION GENERATES A NICE RANGE ENCOMPASSING ALL THE INPUT VALUES VALUES (1,2,OR MORE ELEMENTS)
; CATEGORY:
;		MATH
;	CALLING SEQUENCE:
;		RESULT = NICE_RANGE(VALUES)
; INPUTS:
;		NUMERIC E.G. [0.23, 4]
; OUTPUTS:
;   A NICE RANGE [#,#],WITH THE SAME IDL DATA TYPE AS THE INPUT VALUES
; KEYWORDS:
;    EXPAND: A FACTOR LIKE 1.1 USED TO EXPAND THE RANGE
; OPTIONAL OUTPUTS:
;		ERROR:     ANY ERROR MESSAGES ARE PLACED IN ERROR, IF NO ERRORS THEN ERROR = ''
;
;	RESTRICTION:
;		VALUES MUST BE WITHIN THE RANGE OF 10D^-309 TO 10D^308
;
;	EXAMPLES:
;
;	 	VALUES = 1.1 							 	& RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;  	VALUES = [0.0022, 0.0083D] 	& RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;  	VALUES = [0.011, 3122] 			& RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;  	VALUES = [1E8, 3122] 				& RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;  	VALUES = [1, 3,4,8,12] 			& RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;
;  	NEGATIVES
;	 	VALUES = [-1.5 , -12]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;   VALUES = [1.5 ,  -12]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;		VALUES = [-1.5 ,  12]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;
;		ZEROS
;		VALUES = [0 ,  12]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;		VALUES = [12 , 	0]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;		VALUES = [0 ,  	0]  & RANGE = NICE_RANGE(VALUES) & PRINT,VALUES,RANGE
;
; MODIFICATION HISTORY:
;		WRITTEN JAN 21,2004 BY J.O'REILLY, 28 TARZWELL DRIVE, NMFS, NOAA 02882 (JAY.O'REILLY@NOAA.GOV)
;		NOV 4, 2006 J.O'REILLY & KIM HYDE NOW HANDLES NEGATIVE VALUES
;		MARCH 5, 2007 J.O'R  CHECKS FOR VERY SMALL VALUES AND SETS THEM TO ZERO
;		SEP 30,2013 FORMATTING
;		SEP 7,2014,JOR ADDED KEY EXPAND
;##########################################################################################
;
;-
;	****************************
	ROUTINE_NAME = 'NICE_RANGE'
; ****************************
	ERROR = ''
;	===> GET MACHINE ARITHMETIC FLOATING-POINT PRECISION
	M=MACHAR()

;	===> FIND GOOD DATA
	OK=WHERE(FINITE(VALUES) AND VALUES NE MISSINGS(VALUES),COUNT)
	IF COUNT EQ 0 THEN BEGIN
		ERROR='NO VALID VALUES'
		RETURN, ''
	ENDIF

	_VALUES = FLOAT(VALUES[OK])

;	===> COMPUTE MIN, MAX OF VALUES
	MIN_VALUES = MIN(_VALUES,MAX=MAX_VALUES)


;	===> SEE IF MIN_VALUES IS ESSENTIALLY ZERO
	IF ABS(MIN_VALUES) LT ABS(2*M.EPS) THEN MIN_VALUES(*) = 0
	IF ABS(MAX_VALUES) LT ABS(2*M.EPS) THEN MAX_VALUES(*) = 0


;	===> CALL DECADES TO GET AN ARRAY ENCOMPASSING THE MIN_VALUES AND MAX_VALUES, RESOLVED IN TENTHS FOR EACH DECADES;
 	D=DECADES()

;	===> INITIALIZE _RANGE TO SAME DATA TYPE AS VALUES
	_RANGE = [VALUES[0],VALUES[0]]

;	===> POSITIVE MIN_VALUES
	IF MIN_VALUES GT 0 THEN BEGIN
		SUBS_MIN = VALUE_LOCATE(D,MIN_VALUES)
	  _RANGE[0] = D(SUBS_MIN)
	ENDIF

;	===> POSITIVE MAX_VALUES
	IF MAX_VALUES GT 0 THEN BEGIN
		SUBS_MAX = VALUE_LOCATE(D,MAX_VALUES)
		_RANGE[1] = D(SUBS_MAX)
	 	IF _RANGE[1] LT MAX_VALUES THEN _RANGE[1] = D(SUBS_MAX +1L)
	ENDIF

;	===> NEGATIVE MIN_VALUES
 	IF MIN_VALUES LT 0 THEN BEGIN
 		_D =  REVERSE(-D)
		SUBS_MIN = VALUE_LOCATE(_D,MIN_VALUES)
	  _RANGE[0] = _D(SUBS_MIN)
	ENDIF

;	===> NEGATIVE MAX_VALUES
	IF MAX_VALUES LT 0 THEN BEGIN
 		_D =  -D
		SUBS_MAX = VALUE_LOCATE(_D,MAX_VALUES)
	  _RANGE[1] = _D(SUBS_MAX)
	  IF _RANGE[1] LT MAX_VALUES THEN _RANGE[1] = _D(SUBS_MAX+1L)
	ENDIF


;	===> ZERO MIN_VALUES
	IF MIN_VALUES EQ 0 THEN _RANGE[0] = MIN_VALUES

;	===> ZERO MAX_VALUES
	IF MAX_VALUES EQ 0 THEN _RANGE[1] = MAX_VALUES
	IF KEY(EXPAND) THEN _RANGE = _RANGE *FLOAT(EXPAND)

 RETURN, _RANGE

END; #####################  END OF ROUTINE ################################


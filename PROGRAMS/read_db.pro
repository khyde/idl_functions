; $ID:	READ_DB.PRO,	2020-07-08-15,	USER-KJWH	$
;
FUNCTION read_db, FILE, TRANSLATION, QUIET = quiet
;
;+
; NAME:
;       read_db
;
; PURPOSE:
;       Read a dBASE file into an IDL Structure Array
;
; CATEGORY:
;       Input/Output (See write_db.pro).
;
; CALLING SEQUENCE:
;       DB    = READ_DB()             ; Pickfile will prompt you for a dbase file
;       D     = READ_DB(file)
;       D     = READ_DB(file,TRANS)   ; Translation Table (dBASE to IDL) will be placed in string variable 'TRANS'
;       RESULT= READ_DB(file,/QUIET)  ; Prevents printing of Messages about translation from dBASE to IDL
;
; INPUTS:
;       File:    Name of the input dBASE.dbf to read
;
;       Translation:  Name (Scalar string) for the output string array
;                     which describes the translation of dBASE fields
;                     into IDL fields (tags).
; OUTPUTS:
;
;       An IDL Structure Array is created from the dBASE file
;
;
; OPTIONAL OUTPUT PARAMETERS:
;
;       If Parameter: Translation is provided, then translation results are stored in 'translation'
;
;
; KEYWORDS
;
;       QUIET  (Prevents printing of information generated by program)
;
; SIDE EFFECTS:
;       dBASE IV,V can store numeric and float data with with a maximum size of
;       20 digits and a precision of 19 digits.  Consequently, there will be
;       some loss of precision in converting dBASE fields having many decimal
;       places into DOUBLE precision IDL fields.
;
;       Similarly, there will be loss of precision converting large NUMERIC dBase
;       fields (with no decimals) to IDL LONG data types.

;       For instance in IDL:
;       Conversion to FLOAT
;           PRINT,FLOAT('1.123456789012345679'),FORMAT='(F20.18)'
;           = 1.123456835746765100  (Only 6 correct decimal places)
;       Conversion to DOUBLE
;           PRINT,DOUBLE('1.123456789012345679'),FORMAT='(F20.18)'
;           = 1.123456789012345700(Only 14-15 correct decimal places)
;       Conversion to INTEGER
;         Maximum integer for idl is 32767
;           PRINT, FIX(32767)                  ;   =  32767
;           PRINT, FIX(32768)                  ;   = -32768 (Incorrect)
;           PRINT,FIX('9999'),  FORMAT='(I20)' ;   =   9999 (4 correct digits)
;           PRINT,FIX('-9999'), FORMAT='(I20)' ;   =  -9999 (4 correct digits)
;           PRINT,FIX('99999'), FORMAT='(I20)' ;   = -31073 (Incorrect)
;
;       Conversion to LONG
;         Maximum long word for idl is 2147483647
;           PRINT, LONG(2147483647)                 ;  =  2147483647
;           PRINT, LONG(2147483648)                 ;  = -2147483648 (Incorrect)
;           PRINT, LONG('999999999'), FORMAT='(I20)';  =  999999999  (9 correct digits)
;           PRINT, LONG('-999999999'),FORMAT='(I20)';  =  -999999999 (9 correct digits)
;           PRINT, LONG('9999999999'),FORMAT='(I20)';  =  1410065407 (Incorrect)
;
;
;       ADDITIONALLY, IDL does not yet support dBASE:
;            DATE,
;            LOGICAL,
;            MEMO FIELDS,
;            BINARY IMAGE, AND SOUND DATA, AND
;            OLE OBJECTS.
;
;  The following translation strategy is used by this program:
;
; =============================================================================>
; DBASE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TO  >>>>>>>>>>>>>>>>>>>>> IDL
; dBASE Type     Size (bytes)  Decimal  Missing |    IDL       Missing
;                              Places   Code    |    Type      Code
; ==============================================|===============================>
; NUMERIC/FLOAT         LE  9      0    BLANK   |   LONG       2147483647
; NUMERIC/FLOAT  GE 10, LE 14      0    BLANK   |   DOUBLE     !VALUES.D_INFINITY
; NUMERIC/FLOAT         GE 15      0    BLANK   |   STRING     ''  (empty string)
; NUMERIC/FLOAT         LE 14   GE 1    BLANK   |   DOUBLE     !VALUES.D_INFINITY
; NUMERIC/FLOAT         GE 15   GE 1    BLANK   |   STRING     ''  (empty string)
; CHARACTER            LE 254           BLANK   |   STRING     ''  (empty string)
; LOGICAL                   1           BLANK   |   STRING     ''  (empty string)
; DATE                      8           BLANK   |   STRING     ''  (empty string)
; MEMO                     10           BLANK   |   STRING     ''  (empty string)
; BINARY (IMAGE)           10           BLANK   |   STRING     ''  (empty string)
; BINARY (SOUND)           10           BLANK   |   STRING     ''  (empty string)
; OLE OBJECTS              10           BLANK   |   STRING     ''  (empty string)
;
;
; EXAMPLE:
;       To open and read the dBASE file named "TEST.DBF" in the current directory,
;       and store the fields for each record in an array structure called 'dataset1':
;       READ_DB, 'TEST.DBF', DATASET1
;       If you also want to generate a string_array listing a description of
;       the IDL array structure made from the dBASE file:
;       READ_DB, 'TEST.DBF', DATASET1, LIST1
;
; HINT:
;       An easy way to get data which is a mixture of data types (character, decimal, etc.)
;       into IDL is to:
;       1) Import the data or create it in EXCEL for windows
;       2) Add unique names at the top of each data column
;       3) Highlight the columns you want to export (including column names),
;       4) Save As  DBF 4 (dBASE IV)
;       5) Run IDL and use this program (read_db.pro)
;
;
; ====================>
; RESTRICTIONS:
;       Dbase III (and earlier) FORMATs not supported.
;       dBASE BINARY IMAGE (*.PCX,*.BMP) and BINARY sound data
;       and OLE information is not stored in the *.dbf database table file but
;       is contained in a separate file with a *.DBT extension
;       THE PRESENT VERSION OF THIS PROGRAM DOES NOT ACCESS THE INFORMATION
;       IN THE dBASE *.DBT FILE
;       There is no size limit FOR dBase MEMO type but IDL limits strings to 32,767 characters.
;
;       IDL Structures can have only 127 tags (fields) ... If the dBASE file has more
;       than 127 fields then a message will appear suggesting the user copy up to 127 fields
;       from the dBASE database into a temporary dBASE before importing the temporary
;       dBASE into IDL using read_db.pro
;
; MODIFICATION HISTORY:
;
;       Written December 6,1994, J.E.O'Reilly
;   NOAA, NMFS Narragansett Laboratory, 28 Tarzwell Drive, Narragansett, RI 02882-1199
;   oreilly@fish1.gso.uri.edu
;
;       Jan  3,1995 Changed program to check for blank dBASE data fields
;   Oct 23,1995 Processes missing dbase fields faster (eliminated EXECUTE statement)
;       Jan 11,1996 dBASE Numeric with lengths LE 9 and having no decimal places
;                   are converted to IDL LONG
;                   dBASE Numeric with lengths between 10 and 14 and no decimal places
;                   are converted to IDL DOUBLE
;                   dBASE Numeric with length  GE 14 are converted to IDL STRING
;                   Changed missing code value for Long from 2147483648 to:  2147483647
;                   Changed missing code value for Double from 1e32     to:  !VALUES.D_INFINITY
;                   Changed missing code value for String from ' '      to:  ''
;                   READ_DB does not generate any integer or Float data from dBASE data;
;                   dBase values are converted to long, double, or string
;       July 2,1996 Revised (each record read begins with a 32b)
;       Jan  9,1997 Added PICKFILE to prompt for input dbase file if user does not provide it
;                   Changed from a program to a function: the structured array is returned
;                   Removed option to output a table of translation from dbase to idl
;       Jan 28,1997 Edited some print statements for accuracy
;       Mar 16,1998 N_records was not working for large files
;                   changed from: n_records     = LONG(inbytes(4,0)+256*inbytes(5,0)+65536*inbytes(6,0))
;                             to: n_records     = LONG(inbytes(4,0)+256L*inbytes(5,0)+65536l*inbytes(6,0))
;       July 21,1999 Removed restriction of only 127 tags (idl can now handle more than 127 fields in a structure)  .
;       June 2, 2003 td replace strtrim(string with strtrim if format not specific
;-

; ====================>
; SOME NOTES ABOUT dBASE 4, dBASE 5 FILES:
;       dBASE files *.DBF are binary
;       Stored in the first 32 bytes is:

;       Information on Last Update, y,m,d (bytes 1,2,3)
;       Number of Records                 (bytes 4,5,6)
;       Length of Header (bytes)          (bytes 8,9)
;       Record length (bytes)             (bytes 10,11)
;       Index information                 (bytes up to 32nd ?)
;
;       Thereafter, information about each data field (variable)
;       in the database is stored in 32 bytes segments
;       (32 bytes *number of data fields)
;       This is followed by a '13b',
;       Then followed by the actual data bytes:
;       (record length in bytes * number of records)
;       (Note that each dBASE record begins with a 32b)
;       The last byte in the file is a 26b to terminate the file
;
; END OF PROGRAM DOCUMENTATION

; ====================>
; Check Parameters and Keywords
;
; See if dBASE input File Name and the name for the output array structure was supplied by user
  IF N_ELEMENTS(FILE) NE 1 THEN file = PICKFILE(FILTER='*.DBF',TITLE='Select dBASE File to Read')
  OPENR, lun, file, /GET_LUN   ; Open dBASE file: 'file'

; ====================>
; Create variable to store input read from dBASE file
  inbytes = BYTARR(32)

; ====================>
; Read header in dBase file
  READU,lun,inbytes

; ====================>
; Determine size of dBASE file
  file_size = FSTAT(lun)
  file_size = file_size.size

; ====================>
; Get Info About dBASE file
  update        = inbytes(1:3,0)

  n_records     = LONG(inbytes(4,0)+256*inbytes(5,0)+65536*inbytes(6,0))
  n_records     = LONG(inbytes(4,0)+256L*inbytes(5,0)+65536l*inbytes(6,0))
  header_bytes  = LONG(inbytes(8,0)+256*inbytes(9,0))
  rec_len       = LONG(inbytes(10,0)+256*inbytes(11,0))
  n_fields      = LONG((header_bytes - 32)/32)
  nth_field     = n_fields -1

; ====================>
; Begin making a Table (string array) to hold the complete description
; of the TRANSLATION of the dBASE file into the IDL Structure Array
  translation_table = STRARR(n_fields + 15) ; Extra lines are for translation table heading
  translation_table[0]= 'TRANSLATION TABLE:  dBASE to IDL '
  translation_table[1]= ' '
  translation_table(2)= 'Information for dBASE file    : ' + STRTRIM(file,2)
  translation_table(3)= 'Date (yy/mm/dd)of last update : ' + STRING(inbytes(1,0),inbytes(2,0),inbytes(3,0))
  translation_table(4)= 'Size of dBASE file in Bytes   : ' + STRING(file_size)
  translation_table(5)= 'Record Length in Bytes        : ' + STRING(rec_len)
  translation_table(6)= 'Number of Fields/Variables    : ' + STRING(n_fields)
  translation_table(7)= 'Number of Records             : ' + STRING(n_records)
  translation_table(8)= ' '
  translation_table(9)= STRING(REPLICATE(61B,80))
  translation_table(10) = ' IDL structure array made from dBASE file: ' + file
  translation_table(11) = 'Number of Data Records =        ' + STRING(n_records)
  translation_table(12) = ' '
  translation_table(13)=' DBASE >>>>>>>>>>>>>>>>>>>>>>>>>>>> TO  >>>>>>>>> IDL                 '
  translation_table(14) ='Field   DB_Name      Type Width Dec Missing     IDL_Name    Type        Missing  '




; ====================>
; Create a structure for defining IDL missing codes to be
; substituted for BLANK dBASE fields.
  idlmissing={Undefined:0,$
              Byte:0,$
              Integer:32767,$
              Long:2147483647L,$
              Float:!VALUES.F_INFINITY,$
              Double:!VALUES.D_INFINITY,$
              Complex_floating:0,$
              String:"''",$
              Structure:0,$
              Double_complex:0}

; ====================>
; Get the names of the idl types
  idl_type    = TAG_NAMES(IDLMISSING)

; ====================>
; Create variables to hold information used in the translation
  db_field    = STRARR(n_fields)   ; dBASE Field Names (Variables)
  idl_field   = STRARR(n_fields)   ; IDL   Field Names

  db_type     = STRARR(n_fields)   ; dBASE Field Types

  idl_code    = INTARR(n_fields)   ; IDL data type codes
  idl_code(*) = 0

  db_width   = INTARR(n_fields)    ; dBASE  Field length
  db_dec     = INTARR(n_fields)    ; dBASE  Decimals


; ====================>
; Read in each 32 byte segement describing each dBASE Field.
; Identify the dBASE data type.
; Fill the read_format and translation_table strings

  FOR _field = 0, (nth_field) DO BEGIN
    READU,lun,inbytes
    db_field(_field)  = STRTRIM(inbytes(0:9),2)  ; Name of dBASE field
    idl_field(_field) = db_field(_field)         ; Name of IDL field
    db_width(_field)  = inbytes(16)              ; Length of dBASE Field
    db_dec(_field)    = inbytes(17)              ; Number of Decimal Places

;   See what the data type is for each dBASE field
;   ====================> dBASE NUMERIC OR FLOAT FIELDS
    IF inbytes(11) EQ 78B OR inbytes(11) EQ 70B THEN BEGIN
      db_type(_field)  = 'NUMERIC'
      IF inbytes(11) EQ 70B THEN db_type(_field) = 'FLOAT'
      IF db_width(_field) LE 9 THEN BEGIN
        IF db_dec(_field) EQ 0 THEN BEGIN       ; No Decimals, Make Long
          idl_code(_field) = 3
        ENDIF ELSE BEGIN                        ; Decimals, Make Double
          idl_code(_field) = 5
        ENDELSE
      ENDIF

      IF db_width(_field) GE 10 AND db_width(_field) LE 14 THEN BEGIN ; Make double
        idl_code(_field) = 5
      ENDIF

      IF db_width(_field) GE 15 THEN BEGIN    ; Too long for Long, make string
        idl_code(_field) = 7
      ENDIF

    ENDIF  ;IF inbytes(11) EQ 78B OR inbytes(11) EQ 70B THEN BEGIN

;   ====================>  dBASE CHARACTER FIELDS
    IF inbytes(11) eq 67B THEN BEGIN
      db_type(_field)  = 'CHARACTER'
      idl_code(_field) = 7
    ENDIF

;   ====================>  dBASE LOGICAL FIELDS
    IF inbytes(11) eq 76B THEN BEGIN
      db_type(_field)  = 'LOGICAL'
      idl_code(_field) = 7
    ENDIF

;   ====================>  dBASE DATE FIELDS
    IF inbytes(11) eq 68B THEN BEGIN
      db_type(_field)  = 'DATE'
      idl_code(_field) = 7
    ENDIF

;   ====================>  dBASE MEMO FIELDS
    IF inbytes(11) eq 77B THEN BEGIN
      db_type(_field)  = 'MEMO'
      idl_code(_field) = 7
    ENDIF

;   ====================>  dBASE BINARY FIELDS
    IF inbytes(11) eq 66B THEN BEGIN
      db_type(_field)  = 'BINARY'
      idl_code(_field) = 1
    ENDIF

;   ====================>  dBASE OLE FIELDS
    IF inbytes(11) eq 71B THEN BEGIN
      db_type(_field)  = 'OLE'
      idl_code(_field) = 7
    ENDIF


;   ====================>
;   Create the IDL structure to hold the dBASE database records
;   Start with the first field
    IF _field EQ 0 THEN BEGIN
      array = CREATE_STRUCT(db_field[0],idlmissing.(idl_code[0]))
;     Make String Variable (read_format) used to read dbase record into structure 'array'
;     Start with the format used to read the first field
      read_format   = '(A' + STRTRIM(db_width[0],2) + ','
    ENDIF ELSE BEGIN
;     Add to the structure definition and add to the read format for each of the fields
      array = CREATE_STRUCT(array,db_field(_field),idlmissing.(idl_code(_field)))
      read_format   = read_format + 'A' + STRTRIM(db_width(_field),2) + ','
    ENDELSE

;   Add to the translation_table for each of the IDL/dBASE data fields
    translation_table(_field+15) = STRING((_field+1),db_field(_field),$
                                 db_type(_field),db_width(_field),$
                                 db_dec(_field),$
                                 'Blank',$
                                 idl_field(_field),$
                                 idl_type(idl_code(_field)),$
                                 STRING(idlmissing.(idl_code(_field))),$
                                 FORMAT = '(i4,1X,a10,a10,i5,i4,a7,a15,a8,a16)')

  ENDFOR   ; (FOR _field = 0, (nth_field) DO BEGIN)

; ====================>
; Clean up read_format
  read_format = STRMID(read_format,0,STRLEN(read_format)-1) ; remove last comma
  read_format = read_format + ')'                           ; add end parenthesis

; ====================>
; Replicate data structure, making array structure to hold
; each record in the dBASE file
  array = REPLICATE(array,n_records)

; ====================>
; Dimension inbytes to record length of each dBASE Record
  inbytes = BYTARR(rec_len)

; Dimension words to number of fields in each dBASE record
  in_words = STRARR(n_fields)

; ====================>
; Position pointer at the starting byte of first data record in dBASE file
  POINT_LUN, lun, header_bytes  ;

; ====================>
; Read each dBASE Record into variable inbytes
; Then use read_format to format and place data into structure array
; Skips over missing dBASE fields, leaving them coded as missing in the array
  FOR _record = 0L, (n_records -1) DO BEGIN
    READU,lun,inbytes
    READS, STRING(inbytes(1:*)),in_words,format=read_format
;   Ignore the first byte (32b) on each record
    not_blank = WHERE(STRLEN(STRTRIM(in_words,2)) NE 0, count)
    IF count GE 1 THEN BEGIN
      FOR _word = 0, (N_ELEMENTS(not_blank) -1) DO BEGIN
        array(_record).(not_blank(_word)) = in_words(not_blank(_word))
      ENDFOR
    ENDIF
  ENDFOR

; ====================>
; Reformat translation table so each line occupies 80 characters
  translation_table = STRING(translation_table,FORMAT='(A80)')
  IF KEYWORD_SET(QUIET) EQ 0 THEN PRINT, translation_table



; ====================>
; Place contents of string array: translation_table into parameter translation
  TRANSLATION  = translation_table

; ====================>
; Print out JOB message if user did not supply keyword QUIET
  IF KEYWORD_SET(QUIET) EQ 0 THEN BEGIN
    PRINT, ' '
    PRINT, ' '
    PRINT, ' READ_DB is Finished Reading File: ',file
    PRINT, STRCOMPRESS(STRING(n_records)),  ' Data Records are Stored in An Array Structure'

    IF N_PARAMS() EQ 2 THEN BEGIN
      PRINT, ' '
      PRINT, ' A Description of dBASE and IDL Fields'
      PRINT, ' is Stored in a String Array '
      PRINT, ' Whose Name You Provided in Parameter ''translation'' '
    ENDIF
  ENDIF
  FREE_LUN,lun


  RETURN,ARRAY
  END
; ====================> END OF PROGRAM

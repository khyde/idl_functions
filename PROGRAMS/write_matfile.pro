; $ID:	WRITE_MATFILE.PRO,	2020-07-08-15,	USER-KJWH	$
;#############################################################################
 PRO WRITE_MATFILE, FILE, ARRAY=ARRAY, NAME=NAME, NOTES=NOTES , SWAP=SWAP
;+
; NAME:
;       WRITE_MATFILE
;
; PURPOSE:
;				WRITE A 'MATLAB 5.0 MAT-FILE' FROM AN IDL ARRAY
;
;	KEYWORDS:
;		ARRAY: 		THE IDL DATA ARRAY
;		NAME:			NAME OF THE DATA ARRAY
;		NOTES: 		ADDITIONAL INFORMATION TO WRITE IN THE HEADER PART OF THE MAT FILE
;		SWAP:  		SWAPS BYTES WHEN WRITING INTEGER AND LONG (USED TO WRITE A UNIX MATFILE FROM A PC)
;
; DOCUMENTATION ON MAT-FILE FORMAT TAKEN DIRECTLY FROM:
;		MAT-FILE FORMAT, 	VERSION 7, 	MATLABï¿½, 45 PP.
;		THE LANGUAGE OF TECHNICAL COMPUTING
;		THE MATHWORKS, INC.
;		3 APPLE HILL DRIVE
;		NATICK, MA 01760-2098

;	NOTES:
; THIS ROUTINE WORKS ONLY FOR MAT-FILE DATA TYPE 14 (MATLAB ARRAY, SYMBOL MIMATRIX)

; MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, JUNE 12, 2004
;       SEP 27,2014,JOR UPDATED CODE, FORMATTING
;-
;***************************
ROUTINE_NAME='WRITE_MATFILE'
;***************************

  MATLAB_FILE_TYPE = 'MATLAB 5.0 MAT-FILE'
  IF NONE(SWAP) THEN SWAP = 0 

;	===> DETERMING IDL OPERATING SYSTEM
	IDL_OS = STRUPCASE(!VERSION.OS)

	IF NONE(NAME)  THEN NAME = 'ARRAY'

; ******************************************
;.***** INITIALIZE VARIABLES *****
; ******************************************
  MAT_SUBSYSTEM_SPECIFIC_DATA=BYTARR(8)

; VERSION WHEN CREATING A MAT-FILE, SET THIS FIELD TO 0X0100.
  MAT_VERSION=FIX('0X0100'XL) & IF SWAP THEN MAT_VERSION=SWAP_ENDIAN(MAT_VERSION)

  MAT_ENDIAN_INDICATOR=STRING('MI')
  MAT_FILE_DATA_TYPE= LONG(14)
  NBYTES=0L

;	===> THIS NEEDS TO BE EXPANDED FOR MAC, ETC.
	IF IDL_OS EQ 'WIN32' THEN BEGIN
		IF SWAP EQ 0 THEN MAT_PLATFORM = 'PCWIN' ELSE MAT_PLATFORM = 'SOL2'
		IF SWAP EQ 0 THEN MAT_ENDIAN_INDICATOR=STRING('IM') ELSE MAT_ENDIAN_INDICATOR=STRING('MI')
	ENDIF

	IF N_ELEMENTS(ARRAY) EQ 0 THEN STOP
	IDL_TYPE = IDLTYPE(ARRAY)

;	===> IS THE ARRAY A STRUCTURE CONTAINING SEVERAL ARRAYS ?
	IF IDL_TYPE EQ 'STRUCT' THEN IS_STRUCTURE = 1 ELSE IS_STRUCTURE = 0

; ******************************************
; ***** TABLE 1-1: MAT-FILE DATA TYPES *****
; ******************************************
	TYPES = CREATE_STRUCT('VALUE',0,'SYMBOL','','DATUM_BYTES',0,'NOTE','','CLASS',0,'IDLTYPE',0)
	TYPES = REPLICATE(TYPES,19)

; VALUE SYMBOL MAT-FILE DATA TYPE
	TYPES[1].VALUE =1		& TYPES[1].SYMBOL ='MIINT8' 			& TYPES[1].DATUM_BYTES =1 & TYPES[1].NOTE ='SIGNED'													 & TYPES[1].CLASS= 8 	& TYPES[1].IDLTYPE =0
	TYPES(2).VALUE =2 	& TYPES(2).SYMBOL ='MIUINT8' 			& TYPES(2).DATUM_BYTES =1 & TYPES(2).NOTE ='UNSIGNED'												 & TYPES(2).CLASS= 9 	& TYPES(2).IDLTYPE =1
	TYPES(3).VALUE =3  	& TYPES(3).SYMBOL ='MIINT16' 			& TYPES(3).DATUM_BYTES =2 & TYPES(3).NOTE ='SIGNED'                          & TYPES(3).CLASS= 10 & TYPES(3).IDLTYPE =2
	TYPES(4).VALUE =4 	& TYPES(4).SYMBOL ='MIUINT16' 		& TYPES(4).DATUM_BYTES =2 & TYPES(4).NOTE ='UNSIGNED'                        & TYPES(4).CLASS= 11 & TYPES(4).IDLTYPE =12
	TYPES(5).VALUE =5 	& TYPES(5).SYMBOL ='MIINT32' 			& TYPES(5).DATUM_BYTES =4 & TYPES(5).NOTE ='SIGNED'                          & TYPES(5).CLASS= 12 & TYPES(5).IDLTYPE =3
	TYPES(6).VALUE =6 	& TYPES(6).SYMBOL ='MIUINT32' 		& TYPES(6).DATUM_BYTES =4 & TYPES(6).NOTE ='UNSIGNED'                        & TYPES(6).CLASS= 13 & TYPES(6).IDLTYPE =13
	TYPES(7).VALUE =7 	& TYPES(7).SYMBOL ='MISINGLE' 		& TYPES(7).DATUM_BYTES =4 & TYPES(7).NOTE ='SINGLE'                          & TYPES(7).CLASS=  7 & TYPES(7).IDLTYPE =4
	TYPES(8).VALUE =8 	& TYPES(8).SYMBOL ='' 						& TYPES(8).DATUM_BYTES =0 & TYPES(8).NOTE ='RESERVED'                        & TYPES(8).CLASS=  0 & TYPES(8).IDLTYPE =0
	TYPES(9).VALUE =9 	& TYPES(9).SYMBOL ='MIDOUBLE' 		& TYPES(9).DATUM_BYTES =8 & TYPES(9).NOTE ='DOUBLE'                          & TYPES(9).CLASS=  6 & TYPES(9).IDLTYPE =5
	TYPES(10).VALUE=10 	& TYPES(10).SYMBOL='' 						& TYPES(10).DATUM_BYTES=0 & TYPES(10).NOTE='RESERVED'                        & TYPES(10).CLASS= 0 & TYPES(10).IDLTYPE=0
	TYPES(11).VALUE=11 	& TYPES(11).SYMBOL='' 						& TYPES(11).DATUM_BYTES=0 & TYPES(11).NOTE='RESERVED'												 & TYPES(11).CLASS= 0 & TYPES(11).IDLTYPE=0
	TYPES(12).VALUE=12 	& TYPES(12).SYMBOL='MIINT64' 			& TYPES(12).DATUM_BYTES=8 & TYPES(12).NOTE='SIGNED'                          & TYPES(12).CLASS= 0 & TYPES(12).IDLTYPE=14
	TYPES(13).VALUE=13 	& TYPES(13).SYMBOL='MIUINT64' 		& TYPES(13).DATUM_BYTES=8 & TYPES(13).NOTE='UNSIGNED'                        & TYPES(13).CLASS= 0 & TYPES(13).IDLTYPE=15
	TYPES(14).VALUE=14 	& TYPES(14).SYMBOL='MIMATRIX' 		& TYPES(14).DATUM_BYTES=0 & TYPES(14).NOTE='MATLAB ARRAY'                    & TYPES(14).CLASS= 0 & TYPES(14).IDLTYPE=0
	TYPES(15).VALUE=15 	& TYPES(15).SYMBOL='MICOMPRESSED'	& TYPES(15).DATUM_BYTES=0 & TYPES(15).NOTE='COMPRESSED'                      & TYPES(15).CLASS= 0 & TYPES(15).IDLTYPE=0
	TYPES(16).VALUE=16 	& TYPES(16).SYMBOL='MIUTF8' 			& TYPES(16).DATUM_BYTES=1 & TYPES(16).NOTE='UNICODE UTF_8 ENCODED CHARACTER' & TYPES(16).CLASS= 0 & TYPES(16).IDLTYPE=0
	TYPES(17).VALUE=17 	& TYPES(17).SYMBOL='MIUTF16' 			& TYPES(17).DATUM_BYTES=2 & TYPES(17).NOTE='UNICODE UTF_16 ENCODED CHARACTER'& TYPES(17).CLASS= 0 & TYPES(17).IDLTYPE=0
	TYPES(18).VALUE=18 	& TYPES(18).SYMBOL='MIUTF32' 			& TYPES(18).DATUM_BYTES=4 & TYPES(18).NOTE='UNICODE UDF_32 ENCODED CHARACTER'& TYPES(18).CLASS= 0 & TYPES(18).IDLTYPE=0


;MATLAB CLASS					VALUE 	SYMBOL
;CELL ARRAY 							1 	MXCELL_CLASS
;STRUCTURE 								2 	MXSTRUCT_CLASS
;OBJECT 									3 	MXOBJECT_CLASS
;CHARACTER ARRAY 					4 	MXCHAR_CLASS
;SPARSE ARRAY 						5 	MXSPARSE_CLASS
;DOUBLE PRECISION ARRAY 	6 	MXDOUBLE_CLASS
;SINGLE PRECISION ARRAY 	7 	MXSINGLE_CLASS
;8-BIT, SIGNED INTEGER 		8 	MXINT8_CLASS
;8-BIT, UNSIGNED INTEGER 	9 	MXUINT8_CLASS
;16-BIT, SIGNED INTEGER 	10 	MXINT16_CLASS
;16-BIT, UNSIGNED INTEGER 11 	MXUINT16_CLASS
;32-BIT, SIGNED INTEGER 	12 	MXINT32_CLASS
;32-BIT UNSIGNED, INTEGER 13 	MXUINT32_CLASS


; ****************************************
;	***** OPEN MATLAB FILE FOR WRITING *****
; ****************************************
	OPENW,LUN,FILE,/GET_LUN


; *********************************************************************************
;	LEVEL 5 MAT-FILES ARE MADE UP OF A 128-BYTE HEADER FOLLOWED BY ONE OR MORE
;	DATA ELEMENTS. EACH DATA ELEMENT IS COMPOSED OF AN 8-BYTE TAG FOLLOWED BY THE
;	DATA IN THE ELEMENT. THE TAG SPECIFIES THE NUMBER OF BYTES IN THE DATA ELEMENT
;	AND HOW THESE BYTES SHOULD BE INTERPRETED; THAT IS, SHOULD THE BYTES BE READ AS
;	16-BIT VALUES, 32-BIT VALUES, FLOATING POINT VALUES OR SOME OTHER DATA TYPE.

; *********************************************************************************
;	LEVEL 5 MAT-FILES BEGIN WITH A 128-BYTE HEADER MADE UP OF A 124 BYTE TEXT FIELD
;	AND TWO, 16-BIT FLAG FIELDS.
	DESCRIPTIVE_TEXT= REPLICATE(32B,116)

;	===> FILL DESCRIPTIVE_TEXT WITH ITS COMPONENT TEXT STRINGS
  TXT = 'MATLAB 5.0 MAT-FILE, ' 						& POS_START = 0 				& POS_END = STRLEN(TXT)-1 ;
	DESCRIPTIVE_TEXT(POS_START:POS_END) = BYTE(TXT)
	TXT = 'PLATFORM: ' 		+ MAT_PLATFORM +', '			& POS_START = POS_END+1 & POS_END = POS_END + STRLEN(TXT)
	DESCRIPTIVE_TEXT(POS_START:POS_END) = BYTE(TXT)
	TXT = 'CREATED ON: ' 	+ SYSTIME()  			 	& POS_START = POS_END+1 & POS_END = POS_END + STRLEN(TXT)
	DESCRIPTIVE_TEXT(POS_START:POS_END) = BYTE(TXT)

	IF N_ELEMENTS(NOTES) GE 1 THEN BEGIN
		TXT = ', ' + NOTES										& POS_START = POS_END+1 & POS_END = POS_END + STRLEN(TXT)
;		===> ENSURE THAT LAST CHARACTER OF THE 116 BYTES REMAINS BLANK (TRUNCATE NOTES IF NECESSARY)
		POS_END = POS_END < 114
	  NCHARS = POS_END - POS_START +1
	  TXT = STRMID(TXT,0,NCHARS)
		DESCRIPTIVE_TEXT(POS_START:POS_END) = BYTE(TXT)
	ENDIF

  WRITEU,LUN,DESCRIPTIVE_TEXT


; *********************************************************************************
;	BYTES 117 THROUGH 124 OF THE HEADER CONTAIN AN OFFSET TO SUBSYSTEM-SPECIFIC
;	DATA IN THE MAT-FILE. ALL ZEROS OR ALL SPACES IN THIS FIELD INDICATE THAT THERE IS
;	NO SUBSYSTEM-SPECIFIC DATA STORED IN THE FILE.
	WRITEU,LUN,MAT_SUBSYSTEM_SPECIFIC_DATA

; *********************************************************************************
;	THE LAST FOUR BYTES IN THE HEADER ARE DIVIDED INTO TWO, 16-BIT FLAG FIELDS (INT16).
;	FIELD VALUE:
;		VERSION WHEN CREATING A MAT-FILE, SET THIS FIELD TO 0X0100.
;		ENDIAN INDICATOR:	CONTAINS THE TWO CHARACTERS, M AND I, WRITTEN TO THE
;			MAT-FILE IN THIS ORDER, AS A 16-BIT VALUE. IF, WHEN READ
;			FROM THE MAT-FILE AS A 16-BIT VALUE, THE CHARACTERS APPEAR
;			IN REVERSED ORDER (IM RATHER THAN MI), IT INDICATES THAT THE
;			PROGRAM READING THE MAT-FILE MUST PERFORM BYTE-SWAPPING
;			TO INTERPRET THE DATA IN THE MAT-FILE	CORRECTLY.
	WRITEU,LUN,MAT_VERSION
 	WRITEU,LUN,BYTE(MAT_ENDIAN_INDICATOR)


; LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
; LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
; LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	===> COUNTER FOR MULTIPLE DATA ARRAYS IN ONE FILE (USED IN NAMIMG THE ARRAY IF ARRAY NAME IS BLANK)
	ARRAY_COUNTER= -1
;	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
	AGAIN:

	ARRAY_COUNTER = ARRAY_COUNTER + 1

; ***********************************
;	***** D A T A   E L E M E N T *****
; ***********************************
; EACH DATA ELEMENT BEGINS WITH AN 8-BYTE TAG FOLLOWED IMMEDIATELY BY THE DATA IN THE ELEMENT.
; THE TAG FIELD:
;		THE 8-BYTE DATA ELEMENT TAG IS COMPOSED OF TWO, 32-BIT FIELDS: DATA TYPE, NUMBER OF BYTES

; ALL DATA THAT IS UNCOMPRESSED MUST BE ALIGNED ON 64-BIT BOUNDARIES.
;	WHEN WRITING A MAT-FILE, IF THE AMOUNT OF DATA IN A DATA ELEMENT FALLS SHORT OF A 64-BIT BOUNDARY,
;	YOU MUST ADD BYTES OF PADDING TO MAKE SURE THE TAG OF THE NEXT DATA ELEMENT FALLS ON A 64-BIT
; BOUNDARY. LIKEWISE, WHEN READING DATA FROM A MAT-FILE, BE SURE TO ACCOUNT FOR THESE PADDING BYTES.



	STRUCT=CREATE_STRUCT('MAT_FILE_TYPE',MAT_FILE_DATA_TYPE,'NBYTES_FOLLOW',0L)
;	===> NUMBER OF BYTES IN THIS DATA ELEMENT
; THE VALUE OF THE NUMBER OF BYTES FIELD IN THE DATA ELEMENT TAG INCLUDES ALL THE SUBELEMENTS.
;	TAG_DATA_NBYTES IS THE NUMBER OF BYTES LEFT IN THE FILE


;	A MAT-FILE DATA ELEMENT REPRESENTING A MATLAB NUMERIC ARRAY OR CHARACTER
;	ARRAY IS COMPOSED OF FOUR SUBELEMENTS AND ONE OPTIONAL SUBELEMENT.

;	**********************************
;	***** ARRAY FLAGS SUBELEMENT *****
;	**********************************
; FLAGS. THIS FIELD CONTAINS THREE, SINGLE-BIT FLAGS THAT INDICATE WHETHER THE
;	NUMERIC DATA IS COMPLEX, GLOBAL, OR LOGICAL. IF THE COMPLEX BIT IS SET, THE DATA
;	ELEMENT INCLUDES AN IMAGINARY PART (PI). IF THE GLOBAL BIT IS SET, MATLAB LOADS
;	THE DATA ELEMENT AS A GLOBAL VARIABLE IN THE BASE WORKSPACE. IF THE LOGICAL BIT IS
;	SET, IT INDICATES THE ARRAY IS USED FOR LOGICAL INDEXING.
;	CLASS. THIS FIELD CONTAINS A VALUE THAT IDENTIFIES THE MATLAB ARRAY TYPE (CLASS)
;	REPRESENTED BY THE DATA ELEMENT. TABLE 1-3 LISTS THE MATLAB ARRAY TYPES WITH
;	THE VALUES YOU USE TO SPECIFY THEM. THE TABLE ALSO INCLUDES SYMBOLS THAT ARE
;	USED TO REPRESENT THE MATLAB ARRAY TYPE IN THE EXAMPLES IN THIS DOCUMENT.

  NBYTES=8
; ARRAY FLAGS MIUINT32 2*SIZE-OF-DATA-TYPE (8 BYTES)
  STRUCT=CREATE_STRUCT(STRUCT,'ARRAY_FLAGS_TAG',ULONG([6,NBYTES]))

	FLAGS = 0B
	OK=WHERE(TYPES.IDLTYPE EQ IDL_TYPE,COUNT)
	IF COUNT NE 1 THEN STOP

	MAT_CLASS = BYTE((TYPES(OK[0]).CLASS))
	B=BYTARR(NBYTES)
	B[0]=MAT_CLASS
	B[1] = FLAGS

	IF SWAP THEN B(0:3) = REVERSE(B(0:3))


	STRUCT=CREATE_STRUCT(STRUCT,'ARRAY_FLAGS',B)

;	***************************************
; ***** DIMENSIONS ARRAY SUBELEMENT *****
;	***************************************
; THIS SUBELEMENT SPECIFIES THE SIZE OF EACH DIMENSION OF AN N-DIMENSIONAL ARRAY
; IN AN N-SIZED ARRAY OF 32-BIT VALUES (MIINT32). ALL NUMERIC ARRAYS HAVE AT LEAST
; TWO DIMENSIONS. THE DIMENSIONS ARRAY SUBELEMENT IS COMMON TO ALL MATLAB
; DIMENSIONS ARRAY MIINT32 NUMBER-OF-DIMENSIONS*SIZE-OF-DATA-TYPE
; NOTE TO CALCULATE THE NUMBER OF DIMENSIONS IN AN ARRAY, DIVIDE THE VALUE
; STORED IN THE NUMBER OF BYTES FIELD IN THE DIMENSIONS ARRAY SUBELEMENT TAG
; BY 4, THE NUMBER OF BYTES IN THE DATA TYPE (MIINT32) USED IN THE SUBELEMENT.
; ARRAY TYPES.
; DIMENSIONS ARRAY MIINT32 NUMBER-OF-DIMENSIONS*SIZE-OF-DATA-TYPE
	L=LONG(5)
;;	DATUM_BYTES=TYPES(L[0]).DATUM_BYTES
	SZ=SIZE(ARRAY,/STRUCT)
	N_DIMENSIONS=SZ.N_DIMENSIONS

	DIMENSIONS = SZ.DIMENSIONS(0:N_DIMENSIONS-1)
	DIMENSIONS_TAG = LONG([L, N_DIMENSIONS*TYPES(L[0]).DATUM_BYTES])
	STRUCT=CREATE_STRUCT(STRUCT,'DIMENSIONS_TAG',DIMENSIONS_TAG)


;	===> ADJUST DIMENSIONS FROM IDL TO MATLAB CONVENTION
	DIMENSIONS = REVERSE(DIMENSIONS)

; +++ ??
	OK=WHERE(DIMENSIONS EQ 1,COUNT)
	IF COUNT EQ 1 THEN DIMENSIONS=REVERSE(DIMENSIONS)



	IF N_DIMENSIONS MOD 2 NE 0 THEN DIMENSIONS=[DIMENSIONS,0L]
  STRUCT=CREATE_STRUCT(STRUCT,'DIMENSIONS',DIMENSIONS)

; *********************************
; ***** ARRAY NAME SUBELEMENT *****
; *********************************
; THIS SUBELEMENT SPECIFIES THE NAME ASSIGNED TO THE ARRAY, AS AN ARRAY OF
;	SIGNED, 8-BIT VALUES (MIINT8). THIS SUBELEMENT IS COMMON TO ALL ARRAY TYPES.
; WHEN READING A MAT-FILE, YOU CAN TELL IF YOU ARE PROCESSING A
;	COMPRESSED DATA ELEMENT BY COMPARING THE VALUE OF THE FIRST TWO BYTES OF THE
;	TAG WITH THE VALUE ZERO [0]. IF THESE TWO BYTES ARE NOT ZERO, THE TAG USES THE
;	COMPRESSED FORMAT. WHEN WRITING A MAT-FILE, USE OF THE COMPRESSED DATA
;	ELEMENT FORMAT IS OPTIONAL.

; IF A DATA ELEMENT CONTAINS BETWEEN ONE AND FOUR BYTES OF DATA, MATLAB SAVES
; STORAGE SPACE BY STORING THE DATA IN AN 8-BYTE FORMAT. IN THIS FORMAT, THE DATA
; TYPE AND NUMBER OF BYTES FIELDS ARE STORED AS 16-BIT VALUES, FREEING FOUR BYTES
; IN THE TAG IN WHICH TO STORE THE DATA.
;
	NAME_LENGTH= STRLEN(NAME)


; $$$CHANGES
	IF NAME_LENGTH LE 4 THEN BEGIN
		TAG_ARRAY_NAME= FIX([1,NAME_LENGTH])
 		IF SWAP THEN TAG_ARRAY_NAME = REVERSE(TAG_ARRAY_NAME)
		STRUCT=CREATE_STRUCT(STRUCT,'TAG_ARRAY_NAME',TAG_ARRAY_NAME)
		IF NAME_LENGTH LT 4 THEN BEGIN
			PADS = BYTARR(4 - NAME_LENGTH)
			BNAME = [BYTE(NAME),PADS]
		ENDIF ELSE BNAME = BYTE(NAME)
	ENDIF ELSE BEGIN
   TAG_ARRAY_NAME= FIX([0,1])
		STRUCT=CREATE_STRUCT(STRUCT,'TAG_ARRAY_NAME',TAG_ARRAY_NAME)
		STRUCT=CREATE_STRUCT(STRUCT,'TAG_ARRAY_NAME_EXTRA',NAME_LENGTH)
		PADS = 8 - (NAME_LENGTH MOD 8)
		IF PADS NE 0 THEN BEGIN
			BNAME = [BYTE(NAME),REPLICATE(0B,PADS)]
		ENDIF ELSE BNAME = BYTE(NAME)
	ENDELSE
	STRUCT=CREATE_STRUCT(STRUCT,'ARRAY_NAME',BNAME)

; **********************************
;	***** DATA ARRAY (REAL PART) *****
; **********************************

;	*** NOT USING COMPRESSED DATA ELEMENT FORMAT ***

	OK=WHERE(TYPES.IDLTYPE EQ IDL_TYPE,COUNT)
	IF COUNT NE 1 THEN STOP

	MAT_TYPE=TYPES(OK[0]).VALUE
	TAG_ARRAY = FIX([MAT_TYPE,0])
	IF SWAP THEN TAG_ARRAY = REVERSE(TAG_ARRAY)

	STRUCT=CREATE_STRUCT(STRUCT,'TAG_ARRAY',TAG_ARRAY)


	DATUM_BYTES = TYPES(OK[0]).DATUM_BYTES
	ARRAY_BYTES  = ULONG(N_ELEMENTS(ARRAY) * DATUM_BYTES)
	STRUCT=CREATE_STRUCT(STRUCT,'ARRAY_BYTES',ARRAY_BYTES)

 	I=INDGEN(N_DIMENSIONS)
 	I=REVERSE(I)

	DATA=TRANSPOSE(ARRAY)

	STRUCT=CREATE_STRUCT(STRUCT,'ARRAY',DATA)
;	===> SIZE IN BYTES FOR ENTIRE STRUCTURE
	NBYTES_FOLLOW = SIZE_BYTES(STRUCT) - SIZE_BYTES(STRUCT.MAT_FILE_TYPE)-SIZE_BYTES(STRUCT.NBYTES_FOLLOW)
  STRUCT.NBYTES_FOLLOW = NBYTES_FOLLOW

	NTAGS=N_TAGS(STRUCT)

	IF SWAP THEN STRUCT = SWAP_ENDIAN(STRUCT)
;	LLLLLLLLLLLLLLLLLLLLLLLLLLLL
	FOR NTH=0L,NTAGS-1L DO BEGIN
		WRITEU,LUN,STRUCT.(NTH)
	ENDFOR

	CLOSE,LUN
	FREE_LUN,LUN

END; #####################  END OF ROUTINE ################################

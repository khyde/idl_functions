; $ID:	CONTOUR_TIME_DEPTH.PRO,	2020-07-08-15,	USER-KJWH	$

 	FUNCTION CONTOUR_TIME_DEPTH, DATE, DEPTH, DATA,  DELTA=delta, DATE_RANGE=DATE_RANGE,DEPTH_RANGE = depth_range, ERROR=error
;+
; NAME:
; 	CONTOUR_TIME_DEPTH

;	This Program GRIDS Time versus Depth data using IDL'S GRIDDATA
;
;	TIME:	 Date or Julian Day
;	DEPTH: In Meters
;
; MODIFICATION HISTORY:
;		Written June 14,2005  J.O'Reilly, 28 Tarzwell Drive, NMFS, NOAA 02882 (Jay.O'Reilly@NOAA.GOV)
;-

	ROUTINE_NAME='CONTOUR_TIME_DEPTH'


	IF N_PARAMS() LT 3 THEN BEGIN
		ERROR = 1
		RETURN, -1
	ENDIF ELSE ERROR = 0

;	===> Convert Date to JD
	IF IDLTYPE(DATE,/CODE) EQ 7 THEN BEGIN
		JD = DATE_2JD(DATE)
	ENDIF ELSE BEGIN
		ERROR = 1
		RETURN, -1
	ENDELSE


	IF N_ELEMENTS(DATE_RANGE) NE 2 THEN BEGIN
		XRANGE = [MIN(JD),MAX(JD)]
	ENDIF ELSE BEGIN
		XRANGE = DATE_2JD(DATE_RANGE)
	ENDELSE

	IF N_ELEMENTS(DEPTH_RANGE) NE 2 THEN BEGIN
		YRANGE = [MIN(DEPTH),MAX(DEPTH)]
	ENDIF ELSE BEGIN
		YRANGE = [DEPTH_RANGE[0],DEPTH_RANGE[1]]
	ENDELSE

; ===> Establish DELTA, the grid resolution
	IF N_ELEMENTS(DELTA) NE 2 THEN BEGIN
		DELTA = [1,1]
	ENDIF

;	===> time and depth output grid target coordinates
	XOUT =  XRANGE[0] + FINDGEN((XRANGE[1]-XRANGE[0])/DELTA[0] + DELTA[0])*DELTA[0]
	YOUT =  YRANGE[0] + FINDGEN((YRANGE[1]-YRANGE[0])/DELTA[1] + DELTA[1])*DELTA[1]


; ===> Find stations and fill in values from MIN(YOUT) to the first data and from the bottommost data to MAX(YOUT)

	SETS=WHERE_SETS(JD)
	FOR _SET=0L,N_ELEMENTS(SETS)-1L DO BEGIN
		SUBS=WHERE_SETS_SUBS(SETS(_SET))
		_DEPTHS = DEPTH(SUBS)

    XX = INTERP_XTEND( DEPTH(SUBS),DATA(SUBS), YOUT, XTEND=XTEND, /MAKE_MISSING,ERROR=error)
	  OK=WHERE(XTEND EQ 1,COUNT)
	  IF COUNT GE 1 THEN BEGIN

	  	JD=[JD, REPLICATE(JD(SUBS[0]),COUNT)]
	  	DEPTH=[DEPTH,YOUT[OK]]
	  	DATA =[DATA, REPLICATE(MISSINGS(DATA),COUNT)]
	  ENDIF
	ENDFOR





;	===> Pad left and right side with missing data if needed
	IF XRANGE[0] LT MIN(JD) THEN BEGIN
;		===> Pad Left edge with missing data code
 		JD=[REPLICATE(FIRST(XRANGE),N_ELEMENTS(YOUT)),JD]
 		DEPTH=[YOUT,DEPTH]
 		DATA = [REPLICATE(MISSINGS(DATA),N_ELEMENTS(YOUT)),DATA]
	ENDIF

	IF XRANGE[1] GT MAX(JD) THEN BEGIN
;		===> Pad Left edge with missing data code
 		JD=[REPLICATE(LAST(XRANGE),N_ELEMENTS(YOUT)),JD]
 		DEPTH=[YOUT,DEPTH]
 		DATA = [REPLICATE(MISSINGS(DATA),N_ELEMENTS(YOUT)),DATA]
	ENDIF

	START = [MIN(XRANGE),MIN(YRANGE)]


;	===> Reverse yrange
	YRANGE = -REVERSE(YRANGE)


	TRIANGULATE,JD,DEPTH,TRIANGLES
	GRID = GRIDDATA(JD,DEPTH,DATA,/NATURAL_NEIGHBOR,TRIANGLES=TRIANGLES, /GRID,XOUT=XOUT,YOUT=YOUT, MISSING=MISSINGS(DATA) )


;	===> Vertically Flip grid
 	GRID=ROTATE(GRID,7)

	IMAGE = BYTE(GRID) & IMAGE(*,*)=0
	OK = WHERE(GRID GE -1000 AND GRID LE 1000,COUNT)
		IF COUNT GE 1 THEN IMAGE[OK] =BYTSCL(GRID[OK],MIN=-1, MAX=25)
	OK = WHERE(IMAGE EQ MISSINGS(IMAGE),COUNT)
		IF COUNT GE 1 THEN IMAGE[OK] = 255

;	===>
	PSPRINT,/COLOR,/FULL
;	===> Establish x axis lables for Month and Year
 	AX_MONTH 	= DATE_AXIS(XRANGE,/MONTH)
 	AX_YEAR 	= DATE_AXIS(XRANGE,/YEAR)


	IMG_CON, IMAGE,IMAGE,XMARGIN=[0,0],YMARGIN=[0,0] ,  nocontour=NOCONTOUR,XSTYLE=1,YSTYLE=1,YRANGE=YRANGE, XRANGE=XRANGE,$
   		XTICKNAME=AX_MONTH.TICKNAME,  XTICKS=AX_MONTH.TICKS,$;,  XTICKV=AX_MONTH.TICKV,$
		YTITLE='Depth (m)',levels=CONTOUR_LEVELS,c_colorS=CONTOUR_COLORS,C_ANNOTATION=CONTOUR_LABELS, BACKGROUND=255, _EXTRA=_extra

;	AXIS, XAXIS = 0 ,XSTYLE=1,XTITLE=XTITLE,XTICKLEN= -0.02,COLOR=0,XTHICK=2,XTICKNAME=AX_MONTH.TICKNAME,XTICKV=AX_MONTH.TICKV,XTICKS=AX_MONTH.TICKS

  GRIDS,XX=AX_YEAR.TICKV, /NO_Y, COLOR = 0, THICK = 1

PSPRINT
RETURN,GRID

STOP



END; #####################  End of Routine ################################

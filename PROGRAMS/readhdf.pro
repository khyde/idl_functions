; $ID:	READHDF.PRO,	2020-06-30-17,	USER-KJWH	$
;########################################################################################
FUNCTION READHDF, FILE, PRODUCTS=PRODUCTS,ATT=ATT,KEEP=KEEP
;+
; NAME: READHDF;
; PURPOSE:	READ AN HDF FILE AND RETURN ITS CONTENTS AS AN IDL STRUCTURE
; 
; CATEGORY: READ
; 
; CALLING SEQUENCE: RESULT = READHDF(FILE)
; INPUTS:  AN HDF FILE
;
; KEYWORD PARAMETERS:
;       PRODUCTS: THE NAMES OF THE PRODUCTS IN THE HDF THAT YOU WANT;
;       ATT : THE ATTRIBUTES IN THE HDF THAT YOU WANT;[!NOT WORKING YET]
;       KEEP: DO NOT DELETE THE HDF FILE
;
; OUTPUTS:
;       A STRUCTURE WITH THE SCIENTIFIC DATA AND ATTRIBUTES IN THE HDF FILE,[OR JUST THOSE PRODUCTS SPECIFIED]
; EXAMPLES:
; FILE = 'D:\IDL\HDF\S1997247162631.L2_GAC_OC.HDF' & PRODUCTS=['CHLOR_A','LONGITUDE','LATITUDE'] & S = READHDF(FILE,PRODUCTS=PRODUCTS) & HELP,S
;       
;       
;MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, JAN, 1997.
;       MODIFIED DEC 29,1998 JOR.
;       APRIL 9,1999 ADDED MAX_ATTR
;       JUNE 1,2000  MODIFED PRODUCTS FROM INTEGER TO SEADAS PRODUCT NAMES (E.G. NLW443, CHLOR_A, ETC).
;				 AUG 10, 2003 JOR ADDED CAPABILITY TO READ JPL PATHFINDER FILES
;				 AUG 10, 2003 JOR, REMOVED BINARY ... SCALING NOW DONE WITH SD_SCALES
;				 SEP 28,2011,JOR, SHORTENED PROGRAM NAME ( READHDF WAS COPIED FROM MY ROUTINE SD_READHDF )
;				 DEC 22,2011,JOR, FIXED BUG (NOW CHANGES DIRECTORY BACK TO WORKING DIR WHEN ENCOUNTERING AN ERROR
;				 DEC 29.2011,JOR, USING IDL_VALIDNAME ILLEGAL CHARACTERS IN THE ATTRIBUTE NAME (TO MAKE VALID TAG NAMES)
;				 DEC 31,2011, JOR, ADDED ATTRIBUTES (HDF_SD_ATTRINFO)
;				 JAN 20.2012, JOR, ADDED FILE NAME TO OUTPUT STRUCTURE
;				 FEB 18,2012,JOR, MAY NOW SPECIFY [SD, ONLY] PRODUCTS TO FIND 
;				 FEB 20,2012,JOR, ADDED CAPABILITY TO READ HDF'S WITHIN BZ2 COMPRESSED FILES
;				 FEB 29,2012,JOR ADDED CAPABILITY TO READ NASA L3B [BINNED ] HDF FILES
;				 MAR 3,2012,JOR, ;===> REDIMENSION THE L3B DATA [1,5940423L] 
;				 AND STUFF THE DATA INTO A COMPLETE L3B ARRAY USING BINS AS SUBSCRIPTS
;				 MAR 6,2012,JOR,NASA OC FILES:
;				             MOVED   FILE=OUTFILE INSIDE BLOCK: 'IF EXT EQ 'BZ2' THEN BEGIN'

;				             IF SENSOR EQ 'S' THEN  N_BINS=5940423L 
 ;                   IF SENSOR EQ 'A' OR SENSOR EQ 'T' THEN N_BINS = 23761676;MODIS AQUA HAS   [~4X SEAWIFS]
 ;      MAR 14,2012,JOR, IT IS NECESSARY TO VERTICALLY FLIP NASA STANDARD MAPPED IMAGES [SMI]:
 ;                       ; ===> IT IS NECESSARY TO VERTICALLY FLIP NASA LEVEL 3 STANDARD MAPPED IMAGES [SMI]
 ;                              OK_TAG = WHERE(TAG_NAMES(STRUCT) EQ 'L3M_DATA',COUNT_TAG)
;                               IF COUNT_TAG EQ 1 THEN STRUCT.L3M_DATA = ROTATE(STRUCT.L3M_DATA,7)
;       FEB 17,20213,JOR  TEMP_DIR =  'E:\READHDF\' 
;       FEB 20,2013,JOR,   HDF_CLOSE,FILEHANDLE
;       APR 14,2013,JOR:   TEMP_DIR =  HDD+':\READHDF\' 
;       APR 16,2013,JOR, REMOVED EXIT IF AN ERROR NOW MESSAGE
;       MAY 3,2013,JOR: ERROR = ' ERROR: ' + OUTFILE + '  IS NOT AN HDF FILE' & REPORT,ERROR
;       AUG 21,2013,JOR CHANGED TO I DRIVE FOR TEMP DIR:  TEMP_DIR =  'I'+':\READHDF\' 
;       SEP 29,2013,JOR IF COMPUTER EQ 'LAPSANG' THEN HDD = 'E'
;       NOV 5,2013,JOR HDD = GET_HDD(3); 
;                      FILE_MKDIR,TEMP_DIR & IF FILE_TEST(TEMP_DIR) EQ 0 THEN STOP   
;       JAN 26,2014,JOR REMOVED COMMENTED BLOCKS  
;       FEB 2,2014,JOR HDD = GET_HDD(4)
;       MAR 1,2014,JOR ADDED KEYWORD KEEP 
;       MAR 27,2014,JOR IF KEYWORD_SET(KEEP) THEN TEMP_DIR = GET_HDD()+'READHDF\' ELSE TEMP_DIR = !S.IDL_TEMP
;                       MOVED BLOCK TO DELETE BEFORE ANY RETURNS OF STRUCT
;       JUL 4,2014,JOR :    IF NOT KEYWORD_SET(KEEP) AND N_ELEMENTS(OUTFILE) EQ 1 THEN FILE_DELETE,OUTFILE




                    

;     NOTES:
;     ALSO SEE IDL HELP ON READ_HDF		HDF		 VD
;     
;     FUTURE MODS: ACCEPT  GZIP FILES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;########################################################################################
;-
;
;************************
ROUTINE_NAME = 'READHDF'
;************************
; READHDF HDF_SD_ENDACCESS  ROTATE  MAX  OPEN  OUTFILE
ERROR=''

; ===>  FILE NAMES (INCLUDING PATH )MUST BE PROVIDED 
IF N_ELEMENTS(FILE) EQ 0 THEN BEGIN
  ERROR = 'ERROR:  FILE NAMES (INCLUDING PATH) MUST BE PROVIDED'
  PRINT,ERROR
  RETURN, ERROR
ENDIF;IF N_ELEMENTS(FILE) EQ 0 THEN BEGIN
IF KEYWORD_SET(KEEP) THEN TEMP_DIR = GET_HDD()+'READHDF\' ELSE TEMP_DIR = !S.IDL_TEMP
 
FILE_MKDIR,TEMP_DIR & IF FILE_TEST(TEMP_DIR) EQ 0 THEN STOP; ===> PARSE THE COMPONENTS OF THE FILE NAME  
FN=FILE_PARSE(FILE)
 
; ****************************************
; ===> SEE IF THE FILE IS COMPRESSED BZ2?
; ****************************************
EXT = STRUPCASE(FN.EXT)

IF EXT EQ 'BZ2' THEN BEGIN
  ;NOTE MANY NASA HDF FILES HAVE COMPOUND EXTENSIONS LIKE 'MAIN.BZ2'
  BZ2_FILE = TEMP_DIR + FN.NAME_EXT
  ; ===> COPY THE BZ2 FILE TO TEMP_DIR
  FILE_COPY,FILE,TEMP_DIR,/OVERWRITE,/ALLOW_SAME
  ; ===> UNCOMPRESS THE BZ2 FILE IN PLACE
  BUNZIP2,BZ2_FILE,OUTFILE=OUTFILE
  ; NOTE THAT OUTFILE = TEMP_DIR +FN.NAME ; [BUNZIP2 REMOVES THE '.BZ2' EXTENSION]
    
  ; ===> SEE IF THE FILE IS AN HDF? IF NOT, RETURN ERROR MESSAGE
  IS_HDF = HDF_ISHDF(OUTFILE)
  IF IS_HDF EQ 0 THEN BEGIN
    ERROR = ' ERROR: ' + OUTFILE + '  IS NOT AN HDF FILE' & REPORT,ERROR
ENDIF ;IF IS_HDF EQ 0 THEN BEGIN
FILE=OUTFILE
  
ENDIF;IF EXT EQ 'BZ2' THEN BEGIN

; ===> ENSURE THAT THE FILE IS AN HDF?
IS_HDF = HDF_ISHDF(FILE)
IF IS_HDF EQ 0 THEN BEGIN
  ERROR = 'ERROR: ' + FILE + '  IS NOT AN HDF FILE'  
  REPORT,ERROR
  RETURN,ERROR
ENDIF; IF IS_HDF EQ 0 THEN BEGIN
;
; ===> OPEN AND GET THE FILEHANDLE
FILEHANDLE = HDF_OPEN(FILE, /READ)

; ===> GET THE SCIENTIFIC DATASET INTERFACE ID FROM THE FILE
SDINTERFACE_ID = HDF_SD_START(FILE)

; ===> GET THE NUMBER OF SCIENTIFIC DATASETS [SD] AND ATTRIBUTES
HDF_SD_FILEINFO,SDINTERFACE_ID,DATASETS,ATTRIBUTES

;=============================================================
;*************************************************************
; ===> R E T R I E V E  N A S A   L 3 B    D A T A   
;*************************************************************
;=============================================================
IF STRPOS(STRUPCASE(FILE),'L3B') NE -1 THEN BEGIN
;===> DEFAULT ASSUMES PRODNAME = 'chlor_a'
  PRODNAME = 'chlor_a'  
  DATA=READ_L3BIN_HDF(FILE,PRODNAME,LON,LAT,BINS,NOBS,WTS)
  
  ;===> REDIMENSION THE L3B DATA [1,N_BINS]
;  ===> GET THE OCEAN COLOR SENSOR LETTER
  SENSOR_LETTER = STRMID(STRUPCASE(FN.NAME),0,1)
  
  IF SENSOR_LETTER EQ 'C' THEN BEGIN
    SENSOR = 'CZCS'
    N_BINS=5940423L
  ENDIF;IF SENSOR_LETTER EQ 'C' THEN BEGIN
  
  IF SENSOR_LETTER EQ 'O' THEN BEGIN
    SENSOR = 'OCTS'
    N_BINS=5940423L
  ENDIF;IF SENSOR_LETTER EQ 'O' THEN BEGIN
  
  IF SENSOR_LETTER EQ 'S' THEN BEGIN
    SENSOR = 'SEAWIFS'
    N_BINS=5940423L
  ENDIF;IF SENSOR_LETTER EQ 'S' THEN BEGIN
  
;===> AQUA & TERRA HAVE ~4X THE NUMBER OF BINS AS DOES SEAWIFS   
  IF SENSOR_LETTER EQ 'A' THEN BEGIN
    SENSOR = 'AQUA'
    N_BINS=23761676
  ENDIF;IF SENSOR_LETTER EQ 'A' THEN BEGIN
  
  IF SENSOR_LETTER EQ 'T' THEN BEGIN
    SENSOR = 'TERRA'
    N_BINS=23761676
  ENDIF;IF SENSOR_LETTER EQ 'T' THEN BEGIN
   
  IF SENSOR_LETTER EQ 'M' THEN BEGIN
    SENSOR = 'MERIS'
    N_BINS=5940423L
  ENDIF;IF SENSOR_LETTER EQ 'S' THEN BEGIN
  
  ;===> PLACE DATA INTO A COMPLETE L3B ARRAY [NBINS] USING BINS SUBSCRIPTS
  L3B = REPLICATE(MISSINGS(DATA),1,N_BINS);[1,N_BINS]
  L3B(BINS) = DATA
  DATA=TEMPORARY(L3B)
    
  TAGNAME = STRUPCASE(IDL_VALIDNAME(PRODNAME, /CONVERT_ALL))
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(TAGNAME,DATA))
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(STRUCT_L3B,'BINS',BINS))
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(STRUCT_L3B,'LON',LON))
  
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(STRUCT_L3B,'LAT',LAT))
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(STRUCT_L3B,'NOBS',NOBS))
  STRUCT_L3B = TEMPORARY(CREATE_STRUCT(STRUCT_L3B,'WTS',WTS))
  IF N_ELEMENTS(ATT) EQ 0 THEN GOTO,DONE
; NOTE IF YOU ALSO WANT THE ATTRIBUTES IN THE L3B FILE COMMENT OUT THE ABOVE GOTO COMMAND  
 
ENDIF;IF STRPOS(OUTFILE),'L3B') NE -1 THEN BEGIN



;#############################################
; ===> R E T R I E V E   A T T R I B U T E S
;#############################################

;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FOR NTH = 0,ATTRIBUTES-1L DO BEGIN 
  HDF_SD_ATTRINFO, SDINTERFACE_ID, NTH, NAME=TAGNAME, TYPE=TYPE, COUNT=COUNT, DATA=DATA, HDF_TYPE=HDF_TYPE
; ===> SUBSTITUTE UNDERSCORES FOR ILLEGAL CHARACTERS IN THE ATTRIBUTE NAME (TO MAKE VALID STRUCTURE NAMES)
  TAGNAME = IDL_VALIDNAME(TAGNAME, /CONVERT_ALL)
  IF NTH EQ 0 THEN BEGIN  
    STRUCT_AT = TEMPORARY(CREATE_STRUCT(TAGNAME,DATA))
  ENDIF ELSE BEGIN
    STRUCT_AT = TEMPORARY(CREATE_STRUCT(STRUCT_AT,TAGNAME,DATA))
  ENDELSE;IF NTH EQ 0 THEN BEGIN
ENDFOR; FOR NTH = 0,ATTRIBUTES-1 DO BEGIN 
;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

;;HDF_VD_GET, VData [, CLASS=variable] [, COUNT=variable] [, FIELDS=variable] [, INTERLACE=variable] [, NAME=variable] [, NFIELDS=variable] [, REF=variable] [, SIZE=variable] [, TAG=variable]
;
;#############################################################
; ===> R E T R I E V E   S C I E N T I F I C   D A T A S E T S  
;#############################################################

;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FOR NTH = 0,DATASETS-1L DO BEGIN
  START_SD= 0
  OLD_NAME = 'JUNK'
  NEXT_SD:
  SDATASET_ID=HDF_SD_SELECT(SDINTERFACE_ID,NTH)
  HDF_SD_GETINFO,SDATASET_ID,NATTS=NATTS,NDIMS=NDIMS,LABEL=LABEL,DIMS=DIMS,TYPE=TYPE,NAME=NAME,UNIT=UNIT
    IF NAME EQ OLD_NAME THEN BEGIN
      PRINT,'SKIPPING DUPLICATE TAG:'+NAME
      GOTO,NEXT_SD    
  ENDIF ELSE BEGIN
    OLD_NAME = NAME
  ENDELSE;  IF OLD_NAME EQ NAME THEN BEGIN
    
  ;===> SUBSTITUTE UNDERSCORES FOR ILLEGAL CHARACTERS IN THE ATTRIBUTE NAME (TO MAKE VALID TAG NAMES)
  TAGNAME = IDL_VALIDNAME(NAME, /CONVERT_ALL)
 
    IF N_ELEMENTS(PRODUCTS) GE 1 THEN BEGIN
    OK = WHERE(STRUPCASE(TAGNAME) EQ STRUPCASE(PRODUCTS),COUNT_PRODUCT)
    
    IF COUNT_PRODUCT EQ 0 THEN BEGIN
      CONTINUE ; >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    ENDIF ELSE BEGIN    
      FOUND_PRODUCTS = 1
    ENDELSE;IF COUNT_PRODUCT EQ 0 THEN BEGIN
    
  ENDIF;IF N_ELEMENTS(PRODUCTS GE 1 THEN BEGIN
; ||||||||||||||||||||||||||||||||||||||||||||
  
  HDF_SD_GETDATA, SDATASET_ID, Data ,START=START
  ;INDEX = HDF_SD_NAMETOINDEX( SDINTERFACE_ID, SDSNAME ); FROM GSFC
;;  vref = HDF_VD_FIND(fileid,'BinIndex')
;STOP
; ===> MAKE STRUCTURE TO HOLD THE DATASETS   
  IF N_ELEMENTS(STRUCT_SD) EQ 0 THEN BEGIN
    STRUCT_SD = CREATE_STRUCT(TAGNAME,DATA)
  ENDIF ELSE BEGIN
    STRUCT_SD = TEMPORARY(CREATE_STRUCT(STRUCT_SD,TAGNAME,DATA))
  ENDELSE;IF N_ELEMENTS(STRUCT_SD) EQ 0 THEN BEGIN
  
ENDFOR;FOR NTH = 0,DATASETS-1L DO BEGIN
; FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

 
GOTO, SKIP_VDATA
;**************************************************************************************
; ===> RETRIEVE V DATA INFO:
;**************************************************************************************

; ===>SET VDATA_ID TO -1 TO RETURN THE FIRST VDATA ID IN THE FILE.
;EACH VGROUP MUST BE GOTTEN WITH ATTACH AND RElEASED WHEN DONE.;
;;HDF_VD_GET, VData [, CLASS=variable] [, COUNT=variable] [, FIELDS=variable] [, INTERLACE=variable] [, NAME=variable] [, NFIELDS=variable] [, REF=variable] [, SIZE=variable] [, TAG=variable]
IF N_ELEMENTS(FIRST_VGROUP) EQ 0  THEN BEGIN

  VGROUP_ID = -1
  FIRST_VGROUP = 1
  OLD_NAME = 'JUNK'  
ENDIF;IF N_ELEMENTS(FIRST_VGROUP) EQ 0  THEN BEGIN


NEXT_VGROUP:



VGROUP_ID = HDF_VD_GETID(FILEHANDLE, VGROUP_ID)
; ===> GET NUMBER OF VGROUPS (IF NONE RESULT = -1 THEN IS CHANGED TO ZERO 0
VGROUP = HDF_VD_ATTACH( FILEHANDLE, VGROUP_ID , /READ)
;;STOP
Result = HDF_Vg_GETNEXT(VGroup, VGROUP_ID)
Result = HDF_VG_ISVD(VGroup, VGROUP_ID)


PRINT,VGROUP
; FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 FOR _VGROUP = 0,VGROUP-1L DO BEGIN
; SET VDATA_ID TO -1 TO RETURN THE FIRST VDATA ID IN THE FILE.
  HDF_VG_GETTRS, VGROUP, VGROUP_ID, Tags, Refs
  HDF_VG_GETINFO, VGROUP, CLASS=CLASS,NAME=NAME ,NENTRIES=NENTRIES,REF=REF,TAG=TAG
  ;HDF_VG_INQTR(VGROUP, SD_TAG, ref)
;STOP
 ;; VG_NEXT=HDF_VG_GETNEXT(VG, VDATA_ID)

;    Result = HDF_VG_NUMBER(VG)



;Result = HDF_SD_ATTRFIND(SDINTERFACE_ID, Name) 
;Result = HDF_GR_GETATTR(VG, VGROUP_ID, values)
;;if name eq 'tilt_ranges' then STOP
;;RESULT = HDF_VD_NATTRS( VGROUP, VGROUP_ID ) 

;;VG_DATA=GET_VDS_IN_VG(FILE, NAME, CLASS)
;;HDF_VD_GET, VDATA , CLASS=CLASS, COUNT=COUNT, FIELDS=FIELDS, INTERLACE=INTERLACE, NAME=NAME, NFIELDS=NFIELDS, REF=REF, SIZE=SIZE, TAG=TAG
;;HDF_VD_ATTRSET, VG, FieldID, Attr_Name, Values, Count; ATTACH
;;HDF_VD_ATTRSET, VG, VGROUP_ID, Attr_Name, Values, Count; ATTACH
;;Result = HDF_VD_ATTRFIND(VG, FieldID, Name) 



  TAGNAME = IDL_VALIDNAME(NAME, /CONVERT_ALL)
  
   IF NAME EQ OLD_NAME THEN BEGIN
    PRINT,'SKIPPING DUPLICATE TAG:'+NAME
;;    GOTO,NEXT_VGROUP   
  ENDIF ELSE BEGIN
  OLD_NAME = NAME
  ENDELSE;  IF OLD_NAME EQ NAME THEN BEGIN
 IF N_ELEMENTS(STRUCT_VG) EQ 0 THEN BEGIN
    STRUCT_VG = TEMPORARY(CREATE_STRUCT(TAGNAME,DATA))
  ENDIF ELSE BEGIN
    IF NAME NE OLD_NAME THEN STRUCT_VG = TEMPORARY(CREATE_STRUCT(STRUCT_VG,TAGNAME,DATA))
  ENDELSE;IF N_ELEMENTS(STRUCT_VG) EQ 0 THEN BEGIN
;;IF N_ELEMENTS(NAME) GE 1 AND NAME[0] NE '' THEN GOTO,NEXT_VGROUP; >>>>>>>>>>>>>>>>>>>>>>>>
ENDFOR; FOR _VGROUP = 0,VGROUP DO BEGIN

SKIP_VDATA:
; 
; 

;**************************************************************************************
;STOP     ;     ===> GET THE IMAGE DATA
;;      HDF_SD_GETDATA,SDATASET_ID,image
; ===> DETERMINE IF ANY 8-BIT IMAGES IN FILE
;;N_8BIT_IMAGES = HDF_DFR8_NIMAGES(FILE)
;;      IF N_8BIT_IMAGES GE 1 THEN BEGIN
;       ===> IF 8-BIT (E.G. JPL PF SST) THEN REREAD TO PROPERLY EXTRACT IMAGE
;;        HDF_DFR8_GETIMAGE,FILE,IMAGE ;;,ORIG_PAL
;;      ENDIF;IF N_8BIT_IMAGES GE 1 THEN BEGIN


;STOP;;;; ===> GET THE ANNOTATIONS ID FROM THE FILEHANDLE
;;;;AN_ID = HDF_AN_START(FILEHANDLE)


  DONE:


;///////////////////////////////////////
; ===> END ACCESS AND CLOSE THE HDF FILE
IF N_ELEMENTS(DATASETS) NE 0 THEN BEGIN
  IF DATASETS GE 1 THEN HDF_SD_ENDACCESS,SDATASET_ID
  HDF_SD_END,SDINTERFACE_ID
  HDF_CLOSE,FILEHANDLE
; ===> MAKE THE FINAL OUTPUT STRUCTURE, INITIALIZING WITH THE HDF FILE NAME	
  STRUCT= CREATE_STRUCT('FILE',FILE)
  ; ===> ADD TO STRUCT WHEN DATA ARE AVAILABLE
  IF N_ELEMENTS(PRODUCTS) GE 1 AND N_ELEMENTS(FOUND_PRODUCTS) EQ 1 THEN BEGIN
    STRUCT=CREATE_STRUCT(STRUCT,STRUCT_SD)
    RETURN,STRUCT
  ENDIF;IF FOUND_PRODUCTS EQ 1 THEN BEGIN
  IF N_ELEMENTS(STRUCT_L3B) GE 1 THEN STRUCT=CREATE_STRUCT(STRUCT,STRUCT_L3B)
	IF N_ELEMENTS(STRUCT_SD) GE 1 THEN STRUCT=CREATE_STRUCT(STRUCT,STRUCT_SD)
  IF N_ELEMENTS(STRUCT_AT) GE 1 THEN STRUCT=CREATE_STRUCT(STRUCT,STRUCT_AT)
  
  ;#####     UNLESS KEEP THEN DELETE FILE [ IF EXISTS]
  IF NOT KEYWORD_SET(KEEP) AND N_ELEMENTS(OUTFILE) EQ 1 THEN FILE_DELETE,OUTFILE
; ===> IT IS NECESSARY TO VERTICALLY FLIP NASA LEVEL 3 STANDARD MAPPED IMAGES [SMI]
 OK_TAG = WHERE(TAG_NAMES(STRUCT) EQ 'L3M_DATA',COUNT_TAG)
 IF COUNT_TAG EQ 1 THEN STRUCT.L3M_DATA = ROTATE(STRUCT.L3M_DATA,7)
   RETURN, STRUCT
ENDIF ELSE BEGIN
  RETURN,'ERROR' 
ENDELSE;IF N_ELEMENTS(DATASETS) NE 0 THEN BEGIN


END ; END OF PROGRAM; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\



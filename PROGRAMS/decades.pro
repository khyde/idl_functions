; $ID:	DECADES.PRO,	2020-07-08-15,	USER-KJWH	$
;#######################################################################################
FUNCTION DECADES, MIN_MAX, HALF=HALF
;+
; NAME:
;		DECADES;
; PURPOSE:
;		THIS FUNCTION GENERATES AN ARRAY OF DECADES IN INCREMENTS OF 1/10TH DECADE
; CATEGORY:
;		NUMERIC
; CALLING SEQUENCE:
;   RESULT = DECADES()
; INPUTS:
;		MIN_MAX: [MIN,MAX] OF EXPONENTS OF BASE 10
;		E.G. [1,3] MEANS [10^1,10^3]
;		IF MIN_MAX IS NOT PROVIDED THEN [-10,10] IS ASSUMED.
; OUTPUTS:
;		AN ARRAY OF DECADES IN INCREMENTS OF 1/10TH DECADE.
;
;	EXAMPLE:
;   PRINT, DECADES() 				
;		PRINT,DECADES[0]				
;		PRINT,DECADES([-1,1])
;   PRINT,DECADES([-1,1],/HALF)
;   PRINT,DECADES([-2,2])
;   PRINT,ROUNDS(DECADES([-1,1]),2)
;   PRINT,STR_ZERO_TRIM(ROUNDS(DECADES([-1,1]),2))
;		PRINT, DECADES([1,-1])	;		DESCENDING ORDER:
;   PRINT, DECADES([-38,38])
;   PRINT, DECADES([0,1])
;   PRINT, DECADES([0,2])
;   PRINT, DECADES([0,3])
;   PRINT, DECADES([0,2],/HALF)
;   PRINT, DECADES([0,3],/HALF)
;   PRINT, DECADES([-2,2],/HALF)
;		PRINT, DECADES([-10,0],/HALF)
;
; 	RESTRITION:
;			SEE IDL'S MACHAR FUNCTION FOR LARGEST AND SMALLEST USABLE FLOATING-POINT AND DOUBLE-PRECISION DATA TYPES.
;     LOWER LIMIT WHEN KEYWORD HALF IS USED IS 1.00000E-010
; MODIFICATION HISTORY:
;		WRITTEN MAY 11,2000 BY J.O'REILLY, 28 TARZWELL DRIVE, NMFS, NOAA 02882 (JAY.O'REILLY@NOAA.GOV)
;		MAY 28,2013,JOR, FORMATTING; ALSO DID NOT COMPILE BECAUSE OF NEW RANGE FUNCTION SO CHANGED 'RANGE' TO '_MIN_MAX' THROUGHOUT
;		SEP 30,2013,JOR INCREADED MNMAX FROM [-10,10] TO MIN_MAX = [-20,20]
;		DEC 25,2013,JOR FIXED HALF LOGIC
;		JAN 15,2014,JOR WHEN HALF THEN VALS  = [0.0000000001, 0.0000000003] 
;		                TO DEAL WITH VERY LOW PROBABILITIES [LNP_FAP]
;
 
;#######################################################################################
;-
;	***********************
ROUTINE_NAME  = 'DECADES'
;************************
;TRIM
;	===> INITIALIZE TENS
	TENS = (FINDGEN(10)+1)

;	===> CONSTRAIN TO [-10,10] IF MIN_MAX NOT PROVIDED
  ;IF N_ELEMENTS(MIN_MAX) EQ 0 OR N_ELEMENTS(MIN_MAX) GT 2 THEN MIN_MAX = [-10,10]
  IF N_ELEMENTS(MIN_MAX) EQ 0 OR N_ELEMENTS(MIN_MAX) GT 2 THEN MIN_MAX = [-20,20]
	IF N_ELEMENTS(MIN_MAX) EQ 1 THEN MIN_MAX=[MIN_MAX,MIN_MAX]

;	===> FIX MIN_MAX AS AN INTEGER
	MIN_MIN_MAX 	= MIN(MIN_MAX,SUB)
	MIN_MAX(SUB) 	= FLOOR(MIN_MAX(SUB))

	MAX_MIN_MAX = MAX(MIN_MAX,SUB)
	MIN_MAX(SUB) = CEIL(MIN_MAX(SUB))

;	===> FLOATING POINTS ARE ONLY ACCURATE TO APPROX. 1E38.  IF MIN_MAX IS HIGHER THEN PROMOTE MIN_MAX TO DOUBLE-PRECISION
	IF MIN_MAX[0] LT -38 OR MIN_MAX[1] GE 38 THEN _MIN_MAX = DOUBLE(MIN_MAX) ELSE _MIN_MAX = MIN_MAX

;	===> DETERMINE IF ASCENDING OR DECENDING STEP
  IF _MIN_MAX[0] GT _MIN_MAX[1] THEN STEP = -1 ELSE STEP = 1

;	===> INITIALIZE ARR TO HOLD OUTPUT
  ARR = 0.0


;	===> LOOP OVER MIN_MAX AND CONCATENATE RESULTS WITH ARR
;	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  FOR N= _MIN_MAX[0],_MIN_MAX[1], STEP DO BEGIN
  	PART = TENS*10.0^(N-1)
    IF N EQ _MIN_MAX[0] THEN ARR = [ARR,PART] ELSE ARR = [ARR, PART(1:*)]
  ENDFOR
; ||||||

	IF KEYWORD_SET(HALF) THEN BEGIN
	 
;#####     CREATE A WIDE RANGING SET OF VALUES 

    VALS  = [0.0000000001, 0.0000000003] 
    
    VALS = [VALS, 1E1*VALS, 1E2*VALS,1E3*VALS,1E4*VALS,1E5*VALS,1E6*VALS,$
             1E7*VALS,1E8*VALS,1E9*VALS,1E10*VALS,1E11*VALS,1E12*VALS,$
             1E13*VALS,1E14*VALS,1E15*VALS,1E16*VALS, 1E17*VALS,1E18*VALS,1E19*VALS,1E20*VALS,1E21*VALS]
    ;||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    ;===> GET A NICE RANGE BRACKETING THE INPUT RANGE
    NR = NICE_RANGE(10.^MIN_MAX)
    ;===> FIND JUST THOSE VALS WITHIN THE NICE RANGE
    OK_VALS = WHERE(VALS GE NR[0] AND VALS LE NR[1],COUNT_VALS)
    IF COUNT_VALS GE 1 THEN BEGIN 
      RETURN,VALS(OK_VALS)
    ENDIF ELSE BEGIN
     MESSAGE,'ERROR: CAN NOT LOCATE VALUES '
    ENDELSE;  
	ENDIF

;	===> RETURN ALL BUT THE INITIALIZED VALUE FOR ARR
  RETURN,ARR(1:*)

END; #####################  END OF ROUTINE ################################

; $ID:	SHM_MAKE.PRO,	2020-06-26-15,	USER-KJWH	$
; 
PRO SHM_MAKE, NAME,PX=PX,PY=PY,PZ=PZ, FILE = FILE,MAPP=MAPP,TYPE=TYPE,SHM_NAME=SHM_NAME,ARR=ARR
; #########################################################################; 
;+
; PURPOSE: THIS PROGRAM LOADS A 1-D OR 2-D OR 3-D ARRAY INTO SHARED MEMORY 
;          OR WRITES THE ARRAY TO A SHARED-MEMORY FILE [IF KEY FILE IS PRESENT]
;
; CATEGORY: SHM_ FAMILY [SHARED MEMORY]
;
; INPUT PARAMETERS: NAME: NAME FOR THE MAPPED SEGEMENT [NOT REQUIRED]
;
; KEYWORDS: 
;           PX............ WIDTH OF ARRAY - OR NUMBER OF ELEMENTS IN ARRAY [INPUT]
;           PY............ HEIGHT OF ARRAY - OR NUMBER OF ELEMENTS IF 2-D [OPTIONAL INPUT]
;           PZ............ 3RD DIMENSION OF ARRAY - OR NUMBER OF ELEMENTS IF 3-D  [# IMAGES AS IN OUR D3 FAMILY] [OPTIONAL INPUT]
;           FILE ......... FILENAME  OF THE SHARED-MEMORY FILE TO WRITE [OPTIONAL INPUT]
;           MAPP.......... MAP NAME   [OPTIONAL INPUT]
;           TYPE.......... IDLTYPE  OF THE ARRAY TO MAKE ='BYT','INT','FLT' OR 'DBL'  [OPTIONAL INPUT, DEFAULT = 'INT']
;           SHM_NAME...... THE NAME OF THE SHARED MEMORY SEGMENT CREATED BY IDL [OUTPUT]
;           ARR........... THE SHM_ARRAY CREATED FROM FILE [OUTPUT]
;           
; OUTPUTS: [MAKES & LOADS THE ARRAY INTO SHARED MEMORY  AS THE VARIABLE: NAME
;          OR IF FILE PROVIDED WRITES THE ARRAY TO A SHARED MEMORY FILE
; 
; NOTES:   RELATED PROGRAMS WILL HAVE ACESS TO THE DATA IN SHM_ARRAY BY THESE TWO STEPS: 
;          1) SEE IF 'SHM_ARRAY' IS IN SHARED MEMORY:  PSHM,/NAMES ... IF SO ...
;          2) SHM_ARRAY = SHMVAR('SHM_ARRAY')

; EXAMPLES:
;        SHM_MAKE,PX=1024,TYPE = 'FLT',SHM_NAME=SHM_NAME & P,SHM_NAME & PSHM & WAIT,1 & SHM_KILL
;        SHM_MAKE,PX=1024,PY = 512,TYPE = 'BYT',SHM_NAME=SHM_NAME  & P,SHM_NAME & PSHM & WAIT,1 & SHM_KILL
;        SHM_MAKE,PX=10,PY = 5,PZ = 2,TYPE = 'BYT',SHM_NAME=SHM_NAME  & P,SHM_NAME & PSHM & WAIT,1 & SHM_KILL
;        SHM_MAKE,'',PX=4320,PY=2160,PZ=0,TYPE = 'INT',SHM_NAME=SHM_NAME & P,SHM_NAME & WAIT,1 & SHM_KILL
;        SHM_MAKE,'JUNK',PX=4320,PY=2160,PZ=0,TYPE = 'INT',SHM_NAME=SHM_NAME & PSHM & WAIT,1 & SHM_KILL
;        SHM_MAKE,'JUNK',PX=4320,PY=2160,PZ=0,TYPE = 'INT',SHM_NAME=SHM_NAME & PSHM & WAIT,1 & SHM_KILL
;
;        ALSO SEE SHM_MAKE_DEMO
;
; MODIFICATION HISTORY:
;     JAN 17, 2016  WRITTEN BY: J.E. O'REILLY
;     JAN 21,2016, JOR
;-
; #########################################################################

;*************************
ROUTINE_NAME  = 'SHM_MAKE'
;*************************
;===> [IF NAME & FILENAME ARE NULL STRINGS THEN SHMMAP ACTS AS IF THEY ARE NOT PRESENT]
IF NONE(NAME) THEN NAME = ''
IF NONE(FILE) THEN FILENAME = ''
IF KEY(FILE) AND NONE(PX) THEN MESSAGE,'ERROR: PX IS REQUIRED'
IF NONE(PY) THEN PY = 0
IF NONE(PZ) THEN PZ = 0
IF NONE(TYPE) THEN TYPE = 'INT'
;===> IF FILE PROVIDED THEN PARSE FILE TO GET PX,PY,PZ
IF KEY(FILE) THEN BEGIN
  FN = PARSE_IT(FILE,/ALL) & PX = FN.PX & PY = FN.PY & PZ = FN.PZ & TYPE = FN.EXT
  IF FILE_TEST(FILE) EQ 1 THEN GOTO,DO_SHMVAR;>>>>>>>>>>>>>>>>>
     
    
  ;===> IF FILE DOES NOT EXIST THEN MAKE IT
  IF FILE_TEST(FILE) EQ 0 THEN BEGIN    
    OPENW, SHM_LUN, FILE, /GET_LUN
    IF PX NE 0 AND PY EQ 0 AND PZ EQ 0 THEN BEGIN
      IF TYPE EQ 'INT' THEN WRITEU, SHM_LUN, INTARR([PX])
      IF TYPE EQ 'FLT' THEN WRITEU, SHM_LUN, FLTARR([PX])
      IF TYPE EQ 'DBL' THEN WRITEU, SHM_LUN, DBLARR([PX])
    ENDIF;IF PX NE 0 AND PY EQ 0 AND PZ EQ 0 THEN BEGIN
      
    IF PX NE 0 AND PY NE 0 AND PZ EQ 0 THEN BEGIN
      IF TYPE EQ 'INT' THEN WRITEU, SHM_LUN, INTARR([PX,PY])
      IF TYPE EQ 'FLT' THEN WRITEU, SHM_LUN, FLTARR([PX,PY])
      IF TYPE EQ 'DBL' THEN WRITEU, SHM_LUN, DBLARR([PX,PY])
    ENDIF;IF PX NE 0 AND PY NE 0 AND PZ EQ 0 THEN BEGIN
      
    IF PX NE 0 AND PY NE 0 AND PZ NE 0 THEN BEGIN      
      IF TYPE EQ 'INT' THEN WRITEU, SHM_LUN, INTARR([PX,PY,PZ])
      IF TYPE EQ 'FLT' THEN WRITEU, SHM_LUN, FLTARR([PX,PY,PZ])
      IF TYPE EQ 'DBL' THEN WRITEU, SHM_LUN, DBLARR([PX,PY,PZ]) 
    ENDIF;IF PX NE 0 AND PY NE 0 AND PZ NE 0 THEN BEGIN
      FREE_LUN, SHM_LUN & CLOSE,SHM_LUN
  ENDIF;IF FILE_TEST(FILE) = 0 THEN BEGIN 
     
 
ENDIF;IF KEY(FILE) THEN BEGIN
;===> DEFAULT EQUIVALENTS TO PASS CODES TO MAKE_ARRAY
TYPES = ['BYT','INT','FLT','DBL']
CODES = [   1,     2,    4,   5 ]
OK = WHERE(TYPES EQ TYPE,COUNT)
IF COUNT EQ 1 THEN CODE = FIRST(CODES[OK]) ELSE MESSAGE,'ERROR: INCORRECT INPUT TYPE'

;===> FIND SHARED MEMORY NAMES AND SHMUNMAP THEM IF ANY MATCH NAME
N= GET_SHM(/NAMES) 
OK = WHERE(N EQ NAME,COUNT) 
IF COUNT GE 1 THEN BEGIN
  SHMUNMAP,N[OK]
  SHM_KILL
  ;===> COPY FILE TO 
ENDIF;IF COUNT GE 1 THEN BEGIN


IF PY EQ 0 AND PZ EQ 0 THEN SHMMAP ,NAME,TYPE = CODE,DIMENSION = [PX],GET_NAME=SHM_NAME,FILENAME = FILE
IF PY NE 0 AND PZ EQ 0 THEN SHMMAP ,NAME,TYPE = CODE,DIMENSION = [PX,PY],GET_NAME=SHM_NAME,FILENAME = FILE,DESTROY_SEGMENT=1
IF PY NE 0 AND PZ NE 0 THEN SHMMAP ,NAME,TYPE = CODE,DIMENSION = [PX,PY,PZ],GET_NAME=SHM_NAME,FILENAME = FILE
DO_SHMVAR:
;###> SINCE SHMMAP WAS SKIPPED WE MUST GET THE SHM_NAME USING GET_SHM(/NAMES)
N = GET_SHM(/NAMES) 
OK = WHERE(N EQ NAME,COUNT) 
IF COUNT EQ 1 THEN SHM_NAME = FIRST(N[OK]) ELSE MESSAGE,/INFORMATIONAL,NAME + ' NOT FOUND IN SHARED MEMORY'
;|||||||||||||||||||||||||||||||||||||||||

DONE:


END; #####################  END OF ROUTINE ################################

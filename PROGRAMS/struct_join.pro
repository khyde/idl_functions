; $ID:	STRUCT_JOIN.PRO,	2020-07-08-15,	USER-KJWH	$
; #################################################################################################
 FUNCTION STRUCT_JOIN, STRUCT1,STRUCT2,STRUCT3,STRUCT4,STRUCT5,STRUCT6,STRUCT7,STRUCT8,STRUCT9,STRUCT10,STRUCT11,STRUCT12,$
                        TAGNAMES=TAGNAMES,SUFFIX=SUFFIX, KEEP_KEYS=KEEP_KEYS,  ERROR=ERROR
;+
;	THIS FUNCTION RELATIONALLY JOINS TWO OR MORE STRUCTURES TO FORM A NEW STRUCTURE
;
; SYNTAX:
;	RESULT = STRUCT_JOIN(STRUCT1, STRUCT2)
;
; OUTPUT:
;	A NEW JOINED STRUCTURE WITH ALL TAGS AND DATA FROM ALL INPUT STRUCTURES
;
; ARGUMENTS:
; 	STRUCT1:	FIRST STRUCTURE (PARENT, ONLY ALLOWED 1 INSTANCE OF KEY VALUE 
; 	USED TO JOIN)
; 	STRUCT2:	SECOND STRUCTURE (CHILDREN, ALLOWED MORE THAN ONE INSTANCE OF KEY VALUE
; 	          USED TO JOIN TO STRUCT2 TO STRUCT1)
;
;	NOTES:			BEFORE USING STRUCT_JOIN USE STRUCT_DUPS 
;	            (AND THE SAME TAGNAMES USED IN THIS PROGRAM TO JOIN)
;							TO SEE IF THERE ARE ANY DUPLICATES THAT NEED TO BE ADDRESSED 
;							(REMOVED) OR TO DETERMINE IF YOU NEED TO ADD AN ADDITIONAL
;							TAG TO THE TAGNAMES USED TO JOIN STRUCTURES
; KEYWORDS:
;		TAGNAMES: THE TAGNAME(S) TO USE TO JOIN THE STRUCTURES (REQUIRED INPUT)
;		KEEP_KEYS: FOR CHECKING ON PROPER JOINING (TAGNAMES USED TO MAKE KEYS FROM STRUCT2 WILL BE CONSERVED,
;							 OTHERWISE, THEY WILL BE REMOVED FROM THE JOINED OUTPUT STRUCTURE)
;
;
; EXAMPLE:
;
;	PRINT,'MOST MATCHUP USING TWO JOINING KEYS A & B'
;	S1=REPLICATE(CREATE_STRUCT('A','1','B','10','C','1_1'),6)
;	S1[1].A = '1' 	& S1(2).A = '1' 	& S1(3).A = '2' 	& S1(4).A = '2' 	& S1(5).A = '3'
;	S1[1].B = '20' 	& S1(2).B = '30' 	& S1(3).B = '40' 	& S1(4).B = '50' 	& S1(5).B = '60'
;	S1[1].C = '2_1' & S1(2).C = '3_1' & S1(3).C = '4_1' & S1(4).C = '5_1' & S1(5).C = '6_1'
;
;	S2=REPLICATE(CREATE_STRUCT('A','1','B','10','C','1_2'),6)
;	S2[1].A = '1' 	& S2(2).A = '1' 	& S2(3).A = '2' 	& S2(4).A = '2' 	& S2(5).A = '3'
;	S2[1].B = '21' 	& S2(2).B = '30' 	& S2(3).B = '40' 	& S2(4).B = '50' 	& S2(5).B = '60'
;	S2[1].C = '2_2' & S2(2).C = '3_2' & S2(3).C = '4_2' & S2(4).C = '5_2' & S2(5).C = '6_2'
;
;	S = STRUCT_JOIN(S1,S2, TAGNAMES=['A','B'])
;	SPREAD,S
	
; THE FOLLOWING EXAMPLE DOES NOT WORK BECAUSE THERE ARE NO MATCHING KEYS
; S1=REPLICATE(CREATE_STRUCT('A','1','B','10','C','1_1'),6) & S1.A = ['1','2','3','4','5','6'] & S1.B = ['10','20','30','40','50','60'] & S1.C = ['a','b','c','d','e','f']
; S2=REPLICATE(CREATE_STRUCT('A','1','B','10','D','1_1'),6) & S2.A = ['1','2','3','4','5','6'] & S2.B = ['1','2','3','4','5','6']       & S2.D = ['a','b','c','d','e','f']
; S = STRUCT_JOIN(S1,S2,TAGNAMES=['A','B'])
; SPREAD, S 
; 
; THE FOLLOWING EXAMPLE DOES NOT WORK BECAUSE THERE IS ONLY ONE ELEMENT IN S1 THERE ARE MATCHING DUPLICATES IN S2
; S1=REPLICATE(CREATE_STRUCT('A','1','B','10','C','1_1'),1) 
; S2=REPLICATE(CREATE_STRUCT('A','1','B','10','D','1_1'),6) & S2.A = ['1','1','3','4','5','6'] & S2.B = ['10','10','30','40','50','60']       & S2.D = ['a','b','c','d','e','f']
; S = STRUCT_JOIN(S1,S2,TAGNAMES=['A','B'])
; SPREAD, S 
; 
; NOTES:
;		THIS ROUTINE EXPECTS THE INPUT STRUCT1, STRUCT2 TO BE SIMPLE (SPREADSHEET OR DATABASE TYPE) STRUCTURES.
;
;		IF ANY OF THE TAGNAMES IN THE SECOND STRUCTURE (STRUCT2) MATCH ANY IN THE FIRST STRUCTURE (STRUCT1)
;		THEN THE DUPLICATE TAGS IN THE SECOND STRUCTURE WILL BE RENAMED WITH A DELIM$ (E.G. $2) TO AVOID DUPLICATE
;		TAGNAMES IN THE FINAL JOINED STRUCTURE.
;
;		THE KEYS USED FOR JOINING ARE FORMED FROM THE STRING CONVERSION OF THE STRUCTURE VALUES IN THE THE KEY TAGNAMES
;
; HISTORY:
;		WRITTEN DEC 17, 2005 BY J.O'REILLY, 28 TARZWELL DRIVE, NMFS, NOAA 02882 (JAY.O'REILLY@NOAA.GOV)
;		JUL 26,2013,JOR FORMATTING
;		AUG 6,2014,JOR ADDED KEYWORD DELIM$
;		MAY 28, 2015 - KJWH: ADDED EXAMPLES TO SHOW HOW STRUCT_JOIN CAN CRASH
;		;##############################################################################################
;-

	
;****************************
ROUTINE_NAME  = 'STRUCT_JOIN'
;****************************

	COMMON _STRUCT_JOIN, DELIM$
	ERROR = ''

;	===> THE DELIM$ TO BE ADDED TO TAGNAMES IN STRUCT2 IF ANY OF THEM ARE DUPLICATES OF TAGNAMES IN STRUCT1
 DELIM$ ='$2'

; ===> GET INFORMATION ON STRUCT1, STRUCT2
  SIZE_STRUCT1=SIZE(STRUCT1,/STRUCT)
  SIZE_STRUCT2=SIZE(STRUCT2,/STRUCT)

  NAMES1   = TAG_NAMES(STRUCT1)
  NAMES2   = TAG_NAMES(STRUCT2)

  N_TAGS1  = N_TAGS(STRUCT1)
  N_TAGS2  = N_TAGS(STRUCT2)

  N1 = SIZE_STRUCT1.N_ELEMENTS
  N2 = SIZE_STRUCT2.N_ELEMENTS

; ===> MAKE SURE STRUCT1 AND STRUCT2 ARE STRUCTURES
  IF SIZE_STRUCT1.TYPE  NE 8 OR SIZE_STRUCT2.TYPE  NE 8 THEN BEGIN
    PRINT,'ERROR: STRUCT1,STRUCT2 MUST BE STRUCTURES WITH SAME NUMBER OF ELEMENTS'
    ERROR = 'ERROR: STRUCT1,STRUCT2 MUST BE STRUCTURES WITH SAME NUMBER OF ELEMENTS' & RETURN, ''
  ENDIF

;	===> ENSURE THAT THE JOINING TAGNAME(S) ARE PROVIDED AND MAY BE FOUND IN BOTH STRUCTURES
	IF N_ELEMENTS(TAGNAMES) EQ 0 THEN BEGIN
		PRINT,'ERROR: MUST PROVIDE TAGNAMES TO USE TO JOIN BOTH STRUCTURES'
		ERROR = 'ERROR: MUST PROVIDE TAGNAMES TO USE TO JOIN BOTH STRUCTURES' & RETURN, ''
	ENDIF

;	===> FIND UNIQUE TAGNAMES
	NAMES = [NAMES1,NAMES2]
	SETS  = WHERE_SETS(NAMES,/ORDER)
	NAMES = SETS.VALUE

;	===> ENSURE THAT THE JOINING TAGNAMES ARE PRESENT IN BOTH STRUCTURES
	POS_1=WHERE_MATCH(NAMES1,TAGNAMES,COUNT_1)
	POS_2=WHERE_MATCH(NAMES2,TAGNAMES,COUNT_2)

	IF COUNT_1 NE N_ELEMENTS(TAGNAMES) OR COUNT_1 NE COUNT_2 THEN BEGIN
		PRINT,'ERROR: THE TAGNAMES PROVIDED MUST BE PRESENT IN BOTH STRUCTURES TO BE JOINED'
		ERROR = 'ERROR: THE TAGNAMES PROVIDED MUST BE PRESENT IN BOTH STRUCTURES TO BE JOINED' & RETURN, ''
	ENDIF

;	===> NUMBER OF KEY TAGNAMES USED TO JOIN BOTH STRUCTURES
	N_KEYS = N_ELEMENTS(POS_1)

	OLD_NAMES = NAMES2
	DUP_TAGNAMES = 0
	CHECK = 1

;	WWWWWWWWWWWWWWWWWWWWWWWWW
	WHILE CHECK EQ 1 DO BEGIN
;		===> FIND THE NAMES IN STRUCT2 REDUNDANT WITH NAMES IN STRUCT1
 		OK=WHERE_IN(NAMES2,NAMES1,COUNT)
;		===> IF NEEDED, RENAME NAMES2 BY ADDING A DELIM$ TO AVOID TAGNAME CONFLICTS IN THE FINAL JOINED STRUCTURE
		IF COUNT GE 1 THEN BEGIN
			NAMES2[OK] =  NAMES2[OK]+ DELIM$
			DUP_TAGNAMES = DUP_TAGNAMES + COUNT
		ENDIF ELSE CHECK = 0
	ENDWHILE
IF KEY(SUFFIX) THEN NAMES2 = REPLACE(NAMES2,DELIM$,SUFFIX)

;	===> IF REQUIRED, RENAME TAGNAMES IN STRUCT2 (DO NOT ALTER THE INPUT STRUCT2)
	IF DUP_TAGNAMES GE 1 THEN _STRUCT2=STRUCT_RENAME(STRUCT2,OLD_NAMES, NAMES2) ELSE _STRUCT2 = STRUCT2

;	===> TEMPLATE FOR OUTPUT JOINED STRUCTURE
	TEMPLATE = STRUCT_2MISSINGS(STRUCT_MERGE(STRUCT1[0],_STRUCT2[0]))

;	===> MAKE UP KEYS TO USE IN JOINING STRUCTURES
	KEY1 = ''
  KEY2 = ''

;	LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
	FOR NTH = 0L,N_KEYS-1L DO BEGIN
		STR1	= STRTRIM(STRUCT1.(POS_1[NTH]),2)
		STR2 	= STRTRIM(_STRUCT2.(POS_2[NTH]),2)

;		===> DETERMINE MAXIMUM LENGTH OF STRINGS SO THEY MAY PADDED WITH LEADING ZEROS
;				 THIS ENSURES THAT THE FINAL RETURNED STRUCTURE WILL BE PROPERLY SORTED BY VALUES
		LEN 	= STRTRIM( MAX(STRLEN(STR1)) > MAX(STRLEN(STR2)) , 2)
		FMT   = '(A'+LEN+')'
		STR1  = STR_SPACE2ZERO(STRING(STR1,FORMAT=FMT))
		STR2  = STR_SPACE2ZERO(STRING(STR2,FORMAT=FMT))
		KEY1 = KEY1 + STR1 + '$'
		KEY2 = KEY2 + STR2 + '$'
	ENDFOR
;	|||||||||||||||||||||||||||||||||||||


; ===> ENSURE THAT THERE ARE NO DUPLICATES IN STRUCT1
	SETS= WHERE_SETS(KEY1)
	IF MAX(SETS.N) GT 1 THEN BEGIN
		MESSAGE, 'ERROR: STRUCT1 CAN NOT HAVE DUPLICATE VALUES FOR THE TAGNAME(S)'
		RETURN,''
	ENDIF

	OK_BOTH=WHERE_MATCH(KEY1,KEY2,COUNT_MATCH,NCOMPLEMENT=NCOMPLEMENT_1,COMPLEMENT=COMPLEMENT_1,VALID=VALID)

 	IF COUNT_MATCH GE 1 THEN BEGIN
;		===> MATCHES
  	BOTH=STRUCT_MERGE(STRUCT1(OK_BOTH),_STRUCT2(VALID))
		ALL = BOTH
		VALUES =  KEY2(VALID)

;		===> ANY IN STRUCT1 NOT IN _STRUCT2 ?
		IF NCOMPLEMENT_1 GE 1 THEN BEGIN
			ONE = REPLICATE(TEMPLATE,NCOMPLEMENT_1)
			STRUCT_ASSIGN,STRUCT1(COMPLEMENT_1),ONE,/NOZERO
			ALL = [ALL,ONE]
			VALUES = [VALUES, KEY1(COMPLEMENT_1)]
		ENDIF

;		===> ANY IN _STRUCT2 NOT IN STRUCT1
		INDX_2 = LINDGEN(N2)
		OK = WHERE_IN(INDX_2, VALID,COUNT_2,NCOMPLEMENT=NCOMPLEMENT_2,COMPLEMENT=COMPLEMENT_2)
		IF NCOMPLEMENT_2 GE 1 THEN BEGIN
			TWO = REPLICATE(TEMPLATE,NCOMPLEMENT_2)
			STRUCT_ASSIGN,_STRUCT2(COMPLEMENT_2),TWO,/NOZERO

			IF NOT KEYWORD_SET(KEEP_KEYS) THEN BEGIN
;				===> FILL IN THE KEY TAGS WITH INFO FROM _STRUCT2
;				LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
  			FOR NTH = 0L,N_KEYS-1L DO BEGIN
  				TWO.(POS_1[NTH]) = _STRUCT2(COMPLEMENT_2).(POS_2[NTH])
  			ENDFOR
  		ENDIF

			ALL= [ALL,TWO]
			VALUES = [VALUES, KEY2(COMPLEMENT_2)]
		ENDIF

	ENDIF ELSE BEGIN

;		===> NO COMMON VALUES FOR THE KEY JOINING TAGNAME(S)
		ONE = REPLICATE(TEMPLATE,N1)
		STRUCT_ASSIGN,STRUCT1,ONE
		VALUES = ONE.(POS_1)
		TWO = REPLICATE(TEMPLATE,N2)
		STRUCT_ASSIGN,_STRUCT2,TWO,/NOZERO
		VALUES = [VALUES,_STRUCT2.(POS_2)]
		ALL=[ONE,TWO]
	ENDELSE


;	===> REMOVE THE REDUNDANT TAGS USED FOR JOINING THE STRUCTURES ?
  IF NOT KEYWORD_SET(KEEP_KEYS) THEN $
  			 ALL = STRUCT_COPY(ALL,TAGNAMES= NAMES2(POS_2) ,/REMOVE)

;	===> SORT ALL BY THE VALUE OF THE KEY TAGNAMES
  SRT=SORT(VALUES)
  DATA = ALL(SRT)


;	===> IF MORE THAN 2 STRUCTURES WERE PROVIDED THEN JOIN THEM AS WELL
	N_STRUCTS = N_PARAMS()

;	****************************************************
;	*** IF MORE THAN 2 INPUT STRUCTURES TO BE JOINED ***
;	****************************************************
	FOR COUNTER = 3,N_STRUCTS DO BEGIN
		TXT = STRTRIM(COUNTER,2)
		DELIM$='$'+ TXT
		CMD = 'COPY2 = STRUCT'+TXT
		A=EXECUTE(CMD)
	  DATA = STRUCT_JOIN(DATA,COPY2,TAGNAMES=TAGNAMES)
	ENDFOR
;	||||||||||||||||||||||||||||||||||||||||||||||||||||


;	===> SET DELIM$ ='$2' TO REINITIALIZE COMMON DELIM$, DELIM$
	DELIM$ ='$2'

  RETURN, DATA
  END; #####################  END OF ROUTINE #############################

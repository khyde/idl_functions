; $ID:	MEDIAN_FILL.PRO,	2020-07-08-15,	USER-KJWH	$
;#############################################################################################
FUNCTION MEDIAN_FILL, ARRAY, BOX=BOX, MISSING=MISSING, FRACT_GOOD=FRACT_GOOD, MASK=MASK, EVEN=EVEN, SHOW=SHOW, VERBOSE=VERBOSE, COUNT

;+
; NAME:
;       MEDIAN_FILL
;
; PURPOSE:
;       FILL IN SMALL AREAS OF MISSING DATA IN ARRAY BY INCREMENTALLY APPLYING A LARGER AND LARGER MEDIAN FILTER
;
; CATEGORY:
;       MATH
;
; CALLING SEQUENCE:
;       RESULT = MEDIAN_FILL(ARRAY,COUNT)
;
; INPUTS;
;		ARRAY...... A 1 OR 2-D ARRAY
;
; KEYWORDS:
;		BOX....... THE RANGE IN WIDTH OF THE BOXES TO USE IN EACH PASS THROUGH MEDIAN 
;  	MISSING... THE MISSING DATA CODE VALUE WHICH WILL BE REPLACED BY NEIGHBORING ARRAY VALUES DURING THE APPLICATION OF THE MEDIAN STEP
;   FRACT_GOOD. THE MINIMUM REQUIRED FRACTION OF THE NUMBER WITHIN THE MEDIAN BOX 
;               THAT MUST BE GOOD DATA (NOT MISSING AND NOT MASKED)
;   MASK......  A 1 OR 2-D MASK OF SAME DIMENSIONS AS THE INPUT ARRAY, 
;               WHERE VALUES TO BE MASKED ARE 1 AND VALUES NOT TO BE MASKED ARE 0
;		EVEN...... IF /EVEN AND THE NUMBER OF ELEMENTS FOUND WITHIN THE MEDIAN BOX IS EVEN 
;		           THEN THE RESULT IS AN AVERAGE (SEE IDL HELP ON MEDIAN)
;   SHOW...... DISPLAY THE BYTE-SCALED ARRAY AFTER EACH STEP
;   VERBOSE... PRINT PROGRAM PROGRESS
;
; OUTPUTS:
;		THE MEDIAN-FILTERED ARRAY WHERE THE MISSING VALUES ARE REPLACED 
;		WITH THE MEDIAN OF ADJACENT NON-MISSING DATA VALUES
;
; OPTIONAL OUTPUTS: 
;   NONE
;
;	EXAMPLE:
;		FIRST GET A LANDMASK WITH LAND = 1'S AND OCEAN = 0'S
;    1)		LANDMASK = READ_LANDMASK('NEC',/LAND) & PMM,LANDMASK
;    2)		PAL_36 & SLIDEW,LANDMASK
;    3)   FILE = !S.DATASETS + 'OC-SEAWIFS-MLAC\NEC\STATS\CHLOR_A-OC4\D_20040908-SEAWIFS-R2010-MLAC-NEC-CHLOR_A-OC4-MEAN.SAVE'
;    4)		ARRAY = STRUCT_READ(FILE) & HELP,ARRAY
;    5)		MED = MEDIAN_FILL(ARRAY, COUNT,BOX=[3,5],MASK=LANDMASK) & P,COUNT
;    6)   SLIDEW,ARRAY,TITLE = 'ARRAY' & SLIDEW,MED,TITLE = 'MEDIAN_FILLED'
;    
;	NOTES:
;
;
; MODIFICATION HISTORY:
;       WRITTEN BY:  J.E.O'REILLY, DEC 10,1998
;       FEB 12, 2015 - JEOR: UPDATED WITH NEW FUNCTIONS,FORMATTING
;       FEB 27, 2015 - JEOR: CHANGED MIN_FRACT TO FRACT_GOOD
;       APR 04, 2015 - JEOR: ADDED PARAM COUNT
;       MAY 17, 2016 - JEOR: CHANGED KEYWORD COUNT_FILLED TO PARAMETER COUNT
;       MAY 21, 2016 - JEOR: IMGR,DATA1,TITLE = ROUNDS(MED)
;       AUG 03, 2017 - KJWH: Formatting
;##############################################################################################
;-
;***************************
  ROUTINE_NAME = 'MEDIAN_FILL'
;***************************
;===> DEFAULTS
  IF NONE(MISSING) THEN MISSING=MISSINGS(ARRAY)

  IF N_ELEMENTS(BOX) EQ 1 THEN BOXX = [BOX,BOX]
  IF N_ELEMENTS(BOX) EQ 2 THEN BOXX = BOX
  IF N_ELEMENTS(BOX) EQ 0 THEN BOXX = [3,3]
  BOXX = BOXX > 3
  IF BOXX[1] LE BOXX[0] THEN BOXX = REVERSE(BOXX)
  COUNT = 0UL
  INCREMENT = 2
  IF NONE(FRACT_GOOD) THEN FRACT_GOOD = 3.0/9.0
  IF N_ELEMENTS(MASK) EQ N_ELEMENTS(ARRAY) THEN USE_MASK = 1 ELSE USE_MASK=0

; ===> GET SIZE OF ARRAY
  SZ = SIZEXYZ(ARRAY)
  PX = SZ.PX
  PY = SZ.PY
  LAST_PX = PX-1L
  LAST_PY = PY-1L

;	===> DO NOT ALTER THE INPUT ARRAY, SO MAKE A COPY INTO DATA1
  DATA1 = ARRAY

;	*************************
  IF USE_MASK EQ 1 THEN BEGIN

;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    FOR MED = BOXX[0], BOXX[1], INCREMENT DO BEGIN
      DATA2 = DATA1
      AROUND = MED/2

;===> MINIMUM NUMBER OF GOOD DATA
      MIN_GOOD = FIX(ROUND((MED^2)*FRACT_GOOD))
      IF KEY(IGNORE_MISSING) THEN MIN_GOOD = 1

;     ===> FIND MISSING PIXELS NOT MASKED
     	TARGETS = WHERE(DATA1 EQ MISSING AND MASK EQ 0,COUNT_MISSING)
     	IF NONE(NUMBER_MISSING) THEN NUMBER_MISSING = COUNT_MISSING
      IF COUNT_MISSING GE 1 THEN BEGIN
;       ===> GET THE 2-D COORDINATES FOR TARGETS
				XY = ARRAY_INDICES(DATA1, TARGETS)
				IX=REFORM(XY(0,*))
				IY=REFORM(XY(1,*))

;       ===> DO A MEDIAN AROUND THE TARGET PIXELS, IGNORING MASKED PIXELS
        FOR NTH = 0L,COUNT_MISSING-1L DO BEGIN
          _PX = IX[NTH]
          _PY = IY[NTH]
;         ===> GET PIXELS FROM ALL DATA FROM A BOX AREA CENTERD AT THE _PX,_PY LOCATION
          BOXL = (_PX - AROUND) > 0
          BOXR = (_PX + AROUND) < LAST_PX
          BOXB = (_PY - AROUND) > 0
          BOXT = (_PY + AROUND) < LAST_PY

          BOX_SET 	= DATA1(BOXL:BOXR, BOXB:BOXT)
          BOX_MASK 	= MASK(BOXL:BOXR, BOXB:BOXT)

         	OK_BOX_SET = WHERE(BOX_SET NE MISSING AND BOX_MASK EQ 0,COUNT_BOX_SET)

;					===> IF COUNT_BOX_SET IS GE THE MINIMUM FRACTION FOR GOOD DATA THEN UPDATE DATA2
          IF COUNT_BOX_SET GE (MIN_GOOD) THEN DATA2(_PX,_PY) = MEDIAN(BOX_SET(OK_BOX_SET),EVEN=EVEN)

        ENDFOR ; FOR NTH = 0L,COUNT_TARGET-1L DO BEGIN
      ENDIF ;    IF COUNT_TARGET GE 1 THEN BEGIN

;     ===> HOW MANY IN DATA1HAVE BEEN FILLED?
      OK = WHERE(DATA1 EQ MISSINGS(DATA1) AND DATA2 NE MISSINGS(DATA2),COUNT_FILLED)
;     ===>  UPDATE COUNT
      IF COUNT_FILLED GE 1 THEN COUNT = COUNT + COUNT_FILLED
      IF KEY(VERBOSE) THEN PRINT,'MED:  ',MED,'  PERCENT FILLED  :',ROUNDS((100.*COUNT)/NUMBER_MISSING,2)
      
;			===> UPDATE DATA1 WITH DATA2
      DATA1=DATA2
      
      IF KEY(SHOW) THEN BEGIN
        PAL_SW3
        IMGR,DATA1,TITLE = ROUNDS(MED)
      ENDIF;IF KEY(SHOW) THEN BEGIN
    ENDFOR ; FOR MED = BOXX(0), BOXX(1) DO BEGIN
 	ENDIF ELSE BEGIN
;	****************
;		===> NO MASK
;		
;		===> DETERMINE WHERE DATA ARE EQUAL TO THE INPUT MISSING CODE, BEFORE CONVERSION TO FLOAT
  	OK_MISSING = WHERE(DATA1 EQ MISSING,COUNT_MISSING)
  	COUNT = [COUNT,COUNT_MISSING]

;		===> IF DOUBLE THEN LEAVE ELSE CONVERT DATA TO FLOAT SO THAT THE NAN SCHEME WILL WORK WITH THE MEDIAN
 		IF IDLTYPE(ARRAY,/CODE) NE 5 THEN DATA1 = FLOAT(ARRAY) ELSE DATA1=ARRAY

;		===> CONVERT ANY MISSING CODE DATA INTO STANDARD MISSINGS CODE (INFINITY)
		IF COUNT_MISSING GE 1 THEN DATA1(OK_MISSING) = MISSINGS(DATA1)

;		===> CONVERT ANY INFINITY TO NAN (SINCE IDL'S MEDIAN IGNORES NAN'S)
		DATA1=INFINITY_2NAN(DATA1)

;		FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    FOR MED = BOXX[0], BOXX[1], INCREMENT DO BEGIN
      DATA2 = MEDIAN(DATA1,MED,EVEN=EVEN)
      OK = WHERE(FINITE(DATA1) EQ 1,COUNT_FIN)
      IF COUNT_FIN GE 1 THEN BEGIN
        DATA2[OK] = DATA1[OK]
        DATA1=DATA2
      ENDIF
    ENDFOR;FOR MED = BOXX(0), BOXX(1), INCREMENT DO BEGIN
    ;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    
  ENDELSE ; IF _MASK EQ 0 THEN BEGIN
;	*******



  RETURN,DATA2

END; #####################  END OF ROUTINE ################################
